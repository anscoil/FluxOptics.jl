var documenterSearchIndex = {"docs":
[{"location":"api/metrics/metrics/#Metrics-API","page":"API","title":"Metrics API","text":"","category":"section"},{"location":"api/metrics/metrics/#Abstract-Types","page":"API","title":"Abstract Types","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.AbstractMetric","page":"API","title":"FluxOptics.Metrics.AbstractMetric","text":"AbstractMetric\n\nAbstract base type for optimization metrics in inverse optics design.\n\nMetrics are callable objects that evaluate optimization objectives on optical fields. They encapsulate target references and pre-allocated buffers for efficient gradient computation during iterative optimization.\n\nInterface\n\nSubtypes must implement:\n\ncompute_metric(m::AbstractMetric, u::NTuple{N, ScalarField}): Evaluate metric\nbackpropagate_metric(m::AbstractMetric, u::NTuple{N, ScalarField}, ∂c): Compute gradients\n\nCallable Interface\n\nAll metrics are callable:\n\nmetric = PowerCoupling(target)\nloss = metric(u)                    # Single field\nlosses = metric(u1, u2)             # Multiple fields\n\nAvailable Metrics\n\nDotProduct: Complex overlap integral ⟨u,v⟩\nPowerCoupling: Power coupled to target modes\nSquaredFieldDifference: Field amplitude/phase matching\nSquaredIntensityDifference: Intensity pattern matching\n\nDesign Philosophy\n\nStateful: Pre-allocate buffers at construction for zero-allocation evaluation\nFlexible: Support single or multiple fields, mode-selective or full matrices\nEfficient: Custom gradient implementations via backpropagate_metric\nComposable: Combine metrics for multi-objective optimization\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Core-Functions","page":"API","title":"Core Functions","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.AbstractMetric-Tuple{ScalarField}","page":"API","title":"FluxOptics.Metrics.AbstractMetric","text":"(m::AbstractMetric)(u::Vararg{ScalarField})\n(m::AbstractMetric)(u::ScalarField)\n\nCallable interface for metrics. Equivalent to compute_metric(m, u).\n\nThis is the preferred way to evaluate metrics.\n\nExamples\n\nmetric = PowerCoupling(target)\n\n# Single field\nloss = metric(u)\n\n# Multiple fields\nmetric_multi = DotProduct(target1, target2)\nlosses = metric_multi(u1, u2)\n\nSee also: compute_metric\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.compute_metric","page":"API","title":"FluxOptics.Metrics.compute_metric","text":"compute_metric(m::AbstractMetric, u::NTuple{N, ScalarField})\ncompute_metric(m::AbstractMetric, u::ScalarField)\n\nEvaluate a metric on one or more optical fields.\n\nThis is the core evaluation function for metrics. In practice, prefer using the callable interface metric(u) which calls this function internally.\n\nArguments\n\nm::AbstractMetric: The metric to evaluate.\nu: Single ScalarField or tuple of ScalarFields.\n\nReturns\n\nArray(s) containing metric values. Dimensions depend on the specific metric type and whether mode_selective=true.\n\nExamples\n\nmetric = PowerCoupling(target)\n\n# Callable interface (preferred)\nloss = metric(u)\n\n# Explicit call (equivalent)\nloss = compute_metric(metric, u)\n\n# Multiple fields\nmetric_multi = DotProduct(target1, target2)\nlosses = compute_metric(metric_multi, (u1, u2))\n\nSee also: backpropagate_metric, AbstractMetric\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.backpropagate_metric","page":"API","title":"FluxOptics.Metrics.backpropagate_metric","text":"backpropagate_metric(m::AbstractMetric, u::NTuple{N, ScalarField}, ∂c)\n\nCompute gradients of metric with respect to input fields.\n\nUsed internally by automatic differentiation. Most users don't need to call this directly.\n\nArguments\n\nm::AbstractMetric: The metric.\nu: Tuple of input fields.\n∂c: Gradient w.r.t. metric output.\n\nReturns\n\nTuple of ScalarFields containing gradients w.r.t. each input field.\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/metrics/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"using FluxOptics\n\n# Create metric\ntarget = ScalarField(target_data, (2.0, 2.0), 1.064)\nmetric = PowerCoupling(target)\n\n# Evaluate metric\nu = system()\nloss = compute_metric(metric, u)\n\n# Or use callable interface\nloss = metric(u)\n\n# With multiple fields\nmetric_multi = DotProduct(target1, target2)\nlosses = metric_multi(u1, u2)","category":"page"},{"location":"api/metrics/metrics/#Dot-Product-Metrics","page":"API","title":"Dot Product Metrics","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.DotProduct","page":"API","title":"FluxOptics.Metrics.DotProduct","text":"DotProduct(fields...; mode_selective::Bool=true)\n\nCompute dot product (inner product) between optical fields for optimization.\n\nThis metric calculates the complex overlap integral ⟨u,v⟩ between fields, commonly used  for mode coupling analysis and field matching objectives in inverse design.\n\nArguments\n\nfields...: Reference ScalarField(s) to compare against.\nmode_selective::Bool=true: If true, compute per-mode overlaps. If false, compute full overlap matrix.\n\nMathematical definition\n\n⟨u,v⟩ = ∫∫ u*(x,y) v(x,y) dx dy\n\nExamples\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 2);\n\njulia> data[3:end,:,2] .= -ones(ComplexF64, 2, 4);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> normalize_power!(u);\n\njulia> metric_selective = DotProduct(u);\n\njulia> metric_selective(u)\n1×1×2 Array{ComplexF64, 3}:\n[:, :, 1] =\n 1.0 + 0.0im\n\n[:, :, 2] =\n 1.0 + 0.0im\n\njulia> metric_non_selective = DotProduct(u; mode_selective = false);\n\njulia> metric_non_selective(u)\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\nSee also: PowerCoupling\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Mode-selective dot product (default)\ntarget = ScalarField(target_data, (64, 64, 3), (2.0, 2.0), 1.064)\nmetric = DotProduct(target; mode_selective=true)\n\nu = system()\noverlaps = metric(u)  # 1×1×3 array (per-mode)\n\n# Full overlap matrix\nmetric_full = DotProduct(target; mode_selective=false)\noverlap_matrix = metric_full(u)  # 3×3 matrix\n\n# Multiple targets\nmetric_multi = DotProduct(target1, target2)\noverlaps = metric_multi(u1, u2)","category":"page"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.PowerCoupling","page":"API","title":"FluxOptics.Metrics.PowerCoupling","text":"PowerCoupling(fields...; mode_selective::Bool=true)\n\nCompute power coupled into target optical modes.\n\nThis metric calculates |⟨u,v̂⟩|², the optical power (in Watts) coupled from field u  into normalized target modes v̂. The target fields are copied and normalized internally  to unit power, leaving the original fields unmodified.\n\nArguments\n\nfields...: Target ScalarField(s) to couple into (copied and normalized internally).\nmode_selective::Bool=true: If true, compute per-mode coupling. If false, compute full coupling matrix.\n\nMathematical definition\n\nP_coupled = |⟨u,v̂⟩|² where v̂ are normalized copies of the target fields\n\nExamples\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 2);\n\njulia> data[3:end,:,2] .= -ones(ComplexF64, 2, 4);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> normalize_power!(u);\n\njulia> metric_selective = PowerCoupling(u);\n\njulia> metric_selective(u)\n1×1×2 Array{Float64, 3}:\n[:, :, 1] =\n 1.0\n\n[:, :, 2] =\n 1.0\n\njulia> metric_non_selective = PowerCoupling(u; mode_selective = false);\n\njulia> metric_non_selective(u)\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\nSee also: DotProduct\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Examples-3","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Single target mode\ntarget = ScalarField(target_data, (128, 128), (2.0, 2.0), 1.064)\nnormalize_power!(target)  # Not required - done internally\n\nmetric = PowerCoupling(target)\nu = system()\npower_coupled = metric(u)[]  # Scalar power in Watts\n\n# Multi-mode coupling\nmodes_data = generate_mode_stack(layout, 128, 128, 2.0, 2.0, Gaussian(15.0))\nmodes = ScalarField(modes_data, (2.0, 2.0), 1.064)\n\nmetric = PowerCoupling(modes; mode_selective=true)\nu = system()\npowers = metric(u)  # Power per mode\n\n# Use in optimization\nfunction loss()\n    u = system()\n    -sum(metric(u))  # Maximize total coupled power\nend","category":"page"},{"location":"api/metrics/metrics/#Field-Difference-Metrics","page":"API","title":"Field Difference Metrics","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.SquaredFieldDifference","page":"API","title":"FluxOptics.Metrics.SquaredFieldDifference","text":"SquaredFieldDifference(fields...)\n\nCompute squared L² norm difference between complex optical fields.\n\nThis metric calculates ‖u - v‖², the squared field difference, commonly used as a loss function for direct field matching in inverse design problems.\n\nArguments\n\nfields...: Reference ScalarField(s) to match against.\n\nMathematical definition\n\nL = ∫∫ |u(x,y) - v(x,y)|² dx dy = ‖u - v‖²\n\nExamples\n\n# Small example for documentation - use larger arrays in practice\njulia> data1 = ones(ComplexF64, 4, 4);\n\njulia> target = ScalarField(data1, (1.0, 1.0), 1.064);\n\njulia> data2 = zeros(ComplexF64, 4, 4);\n\njulia> current = ScalarField(data2, (1.0, 1.0), 1.064);\n\njulia> metric = SquaredFieldDifference(target);\n\njulia> metric(current)\n1×1 Matrix{Float64}:\n 16.0\n\nSee also: SquaredIntensityDifference\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Examples-4","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Complex field matching\ntarget = ScalarField(target_data, (128, 128), (2.0, 2.0), 1.064)\n\nmetric = SquaredFieldDifference(target)\nu = system()\nloss = metric(u)[]\n\n# Multi-mode matching\ntarget_multi = ScalarField(target_data, (64, 64, 3), (2.0, 2.0), 1.064)\nmetric_multi = SquaredFieldDifference(target_multi)\nu_multi = system()\nlosses_per_mode = metric_multi(u_multi)  # 1×1×3 array","category":"page"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.SquaredIntensityDifference","page":"API","title":"FluxOptics.Metrics.SquaredIntensityDifference","text":"SquaredIntensityDifference(field_intensity_pairs...)\n\nCompute squared difference between field intensities and target patterns.\n\nThis metric supports two modes depending on target array dimensions:\n\nFull dimensions: Target has same dimensions as field → compare each mode individually\nSpatial only: Target has only spatial dimensions → compare total intensity across all modes\n\nArguments\n\nfield_intensity_pairs...: Tuples of (ScalarField, targetintensityarray).\n\nMathematical definition\n\nFull dimensions case: L = ∫∫ |uₖ(x,y)|² - Itargetₖ(x,y)|² dx dy (per mode)\n\nSpatial only case: L = ∫∫ |(∑ₖ |uₖ(x,y)|²) - Itarget(x,y)|² dx dy (total intensity)\n\nExamples\n\nFull dimensions case (mode-by-mode comparison):\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 2);\n\njulia> field = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> target_intensity = zeros(4, 4, 2);  # Same dimensions as field\n\njulia> metric = SquaredIntensityDifference((field, target_intensity));\n\njulia> metric(field)\n1×1×2 Array{Float64, 3}:\n[:, :, 1] =\n 16.0\n\n[:, :, 2] =\n 16.0\n\nSpatial only case (total intensity comparison):\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 3);\n\njulia> field = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> target_intensity = 3*ones(4, 4);  # Only spatial dimensions\n\njulia> metric = SquaredIntensityDifference((field, target_intensity));\n\njulia> metric(field)\n1×1 Matrix{Float64}:\n 0.0\n\nSee also: SquaredFieldDifference\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Examples-5","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Mode-by-mode intensity matching\ntarget_intensity = abs2.(target_data)  # 128×128×3\nu = ScalarField(ones(ComplexF64, 128, 128, 3), (2.0, 2.0), 1.064)\n\nmetric = SquaredIntensityDifference((u, target_intensity))\nloss_per_mode = metric(u)  # 1×1×3 array\n\n# Total intensity matching (summed over modes)\ntarget_intensity_total = sum(abs2.(target_data), dims=3)[:,:,1]  # 128×128\nmetric_total = SquaredIntensityDifference((u, target_intensity_total))\nloss_total = metric_total(u)[]  # Scalar\n\n# Multiple field-target pairs\nmetric_multi = SquaredIntensityDifference(\n    (field1, target1),\n    (field2, target2)\n)\nlosses = metric_multi(field1, field2)","category":"page"},{"location":"api/metrics/metrics/#Optimization-Patterns","page":"API","title":"Optimization Patterns","text":"","category":"section"},{"location":"api/metrics/metrics/#Basic-Optimization","page":"API","title":"Basic Optimization","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"using Zygote, Optimisers\n\n# Setup system and metric\nsystem = source |> phase_mask |> propagator\ntarget = ScalarField(target_data, (2.0, 2.0), 1.064)\nmetric = PowerCoupling(target)\n\n# Loss function\nfunction loss()\n    u = system()\n    -metric(u)[]  # Maximize coupling (minimize negative)\nend\n\n# Optimize\nparams = Functors.fmap(trainable, system)\nopt_state = Optimisers.setup(Optimisers.Adam(0.01), params)\n\nfor iter in 1:100\n    grads = gradient(loss, params)[1]\n    Optimisers.update!(opt_state, params, grads)\nend","category":"page"},{"location":"api/metrics/metrics/#Multi-Objective-Optimization","page":"API","title":"Multi-Objective Optimization","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Combine multiple metrics\ntarget_mode = ScalarField(mode_data, (2.0, 2.0), 1.064)\ntarget_intensity = desired_intensity_pattern\n\nmetric_coupling = PowerCoupling(target_mode)\nmetric_intensity = SquaredIntensityDifference((target_mode, target_intensity))\n\nfunction combined_loss()\n    u = system()\n    α = 0.7  # Weighting factor\n    α * (1.0 - metric_coupling(u)[]) + (1-α) * metric_intensity(u)[]\nend","category":"page"},{"location":"api/metrics/metrics/#Mode-Selective-Optimization","page":"API","title":"Mode-Selective Optimization","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Optimize specific modes\nmodes = ScalarField(mode_stack, (2.0, 2.0), 1.064)\nmetric = PowerCoupling(modes; mode_selective=true)\n\nfunction selective_loss()\n    u = system()\n    powers = metric(u)\n    \n    # Weight different modes\n    weights = [1.0, 0.5, 0.2]  # Prioritize first mode\n    -sum(reshape(weights, 1, 1, 3) .* powers)\nend","category":"page"},{"location":"api/metrics/metrics/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/metrics/metrics/#Metric-Types","page":"API","title":"Metric Types","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"All metrics are subtypes of AbstractMetric\nMetrics are callable: metric(field) calls compute_metric\nSupport single or multiple field arguments","category":"page"},{"location":"api/metrics/metrics/#Mode-Selectivity","page":"API","title":"Mode Selectivity","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"mode_selective=true: Compute per-mode metrics (diagonal)\nmode_selective=false: Compute full coupling matrix\nAffects output dimensionality and computational cost","category":"page"},{"location":"api/metrics/metrics/#Normalization","page":"API","title":"Normalization","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"PowerCoupling normalizes targets internally (copies first)\nDotProduct uses fields as-is\nConsider normalizing input fields before metrics","category":"page"},{"location":"api/metrics/metrics/#Gradient-Computation","page":"API","title":"Gradient Computation","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"Metrics implement custom backpropagate_metric for efficiency\nCompatible with Zygote and other AD libraries\nGradients flow through metric computations","category":"page"},{"location":"api/metrics/metrics/#Performance","page":"API","title":"Performance","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"Metrics cache internal buffers to avoid allocations\nPre-compute metrics once, reuse for multiple evaluations\nUse in-place operations where possible","category":"page"},{"location":"api/metrics/metrics/#Memory-Layout","page":"API","title":"Memory Layout","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"Metrics store internal arrays matching field structure\nBuffers allocated at construction time\nGPU-compatible when using CuArrays","category":"page"},{"location":"api/metrics/metrics/#Advanced-Usage","page":"API","title":"Advanced Usage","text":"","category":"section"},{"location":"api/metrics/metrics/#Custom-Metric","page":"API","title":"Custom Metric","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Define new metric type\nstruct MyMetric <: AbstractMetric\n    reference::ScalarField\n    buffer::Array{ComplexF64}\nend\n\n# Implement required methods\nfunction compute_metric(m::MyMetric, u::Tuple{ScalarField})\n    # Your metric computation\nend\n\nfunction backpropagate_metric(m::MyMetric, u::Tuple{ScalarField}, ∂c)\n    # Your gradient computation\nend","category":"page"},{"location":"api/metrics/metrics/#Combining-Metrics","page":"API","title":"Combining Metrics","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Wrapper for weighted sum\nstruct WeightedSum{M<:Tuple} <: AbstractMetric\n    metrics::M\n    weights::Vector{Float64}\nend\n\nfunction compute_metric(m::WeightedSum, u::NTuple{N, ScalarField}) where N\n    sum(w * compute_metric(metric, u) for (w, metric) in zip(m.weights, m.metrics))\nend","category":"page"},{"location":"api/metrics/metrics/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"OptimisersExt for optimization algorithms","category":"page"},{"location":"api/gridutils/#GridUtils","page":"GridUtils","title":"GridUtils","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Coordinate systems and transformations for optical field grids.","category":"page"},{"location":"api/gridutils/#Overview","page":"GridUtils","title":"Overview","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"The GridUtils module provides:","category":"page"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Spatial coordinate generation for optical field grids\n2D coordinate transformations (translations, rotations)\nCoordinate composition for complex geometries","category":"page"},{"location":"api/gridutils/#Quick-Example","page":"GridUtils","title":"Quick Example","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"using FluxOptics\n\n# Generate 2D coordinate grid\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\n\n# Create transformation: shift then rotate\ntransform = Rot2D(π/4) ∘ Shift2D(10.0, 5.0)\n\n# Apply to a point\npoint = transform([0.0, 0.0])","category":"page"},{"location":"api/gridutils/#Key-Functions","page":"GridUtils","title":"Key Functions","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"spatial_vectors: Generate coordinate arrays\nShift2D: 2D translation transformation\nRot2D: 2D rotation transformation\nId2D: Identity transformation","category":"page"},{"location":"api/gridutils/#See-Also","page":"GridUtils","title":"See Also","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Modes for using coordinates with optical modes\nFields for ScalarField grid structure","category":"page"},{"location":"api/gridutils/#Index","page":"GridUtils","title":"Index","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Modules = [FluxOptics.GridUtils]\nOrder = [:type, :function]","category":"page"},{"location":"api/metrics/#Metrics","page":"Metrics","title":"Metrics","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Metric types for inverse design optimization.","category":"page"},{"location":"api/metrics/#Overview","page":"Metrics","title":"Overview","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"The Metrics module provides:","category":"page"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Metric types: Object-oriented approach to optimization objectives\nField overlap: DotProduct and PowerCoupling metrics\nField matching: SquaredFieldDifference for complex field matching\nIntensity matching: SquaredIntensityDifference for intensity-based objectives\nAD-compatible: Automatic differentiation support via custom gradients","category":"page"},{"location":"api/metrics/#Quick-Example","page":"Metrics","title":"Quick Example","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"using FluxOptics\n\n# Create target field\ntarget = ScalarField(target_data, (2.0, 2.0), 1.064)\n\n# Power coupling metric\nmetric = PowerCoupling(target)\n\n# Evaluate on current field\nu_current = system()\nloss = metric(u_current)  # Returns power coupled to target\n\n# Use in optimization\nfunction objective()\n    u = system()\n    1.0 - metric(u)[]  # Maximize coupling\nend","category":"page"},{"location":"api/metrics/#Key-Types","page":"Metrics","title":"Key Types","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"DotProduct: Complex overlap integral ⟨u,v⟩\nPowerCoupling: Power coupled to target mode(s)\nSquaredFieldDifference: |u - v|² field matching\nSquaredIntensityDifference: |Iu - Iv|² intensity matching","category":"page"},{"location":"api/metrics/#Key-Functions","page":"Metrics","title":"Key Functions","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"(AbstractMetric): Callable interface (preferred) - evaluate metric\nFluxOptics.Metrics.compute_metric: Explicit evaluation function\nFluxOptics.Metrics.backpropagate_metric: Gradient computation (internal)","category":"page"},{"location":"api/metrics/#See-Also","page":"Metrics","title":"See Also","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"OptimisersExt for optimization algorithms","category":"page"},{"location":"api/metrics/#Index","page":"Metrics","title":"Index","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Modules = [FluxOptics.Metrics]\nOrder = [:type, :function]","category":"page"},{"location":"api/fields/#Fields","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"The ScalarField type and field operations.","category":"page"},{"location":"api/fields/#Overview","page":"Fields","title":"Overview","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"The Fields module provides:","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"ScalarField type: Central data structure for optical fields\nMulti-wavelength support: Handle multiple wavelengths simultaneously\nTilt tracking: Manage off-axis propagation\nField operations: Power, intensity, phase, normalization","category":"page"},{"location":"api/fields/#Quick-Example","page":"Fields","title":"Quick Example","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"using FluxOptics\n\n# Create a field\ndata = ones(ComplexF64, 128, 128, 3)  # 3 modes\nu = ScalarField(data, (2.0, 2.0), [0.8, 1.064, 1.55])\n\n# Field operations\nP = power(u)              # Power per mode\nI = intensity(u)          # Total intensity\nnormalize_power!(u)       # Normalize to unit power\nφ = phase(u)              # Phase distribution\n\n# Access and modify\nu[:, :, 1] .= 0.0        # Clear first mode\nu_copy = copy(u)         # Independent copy","category":"page"},{"location":"api/fields/#Key-Types","page":"Fields","title":"Key Types","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"ScalarField: Optical field with grid information","category":"page"},{"location":"api/fields/#Key-Functions","page":"Fields","title":"Key Functions","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Field Construction and Data","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"ScalarField: Create optical field\nset_field_data: Update field data\nsimilar: Allocate similar field\ncopy: Copy field\nfill!: Fill field with values\ncopyto!: Copy between fields\ncollect: Convert to CPU array","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Field Properties","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"size: Get field dimensions\nndims: Number of dimensions\neltype: Element type","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Tilts Management","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"set_field_tilts: Update field tilts\noffset_tilts!: Add tilt offset with phase correction\nis_on_axis: Check if field is on-axis","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Power and Intensity","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"power: Calculate field power\nnormalize_power!: Normalize to target power\nintensity: Calculate total intensity\nphase: Extract phase distribution","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Field Comparison","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"coupling_efficiency: Coupling efficiency between fields\ndot: Field overlap integral","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Vectorization","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"vec: Vectorize into independent ScalarFields","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Broadcasting and Indexing","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"broadcasted: Element-wise operations\ngetindex: Access field elements\nconj: Complex conjugate","category":"page"},{"location":"api/fields/#See-Also","page":"Fields","title":"See Also","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Modes for generating optical modes\nGridUtils for coordinate systems","category":"page"},{"location":"api/fields/#Index","page":"Fields","title":"Index","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Modules = [FluxOptics.Fields]\nOrder = [:type, :function]","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This section provides detailed documentation for all FluxOptics.jl modules and functions.","category":"page"},{"location":"api/#Quick-Navigation","page":"API Reference","title":"Quick Navigation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"FluxOptics is organized into focused modules for different aspects of optical simulation and inverse design:","category":"page"},{"location":"api/#Foundation","page":"API Reference","title":"Foundation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"GridUtils - Coordinate systems and transformations","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Spatial coordinate generation for optical grids\n2D transformations (translations, rotations)\nCoordinate composition for complex geometries","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modes - Optical mode generation","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Gaussian beam families (Gaussian, Hermite-Gaussian, Laguerre-Gaussian)\nSpatial layouts for multi-mode configurations\nSpeckle generation with controlled statistics","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Fields - Field representation and operations","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"ScalarField type for optical fields\nMulti-wavelength and tilt support\nPower, intensity, and field comparison operations","category":"page"},{"location":"api/#Propagation-and-Components","page":"API Reference","title":"Propagation & Components","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Optical Components - Building blocks for optical systems","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Core: Abstract types, sources, static components (Phase, Mask, TeaDOE)\nFree-Space Propagators: Angular Spectrum, Rayleigh-Sommerfeld, Collins integral\nBulk Propagators: Beam Propagation Method for inhomogeneous media\nActive Media: Gain sheets and amplifiers\nOptical systems with piping syntax","category":"page"},{"location":"api/#Optimization","page":"API Reference","title":"Optimization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"OptimisersExt - Optimization algorithms and rules","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Custom optimization rules (Descent, Momentum, FISTA)\nProximal operators for constrained optimization\nIntegration with Optimisers.jl ecosystem","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Metrics - Loss functions for inverse design","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Field overlap metrics (DotProduct, PowerCoupling)\nField and intensity matching objectives\nCustom gradient implementations for efficiency","category":"page"},{"location":"api/#Design-Philosophy","page":"API Reference","title":"Design Philosophy","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"FluxOptics follows these principles:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Differentiable by design: All components work with automatic differentiation\nGPU-ready: Seamless CUDA.jl integration for acceleration\nComposable: Build complex systems from simple components\nEfficient: Pre-allocated buffers on-demand and optimized kernels\nFlexible: Support for multi-wavelength, multi-mode, and off-axis propagation","category":"page"},{"location":"api/#Typical-Workflow","page":"API Reference","title":"Typical Workflow","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using FluxOptics\n\n# 1. Define spatial grid and modes\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\ngaussian = Gaussian(20.0)\n\n# 2. Create field\nu = ScalarField(gaussian(xv, yv), (2.0, 2.0), 1.064)\n\n# 3. Build optical system\nsource = ScalarSource(u; trainable=true)\nphase = Phase(u, (x, y) -> 0.0; trainable=true)\npropagator = ASProp(u, 1000.0)\nsystem = source |> phase |> propagator\n\n# 4. Define optimization objective\ntarget = ScalarField(target_data, (2.0, 2.0), 1.064)\nmetric = PowerCoupling(target)\n\n# 5. Optimize\nusing Zygote\nloss() = 1.0 - metric(system())[]\n# ... gradient descent ...","category":"page"},{"location":"api/#Module-Overview","page":"API Reference","title":"Module Overview","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pages = [\n    \"gridutils/index.md\",\n    \"modes/index.md\",\n    \"fields/index.md\",\n    \"optical_components/index.md\",\n    \"optimisers/index.md\",\n    \"metrics/index.md\",\n]\nDepth = 1","category":"page"},{"location":"api/gridutils/gridutils/#GridUtils-API","page":"API","title":"GridUtils API","text":"","category":"section"},{"location":"api/gridutils/gridutils/#Spatial-Vectors","page":"API","title":"Spatial Vectors","text":"","category":"section"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.spatial_vectors","page":"API","title":"FluxOptics.GridUtils.spatial_vectors","text":"spatial_vectors(ns::NTuple{Nd,Real}, ds::NTuple{Nd,Real}; offset::NTuple{Nd,Real}=ntuple(_->0, Nd))\nspatial_vectors(nx, dx; xc=0.0)\nspatial_vectors(nx, ny, dx, dy; xc=0.0, yc=0.0)\n\nGenerate spatial coordinate vectors for optical field grids.\n\nCreates coordinate arrays centered at zero with specified sampling and optional offset. Essential for defining spatial grids in optical simulations.\n\nArguments\n\nns::NTuple: Number of points in each dimension.\nds::NTuple: Spatial sampling interval in each dimension (user-defined unit).\noffset::NTuple=ntuple(_->0, Nd): Offset of the zero position from the center of the grid, for each dimension. The center of the grid is then -offset.\n\nReturns\n\nTuple of coordinate vectors, one per spatial dimension. Each coordinate vector is an AbstractRange.\n\nExamples\n\n# 1D case\njulia> x, = spatial_vectors(4, 1.0);\n\njulia> isa(x, AbstractRange)\ntrue\n\njulia> collect(x)\n4-element Vector{Float64}:\n -1.5\n -0.5\n  0.5\n  1.5\n\njulia> x, y = spatial_vectors(4, 4, 1.0, 1.0; xc=2.0); # 2D case with offset\n\njulia> collect(x)\n4-element Vector{Float64}:\n -3.5\n -2.5\n -1.5\n -0.5\n\nSee also: Shift2D, Rot2D\n\n\n\n\n\n","category":"function"},{"location":"api/gridutils/gridutils/#2D-Transformations","page":"API","title":"2D Transformations","text":"","category":"section"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.Shift2D","page":"API","title":"FluxOptics.GridUtils.Shift2D","text":"Shift2D(x::Real, y::Real)\n\nCreate a 2D translation transformation.\n\nRepresents a spatial translation by (x, y) in micrometers. Can be composed  with other transformations using the ∘ operator.\n\nArguments\n\nx::Real: Translation in x direction.\ny::Real: Translation in y direction.\n\nExamples\n\njulia> t = Shift2D(2.0, 3.0);\n\njulia> t([1.0, 1.0])  # Apply transformation\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 3.0\n 4.0\n\njulia> combined = Shift2D(1.0, 0.0) ∘ Rot2D(π/4); # Composition with rotation\n\njulia> combined([1.0, 0.0])  # Rotate then translate\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.7071067811865475\n 0.7071067811865475\n\nSee also: Rot2D, Id2D\n\n\n\n\n\n","category":"type"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.Rot2D","page":"API","title":"FluxOptics.GridUtils.Rot2D","text":"Rot2D(θ::Real)\n\nCreate a 2D rotation transformation.\n\nRepresents a rotation by angle θ (in radians) around the origin.  Can be composed with other transformations using the ∘ operator.\n\nArguments\n\nθ::Real: Rotation angle in radians (positive = counterclockwise).\n\nExamples\n\njulia> r = Rot2D(π/2);  # 90° rotation\n\njulia> r([1.0, 0.0])  # Rotate point\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 6.123233995736766e-17\n 1.0\n\njulia> transform = Rot2D(π/4) ∘ Shift2D(2.0, 0.0); # Composition: translate then rotate\n\njulia> transform([0.0, 0.0])\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.4142135623730951\n 1.414213562373095\n\nSee also: Shift2D, Id2D\n\n\n\n\n\n","category":"type"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.Id2D","page":"API","title":"FluxOptics.GridUtils.Id2D","text":"Id2D()\n\nCreate a 2D identity transformation.\n\nRepresents the identity transformation that leaves coordinates unchanged. Useful as a default value in functions that accept coordinate transformations, or for composing transformation chains where no transformation is needed.\n\nExamples\n\njulia> t = Id2D();\n\njulia> t([1.0, 2.0])  # Apply identity transformation\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 2.0\n\njulia> # Composition with other transformations\n\njulia> combined = Shift2D(1.0, 0.0) ∘ Id2D();\n\njulia> combined([0.0, 0.0])  # Behaves like Shift2D(1.0, 0.0)\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 0.0\n\nSee also: Shift2D, Rot2D\n\n\n\n\n\n","category":"type"},{"location":"api/gridutils/gridutils/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/gridutils/gridutils/#Basic-Coordinate-Generation","page":"API","title":"Basic Coordinate Generation","text":"","category":"section"},{"location":"api/gridutils/gridutils/","page":"API","title":"API","text":"# 1D coordinates\nx, = spatial_vectors(64, 2.0)  # 64 points, 2.0 μm spacing\n\n# 2D coordinates\nxv, yv = spatial_vectors(128, 128, 1.5, 1.5)\n\n# With offset (shift zero position)\nxv, yv = spatial_vectors(128, 128, 1.5, 1.5; xc=10.0, yc=-5.0)","category":"page"},{"location":"api/gridutils/gridutils/#Coordinate-Transformations","page":"API","title":"Coordinate Transformations","text":"","category":"section"},{"location":"api/gridutils/gridutils/","page":"API","title":"API","text":"# Simple translation\nshift = Shift2D(20.0, -10.0)\nnew_point = shift([0.0, 0.0])  # [20.0, -10.0]\n\n# Simple rotation (45°)\nrot = Rot2D(π/4)\nrotated = rot([1.0, 0.0])  # [√2/2, √2/2]\n\n# Composition: translate then rotate\ntransform = Rot2D(π/6) ∘ Shift2D(5.0, 0.0)\nresult = transform([0.0, 0.0])","category":"page"},{"location":"api/gridutils/gridutils/#Use-with-Modes","page":"API","title":"Use with Modes","text":"","category":"section"},{"location":"api/gridutils/gridutils/","page":"API","title":"API","text":"using FluxOptics\n\n# Create offset and rotated Gaussian\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\ngaussian = Gaussian(15.0)\n\n# Apply transformation\ntransform = Shift2D(20.0, 10.0) ∘ Rot2D(π/8)\nfield = gaussian(xv, yv, transform)","category":"page"},{"location":"api/gridutils/gridutils/#Notes","page":"API","title":"Notes","text":"","category":"section"},{"location":"api/gridutils/gridutils/","page":"API","title":"API","text":"All spatial units should be consistent (typically micrometers)\nRotations are counterclockwise for positive angles\nTransformations compose right-to-left: (f ∘ g)(x) = f(g(x))\nOffsets shift the zero position from grid center","category":"page"},{"location":"api/fields/fields/#Fields-API","page":"API","title":"Fields API","text":"","category":"section"},{"location":"api/fields/fields/#ScalarField-Type","page":"API","title":"ScalarField Type","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.ScalarField","page":"API","title":"FluxOptics.Fields.ScalarField","text":"ScalarField(data::AbstractArray{Complex}, ds::NTuple{Nd,Real}, lambdas; tilts=ntuple(_->0, Nd))\nScalarField(nd::NTuple, ds::NTuple{Nd,Real}, lambdas; tilts=ntuple(_->0, Nd))\n\nRepresent a scalar optical field with spatial grid information, wavelength(s), and optional tilt angles.\n\nThis is the central data structure of FluxOptics.jl for storing and manipulating scalar optical fields. The field data can be multi-dimensional with 1 or 2 transverse dimensions and additional dimensions for  different spatial modes. Each mode can hold independent wavelength and tilt information.\n\nConstructors\n\nFrom existing data:\n\ndata::AbstractArray{Complex}: Complex field amplitude data.\nds::NTuple{Nd,Real}: Spatial sampling intervals (dx,[dy]) in micrometers (or meters as long as consistent units are used everywhere).\nlambdas: Wavelength(s) - can be a scalar Real or AbstractArray{Real} for multiple wavelengths. In case of AbstractArray{Real}, it must be broadcastable on the extra dimensions of data (all dimensions except the spatial ones).\ntilts::NTuple{Nd}=ntuple(_->0, Nd): Tilt angles in radians corresponding to a Fourier offset of fx₀ = sin(θx)/λ, fy₀ = sin(θy)/λ. Array arguments to NTuple are accepted as long as they broadcast with the extra non-spatial dimensions of data.\n\nZero-initialized field (convenience):\n\nnd::NTuple: Dimensions of the data array (nx, [ny,] ...).\nOther arguments same as above.\n\nExamples\n\nCreating from existing data:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = rand(ComplexF64, 4, 4);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> size(u)\n(4, 4)\n\nCreating zero-initialized field:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField((4, 4), (1.0, 1.0), 1.064);\n\njulia> size(u)\n(4, 4)\n\nMulti-wavelength field:\n\njulia> wavelengths = [0.8, 1.064, 1.550];\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = zeros(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), wavelengths);\n\nField with initial tilt:\n\njulia> wavelengths = [0.8, 1.064, 1.55];\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = zeros(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064; tilts=(0.01, 0.005));\n\njulia> v = ScalarField(data, (1.0, 1.0), 1.064; tilts=([0.01, 0.02, 0.03], 0));\n\nSee also: set_field_data, power, normalize_power!\n\n\n\n\n\n","category":"type"},{"location":"api/fields/fields/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"using FluxOptics\n\n# From existing data\ndata = rand(ComplexF64, 64, 64)\nu = ScalarField(data, (2.0, 2.0), 1.064)\n\n# Zero-initialized\nu = ScalarField((128, 128), (1.5, 1.5), 1.064)\n\n# Multi-mode field\ndata = zeros(ComplexF64, 128, 128, 5)\nu = ScalarField(data, (2.0, 2.0), 1.064)\n\n# Multi-wavelength field\nλs = [0.8, 1.064, 1.55]\ndata = zeros(ComplexF64, 64, 64, 3)\nu = ScalarField(data, (1.0, 1.0), λs)\n\n# Field with tilts\nu = ScalarField(data, (2.0, 2.0), 1.064; tilts=(0.01, 0.005))","category":"page"},{"location":"api/fields/fields/#Field-Data-Management","page":"API","title":"Field Data Management","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.set_field_data","page":"API","title":"FluxOptics.Fields.set_field_data","text":"set_field_data(u::ScalarField, data::AbstractArray)\n\nCreate a new ScalarField with updated field data, preserving all other parameters.\n\nThis function creates a copy with new amplitude data while keeping the same spatial grid, wavelengths, and tilt information.\n\nArguments\n\nu::ScalarField: Original field.\ndata::AbstractArray: New complex field data.\n\nReturns\n\nNew ScalarField with updated data.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> new_data = rand(ComplexF64, 4, 4);\n\njulia> u_new = set_field_data(u, new_data);\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#Base.similar-Tuple{ScalarField}","page":"API","title":"Base.similar","text":"similar(u::ScalarField)\n\nCreate a new ScalarField with same parameters but uninitialized data.\n\nUseful for creating temporary fields with the same grid, wavelength and tilt structures as an existing field.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> u_tmp = similar(u);  # Same grid/wavelengths/tilts, but data is uninitialized\n\nSee also: copy, set_field_data\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.copy-Tuple{ScalarField}","page":"API","title":"Base.copy","text":"copy(u::ScalarField)\n\nCreate a copy of the scalar field.\n\nCreates a copy of the field data, while sharing the internal representation of other parameters.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> u_copy = copy(u);\n\njulia> # Modifying u_copy.electric will not affect u, but the internal arrays representing\n\njulia> # the wavelengths or tilts must never be modified.\n\nSee also: similar\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.fill!-Tuple{ScalarField, Number}","page":"API","title":"Base.fill!","text":"fill!(u::ScalarField, v) -> ScalarField\n\nFill the electric field with value v in-place.\n\nArguments\n\nu::ScalarField: Field to modify.\nv: Fill value, either a scalar (fills entire field) or array (copied into field).\n\nReturns\n\nModified ScalarField (same as input).\n\nExamples\n\njulia> u = ScalarField((4, 4), (1.0, 1.0), 1.064);\n\njulia> fill!(u, 1.0 + 0.0im);  # Fill with constant\n\njulia> fill!(u, rand(ComplexF64, 4, 4));  # Fill with array\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.copyto!-Tuple{ScalarField, ScalarField}","page":"API","title":"Base.copyto!","text":"copyto!(u::ScalarField, v::ScalarField) -> ScalarField\n\nCopy data from v into u. Modifies u in-place and returns it.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.collect-Tuple{ScalarField}","page":"API","title":"Base.collect","text":"collect(u::ScalarField) -> Array\n\nConvert field data to a regular CPU array. Returns an Array (not a ScalarField).\n\nUseful for converting GPU arrays (e.g., CuArray) to CPU for analysis, plotting, or saving.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> data = collect(u);  # Returns Array, not ScalarField\n\njulia> typeof(data)\nMatrix{ComplexF64} (alias for Array{Complex{Float64}, 2})\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Update field data\nnew_data = rand(ComplexF64, size(u)...)\nu_new = set_field_data(u, new_data)\n\n# Copy and allocate\nu_copy = copy(u)\nu_tmp = similar(u)\n\n# Fill operations\nfill!(u, 1.0 + 0.0im)\nfill!(u, rand(ComplexF64, size(u)...))\n\n# Copy between fields\ncopyto!(u_tmp, u)\n\n# Convert GPU to CPU array\ndata = collect(u)  # Returns Array","category":"page"},{"location":"api/fields/fields/#Field-Properties","page":"API","title":"Field Properties","text":"","category":"section"},{"location":"api/fields/fields/#Base.size-Tuple{ScalarField}","page":"API","title":"Base.size","text":"size(u::ScalarField) -> Tuple\nsize(u::ScalarField, k::Integer) -> Int\n\nReturn the size of the electric field array.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.ndims-Tuple{ScalarField}","page":"API","title":"Base.ndims","text":"ndims(u::ScalarField, spatial::Bool=false) -> Int\n\nReturn number of dimensions. If spatial=true, returns only spatial dimensions (Nd), otherwise returns total dimensions of the electric field array.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.eltype-Tuple{ScalarField}","page":"API","title":"Base.eltype","text":"eltype(u::ScalarField) -> Type\n\nReturn the element type of the electric field.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-3","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Get dimensions\nnx, ny = size(u)[1:2]\nn_modes = size(u, 3)\n\n# Number of dimensions\nndims(u)           # Total dimensions\nndims(u, true)     # Spatial dimensions only\n\n# Element type\neltype(u)  # ComplexF64 or ComplexF32","category":"page"},{"location":"api/fields/fields/#Tilt-Management","page":"API","title":"Tilt Management","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.set_field_tilts","page":"API","title":"FluxOptics.Fields.set_field_tilts","text":"set_field_tilts(u::ScalarField, tilts) -> ScalarField\n\nCreate a new ScalarField with updated tilts, preserving all other parameters.\n\nThis function creates a copy with new tilt values while keeping the same field data, spatial grid, and wavelengths.\n\nArguments\n\nu::ScalarField: Original field.\ntilts: New tilt values as (θx, θy) tuple, where each component can be scalar or array.\n\nReturns\n\nNew ScalarField with updated tilts.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064; tilts=(0.01, 0.0));\n\njulia> u_tilted = set_field_tilts(u, (0.02, 0.01));\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.offset_tilts!","page":"API","title":"FluxOptics.Fields.offset_tilts!","text":"offset_tilts!(u::ScalarField, tilts)\n\nAdd offset to existing tilts and apply corresponding linear phase to the field in-place.\n\nThis function modifies both the tilt metadata and the electric field by:\n\nAdding the offset to the stored tilt values\nMultiplying the field by exp(i 2π/λ (Δθx⋅x + Δθy⋅y)) to maintain consistency\n\nThis shifts the reference frame without rotating the angular spectrum.\n\nArguments\n\nu::ScalarField: Field to modify.\ntilts: Tilt offsets as (Δθx, Δθy) tuple in radians.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064; tilts=(0.01, 0.0));\n\njulia> offset_tilts!(u, (0.005, 0.005));\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.is_on_axis","page":"API","title":"FluxOptics.Fields.is_on_axis","text":"is_on_axis(u::ScalarField) -> Bool\n\nCheck if the field has zero tilts (on-axis propagation).\n\nReturns true if all tilt components are zero, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#Examples-4","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Set new tilts\nu_tilted = set_field_tilts(u, (0.02, 0.015))\n\n# Add tilt offset (modifies tilts and applies phase)\noffset_tilts!(u, (0.01, 0.005))\n\n# Check if on-axis\nis_on_axis(u)  # true/false","category":"page"},{"location":"api/fields/fields/#Power-and-Intensity","page":"API","title":"Power and Intensity","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.power","page":"API","title":"FluxOptics.Fields.power","text":"power(u::ScalarField)\n\nCompute the optical power of the field.\n\nCalculates the spatial integral of the intensity |u|² over the field domain, properly accounting for the spatial sampling.\n\nMathematical definition\n\nP = ∫∫ |u(x,y)|² dx dy ≈ Σᵢⱼ |u[i,j]|² × dx × dy.\n\nReturns\n\nArray of power value(s) with same dimensions as u, spatial dimensions being reduced to size 1.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = rand(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> P = power(u);  # Returns 1×1×3 Array\n\nSee also: normalize_power!\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.normalize_power!","page":"API","title":"FluxOptics.Fields.normalize_power!","text":"normalize_power!(u::ScalarField, target_power=1)\n\nNormalize the field to have specified optical power (in-place modification).\n\nScales the field amplitudes so that the total optical power equals the target values. This is useful for setting consistent power levels between different fields.\n\nArguments\n\nu::ScalarField: Field to normalize (modified in-place)\ntarget_power=1: Target power value(s) - can be a scalar Real or AbstractArray{Real} as long as it can be broadcasted on the field data.\n\nReturns\n\nThe modified field u\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(rand(ComplexF64, 4, 4, 3), (1.0, 1.0), 1.064);\n\njulia> normalize_power!(u);        # Normalize all fields to 1 W\n\njulia> normalize_power!(u, 1e-3);  # Normalize all fields to 1 mW\n\njulia> all(x -> isapprox(x, 1e-3), power(u))\ntrue\n\njulia> # For multiple fields: normalize each field separately\n\njulia> power_values = reshape([1e-3, 2e-3, 3e-3], 1, 1, 3);\n\njulia> normalize_power!(u, power_values);  # Different power per field\n\njulia> isapprox(power(u), power_values)\ntrue\n\nSee also: power\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.intensity","page":"API","title":"FluxOptics.Fields.intensity","text":"intensity(u::AbstractArray, nd::Integer=2)\nintensity(u::ScalarField)\n\nCompute the total intensity |u|² of optical fields or arrays.\n\nCalculates intensity by summing |u|² over all extra dimensions beyond the spatial ones, returning the combined intensity distribution for the spatial dimensions only.\n\nArguments\n\nu::AbstractArray: Array of complex values.\nnd::Integer=2: Number of spatial dimensions (for AbstractArray case only).\nu::ScalarField: Optical field with potentially multiple modes.\n\nMathematical definition\n\nI[i,j] = Σₖ |u[i,j,k]|² where k runs over all extra dimensions\n\nReturns\n\nAbstractArray: Array with spatial dimensions only, extra dims summed.\nScalarField: Array with spatial dimensions only, containing total intensity.\n\nExamples\n\nAbstractArray case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = ones(ComplexF64, 4, 4, 3);  # 2 spatial + 1 extra dim\n\njulia> I = intensity(data, 2);  # Sum over 3rd dimension\n\njulia> size(I)\n(4, 4)\n\njulia> I[1,1]\n3.0\n\nScalarField case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = ones(ComplexF64, 4, 4, 3);  # 3 modes\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> I = intensity(u);  # Returns 4×4 array (total intensity of all 3 modes)\n\njulia> size(I)\n(4, 4)\n\njulia> I[1,1]\n3.0\n\nSee also: power, phase\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.phase","page":"API","title":"FluxOptics.Fields.phase","text":"phase(u::AbstractArray)\nphase(u::ScalarField)\n\nCompute the phase angle of complex arrays or optical fields.\n\nReturns the argument (angle) of complex values in radians, preserving array structure. For optical fields, this gives the wavefront phase information across all modes.\n\nArguments\n\nu::AbstractArray: Array of complex values.\nu::ScalarField: Optical field (uses underlying data array).\n\nMathematical definition\n\nφ = arg(u) = atan(imag(u), real(u))\n\nReturns\n\nAbstractArray: Array of same dimensions containing phase values in radians [-π, π].\nScalarField: Calls phase(u.electric), returns array with phase values.\n\nExamples\n\nAbstractArray case:\n\njulia> data = [1.0+0.0im, 0.0+1.0im, -1.0+0.0im];\n\njulia> phase(data)\n3-element Vector{Float64}:\n 0.0\n 1.5707963267948966\n 3.141592653589793\n\nScalarField case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = [1.0+0.0im 0.0+1.0im; -1.0+0.0im 0.0-1.0im];\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> phase(u)\n2×2 Matrix{Float64}:\n 0.0       1.5708\n 3.14159  -1.5708\n\nSee also: intensity, phase\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#Examples-5","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Single mode field\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\nP = power(u)  # Returns 1×1 array\n\n# Normalize to 1 W\nnormalize_power!(u)\n@assert isapprox(power(u)[], 1.0)\n\n# Normalize to specific power\nnormalize_power!(u, 1e-3)  # 1 mW\n\n# Multi-mode field\ndata = rand(ComplexF64, 64, 64, 3)\nu = ScalarField(data, (1.0, 1.0), 1.064)\nP = power(u)  # Returns 1×1×3 array\n\n# Different power per mode\ntarget_powers = reshape([1.0, 1.5, 2.0], 1, 1, 3)\nnormalize_power!(u, target_powers)\n\n# Total intensity (sum over all modes)\nI_total = intensity(u)  # Returns 2D array\n\n# Phase extraction\nφ = phase(u)  # Returns array same size as u","category":"page"},{"location":"api/fields/fields/#Field-Comparison","page":"API","title":"Field Comparison","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.coupling_efficiency","page":"API","title":"FluxOptics.Fields.coupling_efficiency","text":"coupling_efficiency(u, v)\ncoupling_efficiency(u::ScalarField, v::ScalarField)\n\nCompute the power coupling efficiency between two optical fields.\n\nFor multi-dimensional fields, computes power coupling efficiency between corresponding field distributions (same extra dimension indices). This normalized metric returns values between 0 and 1, representing the fraction of power that would be transferred from field u to field v.\n\nMathematical definition\n\nη = |⟨u,v⟩|² / (‖u‖ ‖v‖)\n\nArguments\n\nu: First field (ScalarField or AbstractArray).\nv: Second field with same spatial dimensions as u.\n\nReturns\n\nFor AbstractArrays: Scalar coupling efficiency [0,1].\nFor ScalarFields: Array of coupling efficiencies, one for each field distribution.\n\nExamples\n\nArray case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ones(ComplexF64, 4, 4);\n\njulia> v = ones(ComplexF64, 4, 4);\n\njulia> coupling_efficiency(u, v)\n1.0\n\nScalarField single-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = ones(ComplexF64, 4, 4);\n\njulia> field2_data = ones(ComplexF64, 4, 4);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> coupling_efficiency(u, v)\n1-element Vector{Float64}:\n 1.0\n\nScalarField multi-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = ones(ComplexF64, 4, 4, 3);\n\njulia> field2_data = ones(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> coupling_efficiency(u, v)\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\nSee also: power\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#LinearAlgebra.dot-Tuple{ScalarField}","page":"API","title":"LinearAlgebra.dot","text":"dot(u::ScalarField, v::ScalarField)\n\nCompute the inner product ⟨u,v⟩ between two optical fields.\n\nFor multi-dimensional fields, computes the dot product between corresponding field distributions (same extra dimension indices).\n\nMathematical definition\n\n⟨u,v⟩ = ∫∫ u(x,y) v(x,y) dx dy ≈ Σᵢⱼ u[i,j] v[i,j]\n\nArguments\n\nu::ScalarField: First field.\nv::ScalarField: Second field with same spatial dimensions as u.\n\nReturns\n\nVector of complex inner products, one for each field distribution.\n\nExamples\n\nSingle-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = rand(ComplexF64, 4, 4);\n\njulia> field2_data = rand(ComplexF64, 4, 4);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> overlap = dot(u, v);  # 0-dimensional Array storing the complex overlap integral\n\nMulti-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = rand(ComplexF64, 4, 4, 3);\n\njulia> field2_data = rand(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> overlaps = dot(u, v);  # 3-element Vector of complex overlaps\n\nSee also: coupling_efficiency, dot, power\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-6","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Modal overlap integral\nu1 = ScalarField(gaussian1(xv, yv), (2.0, 2.0), 1.064)\nu2 = ScalarField(gaussian2(xv, yv), (2.0, 2.0), 1.064)\n\noverlap = dot(u1, u2)  # Complex overlap\nη = coupling_efficiency(u1, u2)  # Real, between 0 and 1\n\n# Multi-mode fields\ndata1 = rand(ComplexF64, 64, 64, 3)\ndata2 = rand(ComplexF64, 64, 64, 3)\nu1 = ScalarField(data1, (2.0, 2.0), 1.064)\nu2 = ScalarField(data2, (2.0, 2.0), 1.064)\n\noverlaps = dot(u1, u2)  # 3-element array\nefficiencies = coupling_efficiency(u1, u2)  # 3-element array","category":"page"},{"location":"api/fields/fields/#Vectorization","page":"API","title":"Vectorization","text":"","category":"section"},{"location":"api/fields/fields/#Base.vec-Tuple{ScalarField}","page":"API","title":"Base.vec","text":"vec(u::AbstractArray, nd::Integer=2)\nvec(u::ScalarField)\n\nConvert multi-dimensional arrays or fields into vector of slices.\n\nFor AbstractArray, splits along dimensions beyond the first nd spatial dimensions. For ScalarField, converts into vector of individual ScalarField objects, each representing a single slice along non-spatial dimensions. Useful for iteration and visualization.\n\nArguments\n\nu: Array or ScalarField to vectorize.\nnd::Integer: Number of spatial dimensions (for AbstractArray case only).\n\nReturns\n\nFor AbstractArray: Vector of array slices along non-spatial dimensions.\nFor ScalarField: Vector of ScalarField objects, one per slice along non-spatial dimensions.\n\nExamples\n\nAbstractArray case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = ones(4, 4, 3);  # 2 spatial dims + 1 extra\n\njulia> slices = vec(data, 2);  # Split after 2 spatial dimensions\n\njulia> length(slices)\n3\n\njulia> size(slices[1])\n(4, 4)\n\nScalarField case:\n\njulia> wavelengths = [0.8, 1.064, 1.550];\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = zeros(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), wavelengths);\n\njulia> u_vec = vec(u);  # Returns Vector{ScalarField} of length 3\n\njulia> length(u_vec)\n3\n\njulia> (u_vec[1].lambdas.val, u_vec[2].lambdas.val, u_vec[3].lambdas.val)\n(0.8, 1.064, 1.55)\n\nSee also: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-7","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Vectorize into individual ScalarFields\nu_vec = vec(u)  # Vector of ScalarField objects\n\n# Iterate over modes\nfor (i, mode_field) in enumerate(u_vec)\n    P_mode = power(mode_field)\n    I_mode = intensity(mode_field)\n    println(\"Mode $i: Power = $(P_mode[])\")\nend\n\n# Collect results\npowers = [power(mode)[] for mode in u_vec]\npeak_intensities = [maximum(intensity(mode)) for mode in u_vec]","category":"page"},{"location":"api/fields/fields/#Broadcasting-and-Indexing","page":"API","title":"Broadcasting and Indexing","text":"","category":"section"},{"location":"api/fields/fields/#Base.Broadcast.broadcasted-Tuple{Function, ScalarField}","page":"API","title":"Base.Broadcast.broadcasted","text":"broadcasted(f::Function, u::ScalarField) -> ScalarField\n\nApply function f element-wise to the electric field. Returns a new ScalarField with transformed data.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.getindex-Tuple{ScalarField, Any}","page":"API","title":"Base.getindex","text":"getindex(u::ScalarField, i...)\n\nAccess elements of the electric field. Returns a view into the field data.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.conj-Tuple{ScalarField}","page":"API","title":"Base.conj","text":"conj(u::ScalarField) -> ScalarField\n\nReturn complex conjugate of the field. Creates a new field with conjugated electric field values.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-8","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Broadcasting\nu_scaled = 2.0 .* u\nu_shifted = u .+ 1.0\n\n# Indexing (returns view)\nmode_1 = u[:, :, 1]\nrow = u[32, :, :]\n\n# Complex conjugate\nu_conj = conj(u)","category":"page"},{"location":"api/fields/fields/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/fields/fields/#Data-Layout","page":"API","title":"Data Layout","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"First Nd dimensions: spatial (x, y for 2D)\nRemaining dimensions: modes, wavelengths, etc.\nContiguous in memory for performance","category":"page"},{"location":"api/fields/fields/#Wavelength-Handling","page":"API","title":"Wavelength Handling","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Single wavelength: stored as scalar, broadcast to field\nMultiple wavelengths: array broadcasts with extra (non-spatial) dimensions","category":"page"},{"location":"api/fields/fields/#Tilt-Handling","page":"API","title":"Tilt Handling","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Tilts are passed as (θx, θy) tuples (scalars or arrays) to the constructor\nInternally stored as tuple of arrays for in-place modification\nEach tilt component broadcasts with extra (non-spatial) dimensions\nTilts represent Fourier offset: fx₀ = sin(θx)/λ","category":"page"},{"location":"api/fields/fields/#Power-Calculation","page":"API","title":"Power Calculation","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Power = ∫∫ |u(x,y)|² dx dy\nNumerical integration: P ≈ Σᵢⱼ |u[i,j]|² × dx × dy\nUnits depend on field amplitude units and spatial units","category":"page"},{"location":"api/fields/fields/#Intensity-vs-Power","page":"API","title":"Intensity vs Power","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Intensity: |u(x,y)|² (per unit area)\nPower: Spatial integral of intensity\nFor multi-mode: intensity sums over modes, power is per-mode","category":"page"},{"location":"api/fields/fields/#Coupling-Efficiency","page":"API","title":"Coupling Efficiency","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"η = |⟨u₁,u₂⟩|² / (‖u₁‖ ‖u₂‖)\nAlways real, between 0 and 1\nInsensitive to global phase\nEquals 1 for identical fields","category":"page"},{"location":"api/fields/fields/#Memory-Considerations","page":"API","title":"Memory Considerations","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"copy() creates independent copy of data\nsimilar() allocates uninitialized memory\nset_field_data() creates new field using provided data and same other parameters\nUse views for slicing without copying","category":"page"},{"location":"api/fields/fields/#Performance-Tips","page":"API","title":"Performance Tips","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Pre-allocate: Use similar() for temporary fields\nIn-place operations: Modify .electric directly when possible\nAvoid unnecessary copies: Use set_field_data() or views\nVectorization: Use vec() only when needed for iteration\nGPU: Field data can be moved to GPU with CUDA.cu(u)","category":"page"},{"location":"api/fields/fields/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Modes for generating field data\nGridUtils for coordinate systems","category":"page"},{"location":"api/modes/#Modes","page":"Modes","title":"Modes","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Optical mode generation and spatial layouts.","category":"page"},{"location":"api/modes/#Overview","page":"Modes","title":"Overview","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"The Modes module provides:","category":"page"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Gaussian beam families (Gaussian, Hermite-Gaussian, Laguerre-Gaussian)\nSpatial layouts for mode composition and multi-mode configurations\nSpeckle generation with controlled statistics and envelope\nMode stacks for multi-mode generation","category":"page"},{"location":"api/modes/#Quick-Example","page":"Modes","title":"Quick Example","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"using FluxOptics\n\n# Single Gaussian mode\ngaussian = Gaussian(20.0)  # 20 μm waist\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nfield = gaussian(xv, yv)\n\n# Array of Hermite-Gaussian modes\nmodes = hermite_gaussian_groups(15.0, 4)  # All HG modes up to order 3\n\n# Spatial layout with replicated modes\nlayout = GridLayout(3, 3, 50.0, 50.0)  # 3×3 grid\nmode_stack = generate_mode_stack(layout, 128, 128, 2.0, 2.0, gaussian)","category":"page"},{"location":"api/modes/#Key-Types","page":"Modes","title":"Key Types","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Gaussian, HermiteGaussian, LaguerreGaussian: Beam modes\nPointLayout, GridLayout, TriangleLayout: Spatial arrangements\nCustomLayout: User-defined layouts","category":"page"},{"location":"api/modes/#Key-Functions","page":"Modes","title":"Key Functions","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"hermite_gaussian_groups: Generate complete mode sets\ngenerate_mode_stack: Create multi-mode field arrays\ngenerate_speckle: Random speckle patterns","category":"page"},{"location":"api/modes/#See-Also","page":"Modes","title":"See Also","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"GridUtils for coordinate transformations\nFields for using modes with ScalarField","category":"page"},{"location":"api/modes/#Index","page":"Modes","title":"Index","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Modules = [FluxOptics.Modes]\nOrder = [:type, :function]","category":"page"},{"location":"#FluxOptics.jl","page":"Home","title":"FluxOptics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differentiable optical propagation and inverse design in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"FluxOptics.jl is a Julia package for simulating scalar optical field propagation with full support for automatic differentiation. Design and optimize optical systems through gradient-based methods.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🌊 Scalar field propagation: Angular Spectrum, Rayleigh-Sommerfeld, Collins integral, Beam Propagation Method\n🎭 Optical components: Phase masks, amplitude masks, DOEs, graded-index media\n🎯 Optimization ready: Fully differentiable with Zygote/Enzyme support via ChainRulesCore\n🔧 Proximal operators: TV regularization, sparsity, constraints\n📊 Built-in metrics: Power coupling, field matching, intensity shaping\n🚀 GPU support: CUDA acceleration available","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using FluxOptics\n\n# Create a Gaussian beam\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\ngaussian = Gaussian(20.0)\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nu.electric .= gaussian(xv, yv)\n\n# Propagate through an optical system\nsource = ScalarSource(u)\nphase_mask = Phase(u, (x, y) -> 0.01*(x^2 + y^2))\npropagator = ASProp(u, 1000.0)  # 1 mm propagation\n\nsystem = source |> phase_mask |> propagator\nresult = system()","category":"page"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"","category":"section"},{"location":"#[API-Reference](api/index.md)","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Complete documentation of all modules, types, and functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"GridUtils: Coordinate systems and transformations\nModes: Gaussian beams, HG/LG modes, spatial layouts\nFields: ScalarField type and field operations\nOptical Components: Propagators, masks, sources, systems\nOptimisersExt: Optimization rules and proximal operators\nMetrics: Loss functions for inverse design","category":"page"},{"location":"#Tutorials-*(coming-soon)*","page":"Home","title":"Tutorials (coming soon)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Step-by-step guides for common use cases","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"📖 Browse the API Reference for detailed function documentation\n💬 Open an issue on GitHub for bugs or feature requests\n📧 Contact the maintainers for questions","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use FluxOptics.jl in your research, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{fluxoptics2025,\n  author = {Barré, Nicolas},\n  title = {FluxOptics.jl: Differentiable Optical Simulations},\n  year = {2025},\n  url = {https://github.com/anscoil/FluxOptics.jl}\n}","category":"page"},{"location":"api/modes/modes/#Modes-API","page":"API","title":"Modes API","text":"","category":"section"},{"location":"api/modes/modes/#Gaussian-Beam-Modes","page":"API","title":"Gaussian Beam Modes","text":"","category":"section"},{"location":"api/modes/modes/#Gaussian-Beams","page":"API","title":"Gaussian Beams","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.Gaussian1D","page":"API","title":"FluxOptics.Modes.Gaussian1D","text":"Gaussian1D(w0::Real; norm_constant=nothing)\nGaussian1D(w0::Real, λ::Real, z::Real; constant_phase=true, norm_constant=nothing)\n\nCreate a one-dimensional Gaussian mode.\n\nThe first form creates a Gaussian at the beam waist, while the second includes propagation effects at distance z from the waist.\n\nArguments\n\nw0::Real: Beam waist radius\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\nnorm_constant=nothing: Custom normalization constant - defines the peak intensity (default uses proper Gaussian normalization)\n\nReturns\n\nGaussian1D mode that can be evaluated at spatial positions.\n\nExamples\n\njulia> g = Gaussian1D(10.0);  # 10 μm waist at focus\n\njulia> nx = 40;  # 40 points\n\njulia> dx = 4.0;  # in µm\n\njulia> x, = spatial_vectors(40, dx);\n\njulia> amplitudes = g(x);\n\njulia> isapprox(sum(abs2, amplitudes) * dx, 1)  # Normalization to 1 by default\ntrue\n\njulia> g_prop = Gaussian1D(10.0, 1.064, 1000.0);  # Propagated 1 mm\n\njulia> amplitudes_prop = g_prop(x);\n\njulia> isapprox(sum(abs2, amplitudes_prop) * dx, 1; atol=1e-5)\ntrue\n\nSee also: HermiteGaussian1D, Gaussian, HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.Gaussian","page":"API","title":"FluxOptics.Modes.Gaussian","text":"Gaussian(w0::Real; norm_constant=nothing)\nGaussian(w0x::Real, w0y::Real; norm_constant=nothing)\nGaussian(w0::Real, λ::Real, z::Real; constant_phase=true, norm_constant=nothing)\nGaussian(w0x::Real, w0y::Real, λ::Real, z::Real; constant_phase=true, norm_constant=nothing)\n\nCreate a two-dimensional Gaussian mode.\n\nArguments\n\nw0::Real: Beam waist radius for circular beam\nw0x::Real, w0y::Real: Beam waist radii in x and y directions for elliptical beam\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\nnorm_constant=nothing: Custom normalization constant - defines the peak intensity (default uses proper Gaussian normalization)\n\nReturns\n\nGaussian mode that can be evaluated at spatial coordinates.\n\nExamples\n\njulia> g = Gaussian(10.0);  # Circular beam, 50 μm waist\n\njulia> nx, ny = 64, 64;\n\njulia> dx, dy = 4.0, 4.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> field = zeros(ComplexF64, nx, ny);\n\njulia> g(field, xv, yv);  # Evaluate on grid (in-place)\n\njulia> isapprox(sum(abs2, field) * dx * dy, 1)  # Check normalization\ntrue\n\njulia> g_ellip = Gaussian(10.0, 20.0, 1.064, 1000.0);  # Elliptical beam, wavelength 1.064 µm, propagated 1 mm\n\njulia> field_ellip = g_ellip(xv, yv);  # Direct evaluation (out-of-place)\n\njulia> isapprox(sum(abs2, field_ellip) * dx * dy, 1)\ntrue\n\nSee also: HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"using FluxOptics\n\n# Simple 2D Gaussian at focus\ng = Gaussian(25.0)  # 25 μm waist\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nfield = g(xv, yv)\n\n# Elliptical Gaussian\ng_ellip = Gaussian(20.0, 30.0)  # Different waists in x and y\nfield_ellip = g_ellip(xv, yv)\n\n# Propagated Gaussian\ng_prop = Gaussian(25.0, 1.064, 1000.0)  # At z=1mm from waist\nfield_prop = g_prop(xv, yv)","category":"page"},{"location":"api/modes/modes/#Hermite-Gaussian-Modes","page":"API","title":"Hermite-Gaussian Modes","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.HermiteGaussian1D","page":"API","title":"FluxOptics.Modes.HermiteGaussian1D","text":"HermiteGaussian1D(w0::Real, n::Integer)\nHermiteGaussian1D(w0::Real, n::Integer, λ::Real, z::Real; constant_phase=true)\n\nCreate a one-dimensional Hermite-Gaussian mode HG_n.\n\nArguments\n\nw0::Real: Beam waist radius\nn::Integer: Mode number (≥ 0)\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\n\nReturns\n\nHermiteGaussian1D mode that can be evaluated at spatial positions.\n\nExamples\n\njulia> hg0 = HermiteGaussian1D(20.0, 0);  # HG_0 (Gaussian)\n\njulia> hg1 = HermiteGaussian1D(20.0, 1);  # HG_1 (first excited mode)\n\njulia> nx = 64;\n\njulia> dx = 2.0;\n\njulia> x, = spatial_vectors(nx, dx);\n\njulia> field0 = hg0(x);\n\njulia> field1 = hg1(x);\n\njulia> isapprox(sum(abs2, field0) * dx, 1)  # Check normalization\ntrue\n\njulia> isapprox(sum(field0 .* conj.(field1)) * dx, 0; atol = 1e-15)  # Orthogonality check\ntrue\n\nSee also: Gaussian1D, Gaussian, HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.HermiteGaussian","page":"API","title":"FluxOptics.Modes.HermiteGaussian","text":"HermiteGaussian(w0::Real, m::Integer, n::Integer)\nHermiteGaussian(w0x::Real, w0y::Real, m::Integer, n::Integer)\nHermiteGaussian(w0::Real, m::Integer, n::Integer, λ::Real, z::Real; constant_phase=true)\nHermiteGaussian(w0x::Real, w0y::Real, m::Integer, n::Integer, λ::Real, z::Real; constant_phase=true)\n\nCreate a two-dimensional Hermite-Gaussian mode HG_{m,n}.\n\nArguments\n\nw0::Real: Beam waist radius for circular beam\nw0x::Real, w0y::Real: Beam waist radii in x and y directions\nm::Integer, n::Integer: Mode numbers in x and y directions (≥ 0)\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\n\nReturns\n\nHermiteGaussian mode that can be evaluated at spatial coordinates.\n\nExamples\n\njulia> hg00 = HermiteGaussian(10.0, 0, 0);  # Fundamental mode\n\njulia> hg10 = HermiteGaussian(10.0, 1, 0);  # First excited in x\n\njulia> hg01 = HermiteGaussian(10.0, 0, 1);  # First excited in y\n\njulia> nx, ny = 64, 64;\n\njulia> dx, dy = 2.0, 2.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> field00 = hg00(xv, yv);\n\njulia> field10 = hg10(xv, yv);\n\njulia> isapprox(sum(abs2, field00) * dx * dy, 1)  # Check normalization\ntrue\n\njulia> isapprox(sum(field00 .* conj.(field10)) * dx * dy, 0; atol = 1e-15)  # Orthogonality\ntrue\n\nSee also: Gaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.hermite_gaussian_groups","page":"API","title":"FluxOptics.Modes.hermite_gaussian_groups","text":"hermite_gaussian_groups(w0, n_groups::Int)\n\nGenerate all Hermite-Gaussian modes up to a given group number.\n\nCreates all HGₘₙ modes where m + n < n_groups, ordered by increasing total mode number. This is useful for modal decomposition and beam shaping applications.\n\nArguments\n\nw0: Beam waist radius\nn_groups::Int: Maximum group number\n\nReturns\n\nVector of HermiteGaussian modes.\n\nExamples\n\njulia> modes = hermite_gaussian_groups(10.0, 3);\n\njulia> length(modes)  # Modes: HG_00, HG_10, HG_01, HG_20, HG_11, HG_02\n6\n\njulia> nx, ny = 64, 64;\n\njulia> dx, dy = 2.0, 2.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> fields = [mode(xv, yv) for mode in modes];\n\njulia> all(abs(sum(abs2, field) * dx * dy - 1.0) < 1e-10 for field in fields)  # All normalized\ntrue\n\njulia> modes = hermite_gaussian_groups(10.0, 4);\n\njulia> length(modes)  # Groups 0, 1, 2, 3 give 1+2+3+4 = 10 modes\n10\n\nSee also: Gaussian, HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"function"},{"location":"api/modes/modes/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"# Single HG mode\nhg21 = HermiteGaussian(15.0, 2, 1)  # HG₂₁\nfield_hg = hg21(xv, yv)\n\n# Complete set of modes up to order N\nN = 4\nmodes = hermite_gaussian_groups(12.0, N)\n# Returns HG₀₀, HG₁₀, HG₀₁, HG₂₀, HG₁₁, HG₀₂, ...\n\n# Check orthogonality\nmode_fields = [m(xv, yv) for m in modes]\ndot(mode_fields[1], mode_fields[2]) * 2.0 * 2.0  # ≈ 0","category":"page"},{"location":"api/modes/modes/#Laguerre-Gaussian-Modes","page":"API","title":"Laguerre-Gaussian Modes","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.LaguerreGaussian","page":"API","title":"FluxOptics.Modes.LaguerreGaussian","text":"LaguerreGaussian(w0::Real, p::Integer, l::Integer; kind=:vortex)\nLaguerreGaussian(w0::Real, p::Integer, l::Integer, λ::Real, z::Real; constant_phase=true, kind=:vortex)\n\nCreate a Laguerre-Gaussian mode LGₚₗ.\n\nArguments\n\nw0::Real: Beam waist radius\np::Integer: Radial mode number (≥ 0)\nl::Integer: Azimuthal mode number (any integer)\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\nkind: Mode type - :vortex (default), :even, or :odd\n:vortex: exp(ilφ) phase dependence\n:even: cos(lφ) dependence  \n:odd: sin(lφ) dependence\n\nReturns\n\nLaguerreGaussian mode that can be evaluated at spatial coordinates.\n\nExamples\n\njulia> lg00 = LaguerreGaussian(10.0, 0, 0);  # Fundamental mode (Gaussian)\n\njulia> lg01 = LaguerreGaussian(10.0, 0, 1);  # Vortex beam\n\njulia> nx, ny = 65, 65;\n\njulia> dx, dy = 2.0, 2.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> field00 = lg00(xv, yv);\n\njulia> field01 = lg01(xv, yv);\n\njulia> isapprox(sum(abs2, field00) * dx * dy, 1)  # Check normalization\ntrue\n\njulia> abs(field01[nx÷2+1, ny÷2+1]) < 1e-10  # LG_01 has zero at center (vortex)\ntrue\n\njulia> lg_even = LaguerreGaussian(10.0, 0, 2; kind=:even);\n\njulia> field_even = lg_even(xv, yv);\n\njulia> all(isreal, field_even)  # Even modes are real-valued\ntrue\n\nSee also: Gaussian, HermiteGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#Examples-3","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"# Fundamental mode (equivalent to Gaussian)\nlg00 = LaguerreGaussian(20.0, 0, 0)\nfield_lg00 = lg00(xv, yv)\n\n# Vortex beam (default)\nlg01 = LaguerreGaussian(20.0, 0, 1)  # Donut beam\nfield_vortex = lg01(xv, yv)\n\n# Even/odd superpositions\nlg_even = LaguerreGaussian(20.0, 0, 2; kind=:even)\nlg_odd = LaguerreGaussian(20.0, 0, 2; kind=:odd)\n\n# These are real-valued\n@assert all(isreal, lg_even(xv, yv))\n@assert all(isreal, lg_odd(xv, yv))","category":"page"},{"location":"api/modes/modes/#Spatial-Layouts","page":"API","title":"Spatial Layouts","text":"","category":"section"},{"location":"api/modes/modes/#Layout-Types","page":"API","title":"Layout Types","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.PointLayout","page":"API","title":"FluxOptics.Modes.PointLayout","text":"PointLayout(n, p=(0,0), t=Id2D())\n\nCreate a layout of n identical points.\n\nArguments\n\nn: Number of points\np=(0,0): Position of the point\nt=Id2D(): Coordinate transformation\n\nReturns\n\nPointLayout that can be iterated to get point positions.\n\nExamples\n\njulia> layout = PointLayout(3, (100.0, 50.0));\n\njulia> positions = collect(layout);\n\njulia> length(positions)\n3\n\njulia> all(pos == (100.0, 50.0) for pos in positions)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.GridLayout","page":"API","title":"FluxOptics.Modes.GridLayout","text":"GridLayout(nx, ny, px, py, t=Id2D())\n\nCreate a regular rectangular grid layout.\n\nArguments\n\nnx, ny: Number of points in x and y directions\npx, py: Spacing between points in x and y\nt=Id2D(): Coordinate transformation\n\nReturns\n\nGridLayout that can be iterated to get point positions.\n\nExamples\n\njulia> layout = GridLayout(2, 3, 100.0, 50.0);\n\njulia> positions = collect(layout);\n\njulia> length(positions)  # 2×3 = 6 points\n6\n\njulia> positions[1]  # First point (centered grid)\n(-50.0, -50.0)\n\njulia> positions[end]  # Last point\n(50.0, 50.0)\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.TriangleLayout","page":"API","title":"FluxOptics.Modes.TriangleLayout","text":"TriangleLayout(np, px, py, t=Id2D())\n\nCreate a triangular arrangement of points.\n\nArguments\n\nnp: Number of points along triangle edge\npx, py: Spacing between points in x and y\nt=Id2D(): Coordinate transformation\n\nReturns\n\nTriangleLayout with np(np+1)/2 total points.\n\nExamples\n\njulia> layout = TriangleLayout(3, 100.0, 100.0);\n\njulia> length(layout)  # 3×4/2 = 6 points\n6\n\njulia> layout = TriangleLayout(4, 50.0, 50.0);\n\njulia> length(layout)  # 4×5/2 = 10 points\n10\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.CustomLayout","page":"API","title":"FluxOptics.Modes.CustomLayout","text":"CustomLayout(positions, t=Id2D())\n\nCreate a layout from custom list of positions.\n\nArguments\n\npositions: Vector of (x,y) tuples specifying point positions\nt=Id2D(): Coordinate transformation applied to all positions\n\nReturns\n\nCustomLayout that can be iterated to get transformed positions.\n\nExamples\n\njulia> positions = [(0.0, 0.0), (100.0, 0.0), (50.0, 86.6)];\n\njulia> layout = CustomLayout(positions);\n\njulia> collect(layout) == positions\ntrue\n\njulia> layout_rot = CustomLayout(positions, Rot2D(π/2));\n\njulia> rotated = collect(layout_rot);\n\njulia> all(isapprox.(rotated[2], (0.0, 100.0), atol=1e-12))  # Second point rotated 90°\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#Mode-Stack-Generation","page":"API","title":"Mode Stack Generation","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.generate_mode_stack","page":"API","title":"FluxOptics.Modes.generate_mode_stack","text":"generate_mode_stack(layout, nx, ny, dx, dy, mode; t=Id2D(), normalize=true)\ngenerate_mode_stack(layout, nx, ny, dx, dy, mode_vector; t=Id2D(), normalize=true)\ngenerate_mode_stack(nx, ny, dx, dy, mode_vector; t=Id2D(), normalize=true)\n\nGenerate arrays of optical modes at specified positions.\n\nThe first form replicates the same mode at each layout position. The second form uses different modes from mode_vector at each position. The third form places modes at the origin (single position each).\n\nArguments\n\nlayout: Spatial layout determining mode positions\nnx, ny: Grid size for each mode field\ndx, dy: Pixel size\nmode: Single mode to replicate at all positions\nmode_vector: Vector of modes (one per position)\nt=Id2D(): Additional transformation applied to all modes\nnormalize=true: Normalize each mode to unit power\n\nReturns\n\n3D complex array of size (nx, ny, n_modes) containing mode fields.\n\nExamples\n\njulia> layout = GridLayout(2, 2, 50.0, 50.0);\n\njulia> gaussian = Gaussian(10.0);\n\njulia> modes = generate_mode_stack(layout, 64, 64, 2.0, 2.0, gaussian);\n\njulia> size(modes)\n(64, 64, 4)\n\njulia> sum(abs2, modes[:, :, 1]) * 2.0 * 2.0  # Check first mode normalization\n1.0000000000000007\n\njulia> hg_modes = [HermiteGaussian(25.0, m, n) for m in 0:1 for n in 0:1];\n\njulia> modes_hg = generate_mode_stack(layout, 64, 64, 2.0, 2.0, hg_modes);\n\njulia> size(modes_hg)\n(64, 64, 4)\n\njulia> lg_modes = [LaguerreGaussian(20.0, 0, l) for l in 0:2];\n\njulia> modes_lg = generate_mode_stack(64, 64, 2.0, 2.0, lg_modes);\n\njulia> size(modes_lg)  # No layout specified, modes at origin\n(64, 64, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/modes/modes/#Examples-4","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"# Replicate same mode at each position\ngaussian = Gaussian(10.0)\nlayout = GridLayout(2, 3, 80.0, 80.0)\nmodes = generate_mode_stack(layout, 256, 256, 1.0, 1.0, gaussian)\n# Returns 256×256×6 array\n\n# Different mode at each position\nhg_modes = [HermiteGaussian(12.0, m, n) \n            for m in 0:2 for n in 0:2]\nlayout = GridLayout(3, 3, 60.0, 60.0)\nmodes = generate_mode_stack(layout, 128, 128, 1.5, 1.5, hg_modes)\n# Returns 128×128×9 array\n\n# Single position, multiple modes\nlg_modes = [LaguerreGaussian(15.0, 0, l) for l in 0:5]\nmodes = generate_mode_stack(128, 128, 2.0, 2.0, lg_modes)\n# Returns 128×128×6 array (all centered)\n\n# With coordinate transformations\ntransform = Shift2D(20.0, -10.0) ∘ Rot2D(π/4)\nlayout_transformed = GridLayout(3, 3, 50.0, 50.0, transform)","category":"page"},{"location":"api/modes/modes/#Speckle-Generation","page":"API","title":"Speckle Generation","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.generate_speckle","page":"API","title":"FluxOptics.Modes.generate_speckle","text":"generate_speckle(ns, ds, λ, NA; envelope=nothing, center=(0,0), t=Id2D(), normalize=true)\n\nGenerate random speckle pattern with controlled numerical aperture.\n\nCreates a complex random field with Fourier components limited by the numerical aperture, producing realistic speckle with controlled correlation length.\n\nArguments\n\nns: Grid dimensions - (nx,) for 1D, (nx, ny) for 2D, (nx, ny, nz) for 3D\nds: Pixel sizes - (dx,), (dx, dy), or (dx, dy, dz)\nλ: Wavelength\nNA: Numerical aperture controlling speckle size\nenvelope=nothing: Optional envelope function (Mode type)\ncenter=(0,0): Center position for envelope\nt=Id2D(): Coordinate transformation for envelope\nnormalize=true: Normalize the speckle distribution to unit power\n\nReturns\n\nComplex array with random speckle pattern.\n\nExamples\n\njulia> speckle = generate_speckle((64, 64), (1.0, 1.0), 1.064, 0.1);\n\njulia> isapprox(sum(abs2, speckle), 1)\ntrue\n\njulia> envelope = Gaussian(20.0);\n\njulia> speckle_env = generate_speckle((64, 64), (1.0, 1.0), 1.064, 0.1; envelope=envelope);\n\njulia> isapprox(sum(abs2, speckle_env), 1)\ntrue\n\njulia> speckle_1d = generate_speckle((128,), (0.5,), 1.064, 0.2);\n\njulia> isapprox(sum(abs2, speckle_1d) * 0.5, 1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/modes/modes/#Examples-5","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"# 2D speckle with controlled correlation length\nspeckle = generate_speckle((256, 256), (1.0, 1.0), 1.064, 0.2)\n# Returns 256×256 complex array, normalized to unit power\n\n# 1D speckle\nspeckle_1d = generate_speckle((512,), (0.5,), 1.064, 0.15)\n\n# 3D speckle\nspeckle_3d = generate_speckle((64, 64, 64), (2.0, 2.0, 2.0), 1.064, 0.1)\n\n# With Gaussian envelope\nenvelope = Gaussian(50.0)\nspeckle_gauss = generate_speckle(\n    (256, 256), (1.0, 1.0), 1.064, 0.2;\n    envelope=envelope\n)\n\n# Controlling speckle statistics via NA\nspeckle_fine = generate_speckle((256, 256), (1.0, 1.0), 1.064, 0.8)    # High NA\nspeckle_coarse = generate_speckle((256, 256), (1.0, 1.0), 1.064, 0.05)  # Low NA\n\n# Using with ScalarField\nspeckle_data = generate_speckle((128, 128), (2.0, 2.0), 1.064, 0.15;\n                                envelope=Gaussian(30.0))\nu = ScalarField(speckle_data, (2.0, 2.0), 1.064)","category":"page"},{"location":"api/modes/modes/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/modes/modes/#Mode-Normalization","page":"API","title":"Mode Normalization","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"All modes are normalized to unit power by default\nPower = ∫∫ |u(x,y)|² dx dy = 1\nFor custom normalization, use norm_constant parameter","category":"page"},{"location":"api/modes/modes/#Mode-Propagation","page":"API","title":"Mode Propagation","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"Use λ and z parameters for Gaussian beam propagation\nIncludes Gouy phase shift\nconstant_phase=true includes exp(ikz) term","category":"page"},{"location":"api/modes/modes/#Layout-Centering","page":"API","title":"Layout Centering","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"Layouts are centered at (0, 0) by default\nUse coordinate transformations to shift layouts","category":"page"},{"location":"api/modes/modes/#Speckle-Statistics","page":"API","title":"Speckle Statistics","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"Correlation length ≈ λ / NA\nHigh NA → fine speckle (small correlation length)\nLow NA → coarse speckle (large correlation length)\nSpeckle is fully developed (unit contrast) without envelope","category":"page"},{"location":"api/modes/modes/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"GridUtils for coordinate systems\nFields for ScalarField operations","category":"page"}]
}
