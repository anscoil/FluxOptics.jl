var documenterSearchIndex = {"docs":
[{"location":"api/metrics/#Metrics","page":"Metrics","title":"Metrics","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Loss functions for inverse design optimization.","category":"page"},{"location":"api/metrics/#Overview","page":"Metrics","title":"Overview","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"The Metrics module provides:","category":"page"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Field overlap: DotProduct and PowerCoupling metrics\nField matching: SquaredFieldDifference for complex field matching\nIntensity matching: SquaredIntensityDifference for intensity-based objectives\nAD-compatible: Automatic differentiation support via custom gradients","category":"page"},{"location":"api/metrics/#Examples","page":"Metrics","title":"Examples","text":"","category":"section"},{"location":"api/metrics/#Power-Coupling","page":"Metrics","title":"Power Coupling","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"using FluxOptics\n\n# Create fields\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nu_current = ScalarField(Gaussian(15.0)(xv, yv), (2.0, 2.0), 1.064)\nu_target = ScalarField(Gaussian(20.0)(xv, yv), (2.0, 2.0), 1.064)\n\n# Power coupling metric\nmetric = PowerCoupling(u_target)\n\n# Evaluate coupling (returns power in Watts)\npower_coupled = metric(u_current)\npower_coupled[]","category":"page"},{"location":"api/metrics/#Field-Matching","page":"Metrics","title":"Field Matching","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"using FluxOptics\n\n# Create fields with different phases\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\ngaussian = Gaussian(15.0)(xv, yv)\nu_current = ScalarField(gaussian, (2.0, 2.0), 1.064)\nu_target = ScalarField(gaussian .* cis.(0.01 .* (xv.^2 .+ yv'.^2)), (2.0, 2.0), 1.064)\n\n# Squared field difference\nmetric = SquaredFieldDifference(u_target)\nloss = metric(u_current)\nloss[]","category":"page"},{"location":"api/metrics/#Intensity-Matching","page":"Metrics","title":"Intensity Matching","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"using FluxOptics\n\n# Create field and target intensity pattern\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nu_current = ScalarField(Gaussian(35.0)(xv, yv), (2.0, 2.0), 1.064)\n\n# Target: ring pattern\nr = sqrt.(xv.^2 .+ yv'.^2)\ntarget_intensity = exp.(-(r .- 30).^2 / 100)\ntarget_intensity ./= sum(target_intensity) * 2.0 * 2.0\n\n# Intensity matching metric\nmetric = SquaredIntensityDifference((u_current, target_intensity))\nloss = metric(u_current)\nloss[]","category":"page"},{"location":"api/metrics/#Key-Types","page":"Metrics","title":"Key Types","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"DotProduct: Complex overlap integral ⟨u,v⟩\nPowerCoupling: Power coupled to target mode(s)\nSquaredFieldDifference: |u - v|² field matching\nSquaredIntensityDifference: |Iu - Iv|² intensity matching","category":"page"},{"location":"api/metrics/#Key-Functions","page":"Metrics","title":"Key Functions","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"compute_metric: Evaluate metric on fields\nbackpropagate_metric: Gradient computation (internal)","category":"page"},{"location":"api/metrics/#See-Also","page":"Metrics","title":"See Also","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Typical Workflow - Complete example of building and optimizing an optical system\nOptimisersExt for optimization algorithms\nSystem for building systems to optimize","category":"page"},{"location":"api/metrics/#Index","page":"Metrics","title":"Index","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Modules = [FluxOptics.Metrics]\nOrder = [:type, :function]","category":"page"},{"location":"api/optical_components/core/core/#Core-API","page":"API","title":"Core API","text":"","category":"section"},{"location":"api/optical_components/core/core/#Abstract-Types","page":"API","title":"Abstract Types","text":"","category":"section"},{"location":"api/optical_components/core/core/#Component-Hierarchy","page":"API","title":"Component Hierarchy","text":"","category":"section"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.AbstractOpticalComponent","page":"API","title":"FluxOptics.OpticalComponents.AbstractOpticalComponent","text":"AbstractOpticalComponent{M}\n\nAbstract supertype for all optical components in FluxOptics.\n\nRoot type for the optical component hierarchy, encompassing both sources that generate fields and pipe components that transform fields. The type parameter M indicates the trainability and buffering strategy.\n\nType Parameter\n\nM::Trainability: Component trainability (Static, Trainable{Buffered}, etc.)\n\nSubtypes\n\nAbstractOpticalSource: Components that generate optical fields\nAbstractPipeComponent: Components that transform optical fields\n\nSee also: Trainability, get_data\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.AbstractOpticalSource","page":"API","title":"FluxOptics.OpticalComponents.AbstractOpticalSource","text":"AbstractOpticalSource{M} <: AbstractOpticalComponent{M}\n\nAbstract type for optical components that generate fields.\n\nSources create optical fields from nothing (like a light source), as opposed to AbstractPipeComponent which transform existing fields. Sources are typically placed at the beginning of optical systems.\n\nType Parameter\n\nM::Trainability: Static, Trainable{Unbuffered}, or Trainable{Buffered}\n\nSubtypes\n\nAbstractCustomSource: Sources with custom generation logic\nAbstractPureSource: Sources with simple generation\n\nRequired Interface\n\nAll subtypes must implement:\n\npropagate(source): Generate the optical field\nget_data(source): Access to source parameters\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> source = ScalarSource(u; trainable=true);\n\njulia> field = propagate(source);\n\nSee also: AbstractPipeComponent, ScalarSource, propagate\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.AbstractPureSource","page":"API","title":"FluxOptics.OpticalComponents.AbstractPureSource","text":"AbstractPureSource{M} <: AbstractOpticalSource{M}\n\nAbstract type for stateless optical sources with direct generation.\n\nPure sources generate optical fields through direct computation without  maintaining internal state, suitable for simple or static source configurations.\n\nType Parameter\n\nM::Trainability: Usually Static, but can support simple trainable cases\n\nRequired Methods\n\nAll subtypes must implement:\n\npropagate(source): Generate the optical field directly\nget_data(source): Access to source parameters\n\nSee also: AbstractCustomSource, ScalarSource\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.AbstractCustomSource","page":"API","title":"FluxOptics.OpticalComponents.AbstractCustomSource","text":"AbstractCustomSource{M} <: AbstractOpticalSource{M}\n\nAbstract type for stateful optical sources with custom generation logic.\n\nCustom sources maintain internal state and support gradient computation for  trainable source parameters like beam profiles, power levels, etc.\n\nType Parameter\n\nM::Trainability: Determines gradient and buffer management\n\nRequired Methods\n\nAll subtypes must implement:\n\npropagate(source): Generate the optical field\nget_data(source): Access to trainable parameters\ntrainable(source): Return trainable parameters (if M <: Trainable)\n\nOptional Methods (for optimization)\n\nget_preallocated_gradient(source): Pre-allocated gradients (if buffered)\nbackpropagate_with_gradient(∂v, ∂p, source): Gradient backpropagation\n\nSee also: AbstractPureSource, ScalarSource\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.AbstractPipeComponent","page":"API","title":"FluxOptics.OpticalComponents.AbstractPipeComponent","text":"AbstractPipeComponent{M} <: AbstractOpticalComponent{M}\n\nAbstract type for optical components that process incident fields.\n\nPipe components transform optical fields that pass through them (like a pipe transforms fluid flow), as opposed to AbstractOpticalSource which generate  fields from nothing. The type parameter M indicates trainability.\n\nType Parameter\n\nM::Trainability: Static, Trainable{Unbuffered}, or Trainable{Buffered}\n\nSubtypes\n\nAbstractCustomComponent: Stateful components with custom propagation\nAbstractPureComponent: Stateless components with simple propagation\n\nRequired Interface\n\nAll subtypes must implement:\n\npropagate!(u, component, direction) or propagate(u, component, direction)\nget_data(component): Access to component parameters\n\nSee also: AbstractOpticalSource, propagate!\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.AbstractPureComponent","page":"API","title":"FluxOptics.OpticalComponents.AbstractPureComponent","text":"AbstractPureComponent{M} <: AbstractPipeComponent{M}\n\nAbstract type for optical components with functional interface.\n\nPure components provide a functional interface where the same input always gives the same output, without requiring manual implementation of gradient rules. They can wrap complex internal state (including AbstractCustomComponents) but expose a pure functional interface that works seamlessly with automatic differentiation.\n\nType Parameter\n\nM::Trainability: Usually Static, but can support Trainable for Zygote-based components\n\nRequired Methods\n\nAll subtypes must implement:\n\npropagate(u, component, direction): Direct field transformation\nget_data(component): Access to component parameters\n\nCharacteristics\n\nFunctional interface: Same input → same output, regardless of internal complexity\nZygote compatible: Automatic differentiation works without custom rules\nComposable: Can wrap and combine other components\nImplementation agnostic: Internal state hidden behind pure interface\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> prop_z = ASPropZ(u, 500.0; trainable=true);\n\njulia> typeof(prop_z) <: AbstractPureComponent\ntrue\n\nSee also: AbstractCustomComponent, ASPropZ, OpticalSequence\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.AbstractCustomComponent","page":"API","title":"FluxOptics.OpticalComponents.AbstractCustomComponent","text":"AbstractCustomComponent{M} <: AbstractPipeComponent{M}\n\nAbstract type for stateful optical components with custom propagation logic.\n\nCustom components maintain internal state, support gradient computation for  optimization, and implement complex propagation behavior. They are the building blocks for trainable optical elements like phase masks, diffractive elements, etc.\n\nType Parameter\n\nM::Trainability: Determines gradient and buffer management\n\nRequired Methods\n\nAll subtypes must implement:\n\npropagate!(u, component, direction): In-place field transformation\nget_data(component): Access to trainable parameters  \ntrainable(component): Return trainable parameters (if M <: Trainable)\n\nOptional Methods (for optimization)\n\nbackpropagate!(u, component, direction): Reverse propagation\nget_preallocated_gradient(component): Pre-allocated gradients (if buffered)\nalloc_saved_buffer(u, component): Allocate forward-pass buffers\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> phase_mask = Phase(u, (x, y) -> 0.1*x^2; trainable=true);\n\njulia> typeof(phase_mask) <: AbstractCustomComponent\ntrue\n\njulia> propagate!(u, phase_mask, Forward);\n\nSee also: AbstractPureComponent, Phase, Mask\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#Trainability-System","page":"API","title":"Trainability System","text":"","category":"section"},{"location":"api/optical_components/core/core/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.Trainability","page":"API","title":"FluxOptics.OpticalComponents.Trainability","text":"Trainability\n\nAbstract type for trainability classification of optical components.\n\nDefines whether a component's parameters can be optimized and how gradients are managed during automatic differentiation.\n\nSubtypes\n\nStatic: Non-trainable component\nTrainable{Buffering}: Trainable component with buffer management\n\nSee also: Buffering, Trainability\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.Static","page":"API","title":"FluxOptics.OpticalComponents.Static","text":"Static <: Trainability\n\nTrainability type for non-optimizable optical components.\n\nComponents with Static trainability have fixed parameters that cannot be modified during optimization. These components are more efficient as they don't allocate gradients or maintain optimization state.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> lens = FourierLens(u, (2.0, 2.0), 1000.0);  # Static by default\n\njulia> typeof(lens) <: AbstractPipeComponent{Static}\ntrue\n\nSee also: Trainable, Trainability\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.Trainable","page":"API","title":"FluxOptics.OpticalComponents.Trainable","text":"Trainable{B <: Buffering} <: Trainability\n\nTrainability type for optimizable optical components.\n\nComponents with Trainable trainability have parameters that can be optimized during training. The type parameter B controls gradient and buffer allocation strategy for performance optimization.\n\nType Parameter\n\nB::Buffering: Buffered or Unbuffered\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> phase_mask = Phase(u, (x, y) -> 0.0; trainable=true, buffered=true);\n\njulia> typeof(phase_mask) <: AbstractPipeComponent{<:Trainable}\ntrue\n\nSee also: Static, Buffering, Trainable\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.Buffering","page":"API","title":"FluxOptics.OpticalComponents.Buffering","text":"Buffering\n\nAbstract type for gradient and buffer allocation strategy.\n\nControls how memory is managed for trainable components during optimization, allowing trade-offs between performance and memory usage.\n\nSubtypes\n\nBuffered: Pre-allocated buffers for maximum performance\nUnbuffered: Dynamic allocation for memory efficiency\n\nSee also: Trainable, Trainability\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.Buffered","page":"API","title":"FluxOptics.OpticalComponents.Buffered","text":"Buffered <: Buffering\n\nBuffering strategy with pre-allocated gradient and forward-pass buffers.\n\nComponents using Buffered pre-allocate all necessary buffers during construction, providing maximum performance during optimization at the cost of higher memory usage. Recommended for production training and repeated optimizations.\n\nAdvantages\n\nMaximum performance: No allocation overhead during training\nPredictable memory: All buffers allocated upfront\nGPU friendly: Reduces memory fragmentation\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> mask = Mask(u, (x, y) -> 1.0; trainable=true, buffered=true);\n\njulia> typeof(mask) <: AbstractPipeComponent{Trainable{Buffered}}\ntrue\n\nSee also: Unbuffered, Trainability\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.Unbuffered","page":"API","title":"FluxOptics.OpticalComponents.Unbuffered","text":"Unbuffered <: Buffering\n\nBuffering strategy with dynamic allocation of gradients and buffers.\n\nComponents using Unbuffered allocate gradients and buffers as needed during optimization, providing memory efficiency at the cost of allocation overhead. Recommended for prototyping and memory-constrained environments.\n\nAdvantages\n\nMemory efficient: Only allocates what's needed\nFlexible: Easy to modify component structure\nDebug friendly: Clear allocation patterns\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> phase_mask = Phase(u, (x, y) -> 0.0; trainable=true, buffered=false);\n\njulia> typeof(phase_mask) <: AbstractPipeComponent{Trainable{Unbuffered}}\ntrue\n\nSee also: Buffered, Trainability\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#Query-Functions","page":"API","title":"Query Functions","text":"","category":"section"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.istrainable","page":"API","title":"FluxOptics.OpticalComponents.istrainable","text":"istrainable(component::AbstractOpticalComponent) -> Bool\n\nCheck if a component is trainable (has optimizable parameters).\n\nReturns true for components created with trainable=true, false otherwise.\n\nExamples\n\nphase_static = Phase(u, (x, y) -> x^2)\nistrainable(phase_static)  # false\n\nphase_train = Phase(u, (x, y) -> 0.0; trainable=true)\nistrainable(phase_train)  # true\n\nSee also: isbuffered\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.isbuffered","page":"API","title":"FluxOptics.OpticalComponents.isbuffered","text":"isbuffered(component::AbstractOpticalComponent) -> Bool\n\nCheck if a trainable component uses pre-allocated gradient buffers.\n\nReturns true for components created with trainable=true, buffered=true, false otherwise.\n\nExamples\n\nphase_unbuf = Phase(u, (x, y) -> 0.0; trainable=true, buffered=false)\nisbuffered(phase_unbuf)  # false\n\nphase_buf = Phase(u, (x, y) -> 0.0; trainable=true, buffered=true)\nisbuffered(phase_buf)  # true\n\nSee also: istrainable, Buffered, Unbuffered\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/core/core/#Propagation","page":"API","title":"Propagation","text":"","category":"section"},{"location":"api/optical_components/core/core/#Direction-Types","page":"API","title":"Direction Types","text":"","category":"section"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.Direction","page":"API","title":"FluxOptics.OpticalComponents.Direction","text":"Direction\n\nAbstract type for specifying propagation direction (Forward or Backward)\n\nSee also: Forward, Backward\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.Forward","page":"API","title":"FluxOptics.OpticalComponents.Forward","text":"Forward\n\nDirection marker type for forward optical propagation.\n\nUsed as a type parameter in propagation functions to indicate the direction of light propagation. Forward propagation follows the positive z-axis direction.\n\nSee also: Backward, propagate!\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.Backward","page":"API","title":"FluxOptics.OpticalComponents.Backward","text":"Backward\n\nDirection marker type for backward optical propagation.\n\nUsed as a type parameter in propagation functions to indicate the direction of light propagation along the negative z-axis direction.\n\nSee also: Forward, propagate!\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/core/core/#Propagation-Functions","page":"API","title":"Propagation Functions","text":"","category":"section"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.propagate","page":"API","title":"FluxOptics.OpticalComponents.propagate","text":"propagate(u::ScalarField, component::AbstractPipeComponent, direction::Type{<:Direction})\npropagate(source::AbstractOpticalSource)\n\nPropagate an optical field through a component or generate a field from a source.\n\nThe first form creates a copy of the input field and applies the optical transformation  defined by component in the specified direction. The second form generates a new optical field from a source component.\n\nArguments\n\nu::ScalarField: Input optical field (unchanged)\ncomponent: Optical component to propagate through  \ndirection::Type{<:Direction}: Forward or Backward propagation\nsource::AbstractOpticalSource: Source component to generate field from\n\nReturns\n\nNew ScalarField with the transformation applied or generated.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> phase_mask = Phase(u, (x, y) -> 0.1*(x^2 + y^2));\n\njulia> u_prop = propagate(u, phase_mask, Forward);\n\njulia> source = ScalarSource(u; trainable=true);\n\njulia> u_generated = propagate(source);\n\njulia> size(u_generated) == size(u)\ntrue\n\nSee also: propagate!, Forward, Backward\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.propagate!","page":"API","title":"FluxOptics.OpticalComponents.propagate!","text":"propagate!(u::ScalarField, component::AbstractPipeComponent, direction::Type{<:Direction})\n\nPropagate field through component in-place, modifying the input field.\n\nThis is the core in-place propagation method that modifies the field as it passes through the optical component. The field is transformed according to the component's optical properties in the specified direction.\n\nArguments\n\nu::ScalarField: Field to propagate (modified in-place)\ncomponent: Optical component to propagate through\ndirection: Forward or Backward propagation direction\n\nReturns\n\nModified ScalarField (same object as input).\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\nphase = Phase(u, (x, y) -> 0.1*x^2)\n\n# In-place propagation\npropagate!(u, phase, Forward)  # u is modified\n\n# For sequence of components\npropagate!(u, phase1, Forward)\npropagate!(u, lens, Forward)\npropagate!(u, phase2, Forward)\n\nSee also: propagate, Forward, Backward\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/core/core/#Component-Interface","page":"API","title":"Component Interface","text":"","category":"section"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.get_data","page":"API","title":"FluxOptics.OpticalComponents.get_data","text":"get_data(component::AbstractOpticalComponent)\n\nAccess the internal data array(s) of an optical component.\n\nReturns the underlying parameter array (phase, mask, etc.) or tuple of arrays for components with multiple parameters. Used for inspection and direct manipulation.\n\nReturns\n\nSingle AbstractArray for simple components (Phase, Mask)\nTuple of arrays for components with multiple parameters\nMay be on GPU if component was constructed with GPU arrays\n\nExamples\n\nphase = Phase(u, (x, y) -> x^2; trainable=true)\nφ = get_data(phase)  # Returns phase array\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/core/core/#FluxOptics.OpticalComponents.trainable-Tuple{AbstractOpticalComponent{Static}}","page":"API","title":"FluxOptics.OpticalComponents.trainable","text":"trainable(component::AbstractOpticalComponent)\n\nReturn trainable parameters of a component as a NamedTuple.\n\nFor Static components, returns an empty NamedTuple{}(). For Trainable components, returns a NamedTuple with parameter names as keys and parameter arrays as values.\n\nReturns\n\nNamedTuple{}() for static components\nNamedTuple with parameter arrays for trainable components\n\nExamples\n\n# Static component\nphase_static = Phase(u, (x, y) -> x^2)\ntrainable(phase_static)  # NamedTuple{}()\n\n# Trainable component\nphase_train = Phase(u, (x, y) -> 0.0; trainable=true)\nparams = trainable(phase_train)  # (; ϕ = ...)\n\n# Use with optimization\nusing Functors\nall_params = Functors.fmap(trainable, system)\n\nSee also: istrainable\n\n\n\n\n\n","category":"method"},{"location":"api/optical_components/core/core/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/core/core/","page":"API","title":"API","text":"Sources for field generation components\nModulators for phase and amplitude modulation\nFree-Space Propagators for propagation methods\nSystem for building optical sequences and complex optical systems\nOptimisersExt for optimization tools","category":"page"},{"location":"api/optical_components/modulators/modulators/#Modulators-API","page":"API","title":"Modulators API","text":"","category":"section"},{"location":"api/optical_components/modulators/modulators/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/optical_components/modulators/modulators/#FluxOptics.OpticalComponents.Phase","page":"API","title":"FluxOptics.OpticalComponents.Phase","text":"Phase(u::ScalarField, f; trainable=false, buffered=false)\nPhase(u::ScalarField, ds::NTuple, f; trainable=false, buffered=false)\n\nCreate a phase mask component.\n\nApplies a spatially-varying phase shift to an optical field: u → u × exp(iφ(x,y)). The phase can be specified as a function or an array, and can be made trainable for inverse design optimization.\n\nArguments\n\nu::ScalarField: Field template (defines grid size and type)\nds::NTuple: Spatial sampling (defaults to u.ds)\nf: Phase function (x, y) -> φ or phase array\ntrainable::Bool: Enable gradient-based optimization (default: false)\nbuffered::Bool: Pre-allocate gradient buffers for performance (default: false)\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (2.0, 2.0), 1.064)\n\n# Parabolic phase (lens-like)\nphase_lens = Phase(u, (x, y) -> π/(1000^2) * (x^2 + y^2))\n\n# Trainable phase mask (starts at zero)\nphase_opt = Phase(u, (x, y) -> 0.0; trainable=true, buffered=true)\n\n# From measured/computed array\nphase_data = load_measurement(...)\nphase_measured = Phase(u, phase_data)\n\n# Use in system\nsystem = ScalarSource(u) |> phase_opt |> ASProp(u, 1000.0)\n\nSee also: Mask, TeaDOE, FourierPhase\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/modulators/modulators/#FluxOptics.OpticalComponents.Mask","page":"API","title":"FluxOptics.OpticalComponents.Mask","text":"Mask(u::ScalarField, f; trainable=false, buffered=false)\nMask(u::ScalarField, ds::NTuple, f; trainable=false, buffered=false)\n\nCreate an amplitude or complex mask component.\n\nApplies a spatially-varying complex transmission: u → u × m(x,y). The mask can represent amplitude attenuation, complex transmission, apertures, or fabrication errors.\n\nArguments\n\nu::ScalarField: Field template (defines grid size and type)\nds::NTuple: Spatial sampling (defaults to u.ds)\nf: Mask function (x, y) -> m (complex) or mask array\ntrainable::Bool: Enable gradient-based optimization (default: false)\nbuffered::Bool: Pre-allocate gradient buffers (default: false)\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\n\n# Circular aperture\nradius = 50.0\naperture = Mask(u, (x, y) -> sqrt(x^2 + y^2) < radius ? 1.0 : 0.0)\n\n# Gaussian apodization\napodization = Mask(u, (x, y) -> exp(-(x^2 + y^2)/(2*40^2)))\n\n# Trainable complex mask\nmask_opt = Mask(u, (x, y) -> 1.0 + 0.0im; trainable=true)\n\n# From measurement (fabrication errors)\nmeasured_transmission = load_measurement(...)\nmask_real = Mask(u, measured_transmission)\n\nSee also: Phase, TeaDOE, FourierMask\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/modulators/modulators/#FluxOptics.OpticalComponents.TeaDOE","page":"API","title":"FluxOptics.OpticalComponents.TeaDOE","text":"TeaDOE(u::ScalarField, Δn, f; trainable=false, buffered=false)\n\nCreate a diffractive optical element using thin element approximation.\n\nModels a phase element with refractive index difference Δn and surface height h(x,y). The transmission is: t = exp(i 2π Δn h(x,y) / λ), wavelength-dependent.\n\nArguments\n\nu::ScalarField: Field template\nΔn: Refractive index difference (nelement - nsurround)\nf: Height function (x, y) -> h or height array\ntrainable::Bool: Optimize surface profile (default: false)\nbuffered::Bool: Pre-allocate gradients (default: false)\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (1.0, 1.0), 1.064)\n\n# Sinusoidal grating\nΔn = 0.5\ngrating = TeaDOE(u, Δn, (x, y) -> 0.5 * sin(2π * x / 50))\n\n# Trainable DOE for beam shaping\ndoe_opt = TeaDOE(u, 0.5, (x, y) -> 0.0; trainable=true)\n\n# Multi-level DOE\nlevels = compute_multilevel_profile(...)\ndoe_ml = TeaDOE(u, 0.5, levels)\n\nSee also: TeaReflector, Phase\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/modulators/modulators/#FluxOptics.OpticalComponents.TeaReflector","page":"API","title":"FluxOptics.OpticalComponents.TeaReflector","text":"TeaReflector(u::ScalarField, f; r=(λ)->1.0, trainable=false, buffered=false)\n\nCreate a reflective diffractive element with variable surface height.\n\nModels a mirror with surface profile h(x,y) and optional wavelength-dependent reflectivity r(λ). Phase shift: φ = 4π h(x,y) / λ (factor 2 from reflection).\n\nArguments\n\nu::ScalarField: Field template\nf: Height function (x, y) -> h or height array\nr: Reflectivity function (λ) -> r (complex, default: 1.0)\ntrainable::Bool: Optimize surface (default: false)\nbuffered::Bool: Pre-allocate gradients (default: false)\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (1.0, 1.0), 1.064)\n\n# Simple mirror with surface\nmirror = TeaReflector(u, (x, y) -> 0.01 * (x^2 + y^2))\n\n# Mirror with wavelength-dependent coating\nr_coating = λ -> 0.95 * exp(im * π/4)  # 95% reflective + phase\nmirror_coated = TeaReflector(u, (x, y) -> 0.0; r=r_coating)\n\n# Deformable mirror (trainable)\ndm = TeaReflector(u, (x, y) -> 0.0; trainable=true)\n\nSee also: TeaDOE, Phase\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/modulators/modulators/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/modulators/modulators/","page":"API","title":"API","text":"ScalarField for field representation\npropagate for field propagation\nFourierPhase for frequency-domain phase modulation\nFourierMask for frequency-domain amplitude modulation\nCore for trainability system","category":"page"},{"location":"api/optical_components/system/#System","page":"System","title":"System","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"Optical system composition and execution.","category":"page"},{"location":"api/optical_components/system/#Overview","page":"System","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"The System module provides:","category":"page"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"Optical systems combining sources and components\nComponent sequences for reusable propagation chains\nPipe operator syntax for intuitive system building\nComponent merging for performance optimization\nField probes for intermediate field capture","category":"page"},{"location":"api/optical_components/system/#Examples","page":"System","title":"Examples","text":"","category":"section"},{"location":"api/optical_components/system/#Basic-System-Construction","page":"System","title":"Basic System Construction","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"using FluxOptics\n\n# Create field and components\nxv, yv = spatial_vectors(256, 256, 2.0, 2.0)\nu = ScalarField(Gaussian(20.0)(xv, yv), (2.0, 2.0), 1.064)\n\nsource = ScalarSource(u)\nphasemask = Phase(u, (x, y) -> 0.01*(x^2 + y^2))\nprop = ASProp(u, 500.0)\n\n# Build system with pipe operator\nsystem = source |> phasemask |> prop\n\n# Execute system\nresult = system()\npower(result.out)[]","category":"page"},{"location":"api/optical_components/system/#Component-Merging","page":"System","title":"Component Merging","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"using FluxOptics\n\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nu = ScalarField(Gaussian(15.0)(xv, yv), (2.0, 2.0), 1.064)\n\nsource = ScalarSource(u)\n\n# Create multiple phase masks\nphase1 = Phase(u, (x, y) -> 0.01*x^2)\nphase2 = Phase(u, (x, y) -> 0.01*y^2)\nphase3 = Phase(u, (x, y) -> 0.01*x*y)\n\n# Without merging: 3 separate phase operations\nsystem_no_merge = source |> phase1 |> phase2 |> phase3\ncomponents_no_merge = get_components(system_no_merge)\n\n# With merging: phases combined into single operation\nsystem_merged = source |> phase1 |> phase2 |> phase3 |> (; merge_components=true)\ncomponents_merged = get_components(system_merged)\n\n# Compare number of operations\n(length(components_no_merge), length(components_merged))","category":"page"},{"location":"api/optical_components/system/#Field-Probes","page":"System","title":"Field Probes","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"using FluxOptics, CairoMakie\n\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\nu = ScalarField(Gaussian(30.0)(xv, yv), (1.0, 1.0), 1.064)\n\nsource = ScalarSource(u)\nphasemask = Phase(u, (x, y) -> 0.01*(x^2 + y^2))\nlens = FourierLens(u, (2.0, 2.0), 1000.0)\nprop = ASProp(u, (2.0, 2.0), 4000.0)\n\n# Insert probes to capture intermediate fields\nprobe1 = FieldProbe()\nprobe2 = FieldProbe()\n\nsystem = source |> phasemask |> probe1 |> lens |> probe2 |> prop\n\n# Execute and access intermediate fields\nresult = system()\n\n# Access fields at probe locations\nfield_after_phase = result.probes[probe1]\nfield_after_lens = result.probes[probe2]\nfinal_field = result.out\n\n# Show intensity at each stage\nvisualize((field_after_phase, field_after_lens, final_field), (intensity, phase);\n    colormap=(:inferno, :viridis), height=120)","category":"page"},{"location":"api/optical_components/system/#Key-Types","page":"System","title":"Key Types","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"OpticalSystem: Complete optical system with source\nAbstractSequence: Abstract type for defining optical sequences\nOpticalSequence: Component sequence without source\nFieldProbe: Intermediate field capture","category":"page"},{"location":"api/optical_components/system/#Key-Functions","page":"System","title":"Key Functions","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"get_source: Extract source from system\nget_components: Extract component sequence\nget_sequence: Extract components from sequence","category":"page"},{"location":"api/optical_components/system/#Design-Patterns","page":"System","title":"Design Patterns","text":"","category":"section"},{"location":"api/optical_components/system/#System-Construction","page":"System","title":"System Construction","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"Use pipe operator for readable system building:","category":"page"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"system = source |> component1 |> component2 |> component3","category":"page"},{"location":"api/optical_components/system/#Component-Merging-2","page":"System","title":"Component Merging","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"Enable merging for performance:","category":"page"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"system = source |> phase1 |> phase2 |> (; merge_components=true)\n# Adjacent compatible components are merged","category":"page"},{"location":"api/optical_components/system/#Field-Probes-2","page":"System","title":"Field Probes","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"Insert probes to capture intermediate fields:","category":"page"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"probe = FieldProbe()\nsystem = source |> phase |> probe |> lens\nresult = system()\nintermediate = result.probes[probe]","category":"page"},{"location":"api/optical_components/system/#See-Also","page":"System","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"Core for component interface\nSources for field generation\nModulators for components","category":"page"},{"location":"api/optical_components/system/#Index","page":"System","title":"Index","text":"","category":"section"},{"location":"api/optical_components/system/","page":"System","title":"System","text":"Modules = [FluxOptics.OpticalComponents]\nPages = [\"system.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/optical_components/system/system/#System-API","page":"API","title":"System API","text":"","category":"section"},{"location":"api/optical_components/system/system/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/optical_components/system/system/#FluxOptics.OpticalComponents.OpticalSystem","page":"API","title":"FluxOptics.OpticalComponents.OpticalSystem","text":"OpticalSystem(source, components...; merge_components=false, inplace=false)\nsource |> component1 |> component2 |> ... |> (; merge_components=true)\n\nCreate a complete optical system with source and components.\n\nRepresents a full optical system from source to output, combining a source component with a sequence of transformations. Systems are callable and can be optimized end-to-end.\n\nArguments\n\nsource: Source component (generates initial field)\ncomponents...: Sequence of optical components\nmerge_components::Bool: Merge adjacent compatible components for efficiency (default: false)\ninplace::Bool: Modify fields in-place during propagation (default: false)\n\nComponent Merging\n\nWhen merge_components=true, adjacent components of the same type are automatically merged where possible (e.g., two static Phase masks → single Phase, two Fourier propagators → combined). This can significantly improve performance by reducing the number of operations.\n\nNote: After merging, get_components(system) returns the merged components, which may differ from the original input components.\n\nExamples\n\n# Basic system\nsource = ScalarSource(u0; trainable=true)\nphase = Phase(u, (x, y) -> 0.0; trainable=true)\nlens = FourierLens(u, (2.0, 2.0), 1000.0)\nprop = ASProp(u, 500.0)\n\nsystem = source |> phase |> lens |> prop\n\n# With component merging (more efficient)\nphase1 = Phase(u, (x, y) -> x^2)\nphase2 = Phase(u, (x, y) -> y^2)\nsystem_merged = source |> phase1 |> phase2 |> (; merge_components=true)\n# phase1 and phase2 combined into single Phase\n\ncomponents = get_components(system_merged)  # Returns merged version\n\n# Execute system\nresult = system()\noutput = result.out\n\n# With probes\nprobe = FieldProbe()\nsystem = source |> phase |> probe |> lens |> prop\nresult = system()\nfield_after_phase = result.probes[probe]\n\n# In-place mode (memory efficient)\nsystem_inplace = system |> (; inplace=true)\n\nSee also: OpticalSequence, get_source, get_components\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/system/system/#FluxOptics.OpticalComponents.AbstractSequence","page":"API","title":"FluxOptics.OpticalComponents.AbstractSequence","text":"AbstractSequence{M} <: AbstractPipeComponent{M}\n\nAbstract type for sequences of optical components.\n\nSequences combine multiple components into a single composite component that can be used like any other pipe component. The type parameter M reflects the combined trainability of all components in the sequence.\n\nSubtypes\n\nOpticalSequence: Concrete sequence implementation\n\nRequired Interface\n\nAll subtypes must implement:\n\nget_sequence(seq::AbstractSequence)\n\nSee also: OpticalSequence, get_sequence\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/system/system/#FluxOptics.OpticalComponents.OpticalSequence","page":"API","title":"FluxOptics.OpticalComponents.OpticalSequence","text":"OpticalSequence(components...)\n\nCreate a sequence of optical components without a source.\n\nStores multiple pipe components as a single composite component. Unlike OpticalSystem, this does not include a source and cannot use the pipe operator syntax.\n\nNote: The pipe operator (|>) only works for OpticalSystem, not OpticalSequence. To create sequences, pass components directly to the constructor.\n\nArguments\n\ncomponents...: Sequence of AbstractPipeComponent instances\n\nExamples\n\n# Create sequence explicitly\nu = ScalarField(ones(ComplexF64, 256, 256), (2.0, 2.0), 1.064)\n\nphase = Phase(u, (x, y) -> x^2)\nlens = FourierLens(u, (2.0, 2.0), 1000.0)\nprop = ASProp(u, 500.0)\n\nsequence = OpticalSequence(phase, lens, prop)\n\n# Apply to field\nresult = propagate(u, sequence, Forward)\n\n# Extract components\ncomponents = get_sequence(sequence)\n\nSee also: OpticalSystem, AbstractSequence, get_sequence\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/system/system/#FluxOptics.OpticalComponents.FieldProbe","page":"API","title":"FluxOptics.OpticalComponents.FieldProbe","text":"FieldProbe()\n\nCreate a probe to capture intermediate fields in an optical system.\n\nProbes capture the field at specific points during propagation without affecting the field itself. Useful for debugging, visualization, or monitoring optimization.\n\nExamples\n\n# Create probes\nprobe1 = FieldProbe()\nprobe2 = FieldProbe()\n\n# Insert in system\nsystem = source |> component1 |> probe1 |> \n         component2 |> probe2 |> \n         component3\n\n# Execute and access captured fields\nresult = system()\nfield1 = result.probes[probe1]\nfield2 = result.probes[probe2]\nfinal = result.out\n\nSee also: OpticalSystem\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/system/system/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/optical_components/system/system/#FluxOptics.OpticalComponents.get_source-Tuple{OpticalSystem}","page":"API","title":"FluxOptics.OpticalComponents.get_source","text":"get_source(system::OpticalSystem)\n\nExtract the source component from an optical system.\n\nReturns the source component (e.g., ScalarSource) used to generate the initial field in the system.\n\nExamples\n\nsystem = source |> phase |> lens |> propagator\n\nsrc = get_source(system)\n\nSee also: OpticalSystem, get_components\n\n\n\n\n\n","category":"method"},{"location":"api/optical_components/system/system/#FluxOptics.OpticalComponents.get_components","page":"API","title":"FluxOptics.OpticalComponents.get_components","text":"get_components(system::OpticalSystem)\n\nExtract the component sequence from an optical system.\n\nReturns the tuple of components (excluding the source) that make up the system. If the system was created with merge_components=true, returns the merged components, which may differ from the original input.\n\nExamples\n\nsystem = source |> phase |> lens |> propagator\n\ncomponents = get_components(system)  # (phase, lens, propagator)\n\n# With merging\nphase1 = Phase(u, (x, y) -> x^2)\nphase2 = Phase(u, (x, y) -> y^2)\nsystem_merged = source |> phase1 |> phase2 |> (; merge_components=true)\n\ncomponents_merged = get_components(system_merged)  # Single merged Phase\n\nSee also: get_source, OpticalSystem\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/system/system/#FluxOptics.OpticalComponents.get_sequence","page":"API","title":"FluxOptics.OpticalComponents.get_sequence","text":"get_sequence(seq::AbstractSequence)\n\nExtract the tuple of components from a sequence.\n\nReturns the ordered tuple of components that make up the sequence.\n\nExamples\n\nseq = OpticalSequence(phase1, lens, phase2)\ncomponents = get_sequence(seq)  # (phase1, lens, phase2)\n\nSee also: AbstractSequence, OpticalSequence\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/system/system/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/optical_components/system/system/#Component-Merging-Rules","page":"API","title":"Component Merging Rules","text":"","category":"section"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"When merge_components=true, compatible adjacent components are merged:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"Phase + Phase:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"phase1 = Phase(u, (x, y) -> x^2)\nphase2 = Phase(u, (x, y) -> y^2)\n# Merged: φ_total = φ₁ + φ₂","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"Mask × Mask:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"mask1 = Mask(u, (x, y) -> 0.8)\nmask2 = Mask(u, (x, y) -> 0.9)\n# Merged: m_total = m₁ × m₂","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"Mask × Phase → Mask:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"mask = Mask(u, (x, y) -> 0.8)\nphase = Phase(u, (x, y) -> π/4)\n# Merged: m_total = m × exp(iφ)","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"FourierOperator + FourierOperator:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"fft = FourierOperator(u, true)\nifft = FourierOperator(u, false)\n# Merged: cancels to identity (removed)","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"Requirements for merging:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"Components must be Static (non-trainable)\nArrays must have compatible sizes\nComponents must be adjacent in sequence","category":"page"},{"location":"api/optical_components/system/system/#Pipe-Operator-Behavior","page":"API","title":"Pipe Operator Behavior","text":"","category":"section"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"The pipe operator |> creates OpticalSystem instances:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"# Source + Component → OpticalSystem\nsystem = source |> phase\n\n# Component + Component → OpticalSystem (no source)\nsequence_system = phase |> lens\n\n# System + Component → OpticalSystem\nsystem = system |> propagator\n\n# System + NamedTuple → OpticalSystem (update options)\nsystem = system |> (; merge_components=true)","category":"page"},{"location":"api/optical_components/system/system/#Execution-and-Output","page":"API","title":"Execution and Output","text":"","category":"section"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"System execution returns a NamedTuple:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"result = system()\n# result.out: final field\n# result.probes: IdDict{FieldProbe, ScalarField}","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"For systems without probes:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"result = system()\noutput = result.out  # Access final field","category":"page"},{"location":"api/optical_components/system/system/#In-Place-Mode","page":"API","title":"In-Place Mode","text":"","category":"section"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"When inplace=true:","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"Fields are modified during propagation\nReduces memory allocations\nCompatible with probes (probes always copy)","category":"page"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"system_inplace = source |> phase |> lens |> (; inplace=true)\nresult = system_inplace()","category":"page"},{"location":"api/optical_components/system/system/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/system/system/","page":"API","title":"API","text":"Core for component interface\nSources for source components\nModulators for modulation components","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/#Multi-Wavelength-Beam-Shaping:-RGB-Smiley-Generation","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping: RGB Smiley Generation","text":"","category":"section"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"This tutorial demonstrates chromatic beam shaping using a cascade of diffractive optical elements (DOEs). We optimize four DOEs to transform three Gaussian beams (red, green, blue) into a color smiley face pattern: red head, green eyes, blue mouth.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/#Chromatic-DOE-Design","page":"Multi-Wavelength Beam Shaping","title":"Chromatic DOE Design","text":"","category":"section"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"Each DOE introduces wavelength-dependent phase shifts through height modulation. By cascading multiple DOEs with propagation between them, we can independently control the spatial distribution of each wavelength, enabling complex multi-color beam shaping.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"using FluxOptics, Zygote, CairoMakie","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/#Target-Images","page":"Multi-Wavelength Beam Shaping","title":"Target Images","text":"","category":"section"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"We load three grayscale target patterns that define the desired intensity distribution for each color channel. The images are padded to avoid edge effects during propagation and normalized to unit power.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"using Images\n\ndata = \"docs/literate/data\"\n\nfunction pad_0(u, n)\n    nx, ny = size(u)\n    A = zeros(eltype(u), (nx + 2*n, ny + 2*n))\n    A[(n + 1):(n + nx), (n + 1):(n + ny)] .= u\n    A\nend\n\nn_pad = 100;","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"Load and normalize target patterns","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"I_head = pad_0(Float32.(load(\"$(data)/smiley_600x600_head.png\")[end:-1:1, 1:end]'), n_pad)\nI_head .-= minimum(I_head)\nI_head ./= sum(I_head)\n\nI_mouth = pad_0(Float32.(load(\"$(data)/smiley_600x600_mouth.png\")[end:-1:1, 1:end]'), n_pad)\nI_mouth .-= minimum(I_mouth)\nI_mouth ./= sum(I_mouth)\n\nI_eyes = pad_0(Float32.(load(\"$(data)/smiley_600x600_eyes.png\")[end:-1:1, 1:end]'), n_pad)\nI_eyes .-= minimum(I_eyes)\nI_eyes ./= sum(I_eyes);","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"Composite target (grayscale visualization)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"visualize(4*I_head .+ I_eyes .+ I_mouth, identity; colormap=:grayC, height=120)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"(Image: Target patterns: head (brightest), eyes, and mouth)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/#Multi-Wavelength-Source","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Source","text":"","category":"section"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"We create a multi-wavelength field with three Gaussian beams at blue (455nm), green (538nm), and red (640nm). The wavelength-dependent refractive index of the DOE material (n ≈ 1.51) enables chromatic control.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"ns = size(I_head)\nds = (0.5, 0.5)\nx_vec, y_vec = spatial_vectors(ns, ds)\n\nλ_455 = 0.455  # Blue\nλ_538 = 0.538  # Green\nλ_640 = 0.640;  # Red","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"Refractive index dispersion (typical optical glass)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"function dn(λ::T) where {T}\n    return if λ == T(0.455)\n        T(1.518 - 1)\n    elseif λ == T(0.538)\n        T(1.512 - 1)\n    elseif λ == T(0.640)\n        T(1.508 - 1)\n    else\n        T(NaN)\n    end\nend\n\nlambdas = [λ_640, λ_538, λ_455]\n\nw0_640 = 40.0\nw0_538 = 40.0\nw0_455 = 40.0;","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"Create multi-wavelength field","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"u0 = ScalarField((ns..., 3), ds, lambdas)\nu0[:, :, 1] .= 2*Gaussian(w0_640)(x_vec, y_vec)  # Red (2× power)\nu0[:, :, 2] .= Gaussian(w0_538)(x_vec, y_vec)    # Green\nu0[:, :, 3] .= Gaussian(w0_455)(x_vec, y_vec);    # Blue","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"Combined target intensity (RGB channels)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"If = cat(4*I_head, I_eyes, I_mouth, dims = 3)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"Visualize initial beams and targets","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"visualize((vec(u0), vec(sqrt.(If), 2)), intensity;\n           colormap=((:Reds, :Greens, :Blues),), height=120)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"(Image: Initial Gaussian beams (top) and target patterns (bottom) for each wavelength)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/#Optical-System:-DOE-Cascade","page":"Multi-Wavelength Beam Shaping","title":"Optical System: DOE Cascade","text":"","category":"section"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"The system consists of four trainable DOEs separated by 3mm free-space propagation. Each DOE applies wavelength-dependent phase shifts through height modulation. The optimization will find the height profiles that transform the input Gaussians into the target smiley pattern.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"z = 3000.0  # 3mm propagation between DOEs\n\np = RSProp(u0, z; use_cache = true)\ndoe() = TeaDOE(u0, dn; trainable = true, buffered = true)\n\ns = ScalarSource(u0)\nsystem = s |> p |> doe() |> p |> doe() |> p |> doe() |> p |> doe() |> p |>\n         (; inplace = true);","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/#Loss-Function-and-Optimization","page":"Multi-Wavelength Beam Shaping","title":"Loss Function and Optimization","text":"","category":"section"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"We minimize the squared intensity difference between the output and target patterns across all three wavelengths. The DOE heights are constrained to [-0.5, 0.5] μm to maintain reasonable fabrication requirements.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"intensity_diff = SquaredIntensityDifference((u0, If))\nf_opt = m -> sum(intensity_diff(m().out));","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"Initialize DOEs to zero height","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"masks = filter(x -> isa(x, TeaDOE), get_components(system))\nfor mask in masks\n    fill!(mask, 0)\nend","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"FISTA with height clamping","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"rule = Fista(200)\nprox = ClampProx(-0.5, 0.5)\nopt = FluxOptics.setup(ProxRule(rule, prox), system)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/#Optimization-Loop","page":"Multi-Wavelength Beam Shaping","title":"Optimization Loop","text":"","category":"section"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"We run 200 iterations of FISTA. The optimization simultaneously shapes all three wavelengths, finding DOE height profiles that satisfy the chromatic constraints.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"losses = Float64[]\n\nfor i in 1:200\n    val, grads = Zygote.withgradient(f_opt, system)\n    FluxOptics.update!(opt, system, grads[1])\n    push!(losses, val)\nend","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"Convergence curve shows steady decrease in loss as the DOEs learn to shape the multi-wavelength beam into the target smiley pattern.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"(Image: Optimization convergence - loss decreases as DOEs learn chromatic beam shaping)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/#Optimized-DOE-Height-Profiles","page":"Multi-Wavelength Beam Shaping","title":"Optimized DOE Height Profiles","text":"","category":"section"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"The four optimized DOEs show complex height profiles that enable independent control of each wavelength. The height structures differ between DOEs as each contributes to the cumulative transformation through the cascade.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"visualize((masks[1:2], masks[3:4]), identity; show_colorbars=true, height=120)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"(Image: Optimized height profiles of the four DOEs in the cascade)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/#Result:-RGB-Smiley","page":"Multi-Wavelength Beam Shaping","title":"Result: RGB Smiley","text":"","category":"section"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"The final output shows successful chromatic beam shaping. Each wavelength forms its target pattern: red forms the head, green forms the eyes, and blue forms the mouth. The color separation demonstrates precise wavelength- dependent control achieved through the optimized DOE cascade.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"uf = system().out\n\nvisualize((vec(u0), vec(sqrt.(If), 2), vec(uf)), intensity;\n           colormap=((:Reds, :Greens, :Blues),), height=120)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"(Image: Initial beams, target patterns, and optimized result showing RGB smiley formation)","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"The optimization successfully generates a multi-color smiley face through wavelength-dependent diffractive beam shaping. This demonstrates the capability of cascaded DOEs for complex chromatic control, with applications in color holography, multi-wavelength optical systems, and achromatic/polychromatic designs.","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"","category":"page"},{"location":"tutorials/03_RGB_beam_shaping/","page":"Multi-Wavelength Beam Shaping","title":"Multi-Wavelength Beam Shaping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/optical_components/fourier/fourier/#Fourier-API","page":"API","title":"Fourier API","text":"","category":"section"},{"location":"api/optical_components/fourier/fourier/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/optical_components/fourier/fourier/#FluxOptics.OpticalComponents.FourierOperator","page":"API","title":"FluxOptics.OpticalComponents.FourierOperator","text":"FourierOperator(u::ScalarField, direct::Bool)\n\nCreate a Fourier transform operator (FFT or IFFT).\n\nLow-level component for manual Fourier domain operations. Applies either forward FFT (direct=true) or inverse IFFT (direct=false) to the field. Most users should use FourierWrapper, FourierPhase, or FourierMask instead.\n\nArguments\n\nu::ScalarField: Field template (defines grid size and dimensions)\ndirect::Bool: true for FFT, false for IFFT\n\nDirection Behavior\n\nForward direction: Applies FFT if direct=true, IFFT if direct=false\nBackward direction: Reversed (IFFT if direct=true, FFT if direct=false)\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (1.0, 1.0), 1.064)\n\n# Forward FFT\nfft_op = FourierOperator(u, true)\nu_freq = propagate(u, fft_op, Forward)\n\n# Inverse FFT\nifft_op = FourierOperator(u, false)\nu_back = propagate(u_freq, ifft_op, Forward)\n\nNote: FourierOperator is used internally by FourierWrapper to create FFT → component → IFFT sequences. For most use cases, prefer the higher-level wrappers.\n\nSee also: FourierWrapper, FourierPhase, FourierMask\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/fourier/fourier/#FluxOptics.OpticalComponents.FourierWrapper","page":"API","title":"FluxOptics.OpticalComponents.FourierWrapper","text":"FourierWrapper(u::ScalarField, component::AbstractPipeComponent)\n\nWrap a component to operate in Fourier domain.\n\nApplies FFT before the component and IFFT after, allowing spatial-domain components to operate on frequency content. Equivalent to: u → IFFT[component(FFT[u])]\n\nArguments\n\nu::ScalarField: Field template\ncomponent: Component to wrap (operates on Fourier transform)\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (1.0, 1.0), 1.064)\n\n# Apply phase mask in Fourier domain\nphase_real = Phase(u, (x, y) -> 0.01*x^2)\nphase_fourier = FourierWrapper(u, phase_real)\n\n# Equivalent to frequency-domain filtering\nv = propagate(u, phase_fourier, Forward)\n\nSee also: FourierPhase, FourierMask\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/fourier/fourier/#FluxOptics.OpticalComponents.FourierPhase","page":"API","title":"FluxOptics.OpticalComponents.FourierPhase","text":"FourierPhase(u::ScalarField, f; trainable=false, buffered=false)\n\nApply phase mask in Fourier domain.\n\nConvenient constructor for FourierWrapper(u, Phase(...)). The function f receives spatial frequencies (fx, fy) as arguments.\n\nArguments\n\nu::ScalarField: Field template\nf: Phase function (fx, fy) -> φ in Fourier space\ntrainable::Bool: Enable optimization (default: false)\nbuffered::Bool: Pre-allocate gradients (default: false)\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (1.0, 1.0), 1.064)\n\n# Parabolic phase in frequency domain\nfourier_phase = FourierPhase(u, (fx, fy) -> 0.01*(fx^2 + fy^2))\n\n# Low-pass filter (soft)\nsigma_f = 0.1  # 1/μm\nlowpass = FourierPhase(u, (fx, fy) -> -π*(fx^2 + fy^2)/(2*sigma_f^2))\n\nSee also: FourierMask, FourierWrapper, Phase\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/fourier/fourier/#FluxOptics.OpticalComponents.FourierMask","page":"API","title":"FluxOptics.OpticalComponents.FourierMask","text":"FourierMask(u::ScalarField, f; trainable=false, buffered=false)\n\nApply amplitude/complex mask in Fourier domain.\n\nConvenient constructor for FourierWrapper(u, Mask(...)). The function f receives spatial frequencies (fx, fy) as arguments.\n\nArguments\n\nu::ScalarField: Field template\nf: Mask function (fx, fy) -> m in Fourier space (complex)\ntrainable::Bool: Enable optimization (default: false)\nbuffered::Bool: Pre-allocate gradients (default: false)\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (1.0, 1.0), 1.064)\n\n# Low-pass filter (sharp cutoff)\nf_cutoff = 0.2  # 1/μm\nlowpass = FourierMask(u, (fx, fy) -> sqrt(fx^2 + fy^2) < f_cutoff ? 1.0 : 0.0)\n\n# Gaussian filter\nsigma_f = 0.15\ngaussian_filter = FourierMask(u, (fx, fy) -> exp(-(fx^2 + fy^2)/(2*sigma_f^2)))\n\nSee also: FourierPhase, FourierWrapper, Mask\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/fourier/fourier/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/fourier/fourier/","page":"API","title":"API","text":"Phase for spatial-domain phase masks\nMask for spatial-domain amplitude masks\nCore for component interface","category":"page"},{"location":"api/optical_components/sources/sources/#Sources-API","page":"API","title":"Sources API","text":"","category":"section"},{"location":"api/optical_components/sources/sources/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/optical_components/sources/sources/#FluxOptics.OpticalComponents.ScalarSource","page":"API","title":"FluxOptics.OpticalComponents.ScalarSource","text":"ScalarSource(u::ScalarField; trainable=false, buffered=false)\n\nCreate a scalar optical source from a field template.\n\nSources generate optical fields at the beginning of an optical system. The source stores a copy of the input field and reproduces it (or an optimized version if trainable) when propagated.\n\nArguments\n\nu::ScalarField: Template field defining spatial grid, wavelength, and initial amplitude\ntrainable::Bool: If true, field amplitude/phase can be optimized (default: false)\nbuffered::Bool: If true, pre-allocate gradient buffers (default: false)\n\nExamples\n\njulia> xv, yv = spatial_vectors(64, 64, 2.0, 2.0);\n\njulia> w0 = 10.0;\n\njulia> u0 = ScalarField(Gaussian(w0)(xv, yv), (2.0, 2.0), 1.064);\n\njulia> source = ScalarSource(u0); # Static source (fixed beam profile)\n\njulia> u = propagate(source);\n\njulia> source_train = ScalarSource(u0; trainable=true, buffered=true); # Trainable source (optimizable beam)\n\njulia> phase_mask = Phase(u, (x, y) -> 0.01 * (x^2 + y^2));\n\njulia> propagator = ASProp(u0, 500.0);\n\njulia> system = source_train |> phase_mask |> propagator;\n\n\nSee also: get_source, propagate\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/sources/sources/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/optical_components/sources/sources/#FluxOptics.OpticalComponents.get_source-Tuple{ScalarSource}","page":"API","title":"FluxOptics.OpticalComponents.get_source","text":"get_source(source::ScalarSource)\n\nAccess the current field stored in a scalar source.\n\nReturns a reference to the source's internal field. Useful for inspection or extracting the optimized beam profile after training.\n\nExamples\n\nsource = ScalarSource(u0; trainable=true)\n# ... after optimization ...\noptimized_field = get_source(source)\n\nSee also: ScalarSource\n\n\n\n\n\n","category":"method"},{"location":"api/optical_components/sources/sources/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/sources/sources/","page":"API","title":"API","text":"ScalarField for field representation\npropagate for field generation\nModes for beam profile generation\nSystem for optical system composition","category":"page"},{"location":"api/optical_components/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"Helper components for field manipulation and optimization.","category":"page"},{"location":"api/optical_components/utilities/#Overview","page":"Utilities","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"The Utilities module provides:","category":"page"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"Pad/crop operators for memory-efficient propagation\nTilt anchors for off-axis beam tracking\nBasis projection for reduced-parameter optimization","category":"page"},{"location":"api/optical_components/utilities/#Examples","page":"Utilities","title":"Examples","text":"","category":"section"},{"location":"api/optical_components/utilities/#Pad-and-Crop","page":"Utilities","title":"Pad and Crop","text":"","category":"section"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"using FluxOptics\n\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\n\n# Basic padding\nu_pad = pad(u.electric, (256, 256))\nsize(u_pad)","category":"page"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"# Centered padding\noffset = ((256-128)÷2, (256-128)÷2)\nu_centered = pad(u.electric, (256, 256); offset=offset)\n\n# Cropping back\nu_crop = crop(u_centered, (128, 128); offset=offset)\nsize(u_crop)","category":"page"},{"location":"api/optical_components/utilities/#PadCropOperator","page":"Utilities","title":"PadCropOperator","text":"","category":"section"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"# Efficient pad/crop in systems\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\nu_tmp = zeros(ComplexF64, 256, 256)\n\npad_op = PadCropOperator(u, u_tmp; store_ref=true)\ncrop_op = adjoint(pad_op)\n\n# Create source\nsource = ScalarSource(u)\n\n# Avoid aliasing during propagation\nprop = ASProp(set_field_data(u, u_tmp), 1000.0)\nsystem = source |> pad_op |> prop |> crop_op\n\n# Execute system\nresult = system()\nsize(result.out)","category":"page"},{"location":"api/optical_components/utilities/#Basis-Projection","page":"Utilities","title":"Basis Projection","text":"","category":"section"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"using FluxOptics\n\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\nsource = ScalarSource(u)\n\n# Polynomial basis\nn_basis = 10\nbasis = make_spatial_basis((x, y, n) -> (x^2 + y^2)^n, \n                          (128, 128), (2.0, 2.0), 0:n_basis-1)\n\n# Wrap trainable phase\nphase = Phase(u, (x, y) -> 0.0; trainable=true)\nwrapper = BasisProjectionWrapper(phase, basis, zeros(n_basis))\n\npropagator = ASProp(u, 500.0)\n\n# Optimize n_basis coefficients instead of 128×128 pixels\nsystem = source |> wrapper |> propagator\nresult = system()\n\n# Show we're optimizing only n_basis parameters\nparams = trainable(wrapper)\nlength(params.proj_coeffs)","category":"page"},{"location":"api/optical_components/utilities/#Key-Types","page":"Utilities","title":"Key Types","text":"","category":"section"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"PadCropOperator: Reversible pad/crop component\nTiltAnchor: Tilt reference anchor\nBasisProjectionWrapper: Basis coefficient optimization","category":"page"},{"location":"api/optical_components/utilities/#Key-Functions","page":"Utilities","title":"Key Functions","text":"","category":"section"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"pad, crop: Array padding and cropping\nmake_spatial_basis: Spatial basis generation\nmake_fourier_basis: Fourier basis generation","category":"page"},{"location":"api/optical_components/utilities/#See-Also","page":"Utilities","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"Core for component interface\nSystem for component composition","category":"page"},{"location":"api/optical_components/utilities/#Index","page":"Utilities","title":"Index","text":"","category":"section"},{"location":"api/optical_components/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [FluxOptics.OpticalComponents]\nPages = [\"utilities.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/metrics/metrics/#Metrics-API","page":"API","title":"Metrics API","text":"","category":"section"},{"location":"api/metrics/metrics/#Abstract-Types","page":"API","title":"Abstract Types","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.AbstractMetric","page":"API","title":"FluxOptics.Metrics.AbstractMetric","text":"AbstractMetric\n\nAbstract base type for optimization metrics in inverse optics design.\n\nMetrics are callable objects that evaluate optimization objectives on optical fields. They encapsulate target references and pre-allocated buffers for efficient gradient computation during iterative optimization.\n\nInterface\n\nSubtypes must implement:\n\ncompute_metric(m::AbstractMetric, u::NTuple{N, ScalarField}): Evaluate metric\nbackpropagate_metric(m::AbstractMetric, u::NTuple{N, ScalarField}, ∂c): Compute gradients\n\nCallable Interface\n\nAll metrics are callable:\n\nmetric = PowerCoupling(target)\nloss = metric(u)                    # Single field\nlosses = metric(u1, u2)             # Multiple fields\n\nAvailable Metrics\n\nDotProduct: Complex overlap integral ⟨u,v⟩\nPowerCoupling: Power coupled to target modes\nSquaredFieldDifference: Field amplitude/phase matching\nSquaredIntensityDifference: Intensity pattern matching\n\nDesign Philosophy\n\nStateful: Pre-allocate buffers at construction for zero-allocation evaluation\nFlexible: Support single or multiple fields, mode-selective or full matrices\nEfficient: Custom gradient implementations via backpropagate_metric\nComposable: Combine metrics for multi-objective optimization\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Core-Functions","page":"API","title":"Core Functions","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.AbstractMetric-Tuple{ScalarField}","page":"API","title":"FluxOptics.Metrics.AbstractMetric","text":"(m::AbstractMetric)(u::Vararg{ScalarField})\n(m::AbstractMetric)(u::ScalarField)\n\nCallable interface for metrics. Equivalent to compute_metric(m, u).\n\nThis is the preferred way to evaluate metrics.\n\nExamples\n\nmetric = PowerCoupling(target)\n\n# Single field\nloss = metric(u)\n\n# Multiple fields\nmetric_multi = DotProduct(target1, target2)\nlosses = metric_multi(u1, u2)\n\nSee also: compute_metric\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.compute_metric","page":"API","title":"FluxOptics.Metrics.compute_metric","text":"compute_metric(m::AbstractMetric, u::NTuple{N, ScalarField})\ncompute_metric(m::AbstractMetric, u::ScalarField)\n\nEvaluate a metric on one or more optical fields.\n\nThis is the core evaluation function for metrics. In practice, prefer using the callable interface metric(u) which calls this function internally.\n\nArguments\n\nm::AbstractMetric: The metric to evaluate.\nu: Single ScalarField or tuple of ScalarFields.\n\nReturns\n\nArray(s) containing metric values. Dimensions depend on the specific metric type and whether mode_selective=true.\n\nExamples\n\nmetric = PowerCoupling(target)\n\n# Callable interface (preferred)\nloss = metric(u)\n\n# Explicit call (equivalent)\nloss = compute_metric(metric, u)\n\n# Multiple fields\nmetric_multi = DotProduct(target1, target2)\nlosses = compute_metric(metric_multi, (u1, u2))\n\nSee also: backpropagate_metric, AbstractMetric\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.backpropagate_metric","page":"API","title":"FluxOptics.Metrics.backpropagate_metric","text":"backpropagate_metric(m::AbstractMetric, u::NTuple{N, ScalarField}, ∂c)\n\nCompute gradients of metric with respect to input fields.\n\nUsed internally by automatic differentiation. Most users don't need to call this directly.\n\nArguments\n\nm::AbstractMetric: The metric.\nu: Tuple of input fields.\n∂c: Gradient w.r.t. metric output.\n\nReturns\n\nTuple of ScalarFields containing gradients w.r.t. each input field.\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/metrics/#Dot-Product-Metrics","page":"API","title":"Dot Product Metrics","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.DotProduct","page":"API","title":"FluxOptics.Metrics.DotProduct","text":"DotProduct(fields...; mode_selective::Bool=true)\n\nCompute dot product (inner product) between optical fields for optimization.\n\nThis metric calculates the complex overlap integral ⟨u,v⟩ between fields, commonly used  for mode coupling analysis and field matching objectives in inverse design.\n\nArguments\n\nfields...: Reference ScalarField(s) to compare against.\nmode_selective::Bool=true: If true, compute per-mode overlaps. If false, compute full overlap matrix.\n\nMathematical definition\n\n⟨u,v⟩ = ∫∫ u*(x,y) v(x,y) dx dy\n\nExamples\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 2);\n\njulia> data[3:end,:,2] .= -ones(ComplexF64, 2, 4);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> normalize_power!(u);\n\njulia> metric_selective = DotProduct(u);\n\njulia> metric_selective(u)\n1×1×2 Array{ComplexF64, 3}:\n[:, :, 1] =\n 1.0 + 0.0im\n\n[:, :, 2] =\n 1.0 + 0.0im\n\njulia> metric_non_selective = DotProduct(u; mode_selective = false);\n\njulia> metric_non_selective(u)\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\nSee also: PowerCoupling\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.PowerCoupling","page":"API","title":"FluxOptics.Metrics.PowerCoupling","text":"PowerCoupling(fields...; mode_selective::Bool=true)\n\nCompute power coupled into target optical modes.\n\nThis metric calculates |⟨u,v̂⟩|², the optical power (in Watts) coupled from field u  into normalized target modes v̂. The target fields are copied and normalized internally  to unit power, leaving the original fields unmodified.\n\nArguments\n\nfields...: Target ScalarField(s) to couple into (copied and normalized internally).\nmode_selective::Bool=true: If true, compute per-mode coupling. If false, compute full coupling matrix.\n\nMathematical definition\n\nP_coupled = |⟨u,v̂⟩|² where v̂ are normalized copies of the target fields\n\nExamples\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 2);\n\njulia> data[3:end,:,2] .= -ones(ComplexF64, 2, 4);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> normalize_power!(u);\n\njulia> metric_selective = PowerCoupling(u);\n\njulia> metric_selective(u)\n1×1×2 Array{Float64, 3}:\n[:, :, 1] =\n 1.0\n\n[:, :, 2] =\n 1.0\n\njulia> metric_non_selective = PowerCoupling(u; mode_selective = false);\n\njulia> metric_non_selective(u)\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\nSee also: DotProduct\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Field-Difference-Metrics","page":"API","title":"Field Difference Metrics","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.SquaredFieldDifference","page":"API","title":"FluxOptics.Metrics.SquaredFieldDifference","text":"SquaredFieldDifference(fields...)\n\nCompute squared L² norm difference between complex optical fields.\n\nThis metric calculates ‖u - v‖², the squared field difference, commonly used as a loss function for direct field matching in inverse design problems.\n\nArguments\n\nfields...: Reference ScalarField(s) to match against.\n\nMathematical definition\n\nL = ∫∫ |u(x,y) - v(x,y)|² dx dy = ‖u - v‖²\n\nExamples\n\n# Small example for documentation - use larger arrays in practice\njulia> data1 = ones(ComplexF64, 4, 4);\n\njulia> target = ScalarField(data1, (1.0, 1.0), 1.064);\n\njulia> data2 = zeros(ComplexF64, 4, 4);\n\njulia> current = ScalarField(data2, (1.0, 1.0), 1.064);\n\njulia> metric = SquaredFieldDifference(target);\n\njulia> metric(current)\n1×1 Matrix{Float64}:\n 16.0\n\nSee also: SquaredIntensityDifference\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.SquaredIntensityDifference","page":"API","title":"FluxOptics.Metrics.SquaredIntensityDifference","text":"SquaredIntensityDifference(field_intensity_pairs...)\n\nCompute squared difference between field intensities and target patterns.\n\nThis metric supports two modes depending on target array dimensions:\n\nFull dimensions: Target has same dimensions as field → compare each mode individually\nSpatial only: Target has only spatial dimensions → compare total intensity across all modes\n\nArguments\n\nfield_intensity_pairs...: Tuples of (ScalarField, targetintensityarray).\n\nMathematical definition\n\nFull dimensions case: L = ∫∫ |uₖ(x,y)|² - Itargetₖ(x,y)|² dx dy (per mode)\n\nSpatial only case: L = ∫∫ |(∑ₖ |uₖ(x,y)|²) - Itarget(x,y)|² dx dy (total intensity)\n\nExamples\n\nFull dimensions case (mode-by-mode comparison):\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 2);\n\njulia> field = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> target_intensity = zeros(4, 4, 2);  # Same dimensions as field\n\njulia> metric = SquaredIntensityDifference((field, target_intensity));\n\njulia> metric(field)\n1×1×2 Array{Float64, 3}:\n[:, :, 1] =\n 16.0\n\n[:, :, 2] =\n 16.0\n\nSpatial only case (total intensity comparison):\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 3);\n\njulia> field = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> target_intensity = 3*ones(4, 4);  # Only spatial dimensions\n\njulia> metric = SquaredIntensityDifference((field, target_intensity));\n\njulia> metric(field)\n1×1 Matrix{Float64}:\n 0.0\n\nSee also: SquaredFieldDifference\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/metrics/metrics/#Metric-Types","page":"API","title":"Metric Types","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"All metrics are subtypes of AbstractMetric\nMetrics are callable: metric(field) calls compute_metric\nSupport single or multiple field arguments","category":"page"},{"location":"api/metrics/metrics/#Mode-Selectivity","page":"API","title":"Mode Selectivity","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"mode_selective=true: Compute per-mode metrics (diagonal)\nmode_selective=false: Compute full coupling matrix\nAffects output dimensionality and computational cost","category":"page"},{"location":"api/metrics/metrics/#Normalization","page":"API","title":"Normalization","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"PowerCoupling normalizes targets internally (copies first)\nDotProduct uses fields as-is\nConsider normalizing input fields before metrics","category":"page"},{"location":"api/metrics/metrics/#Performance","page":"API","title":"Performance","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"Metrics cache internal buffers to avoid allocations\nUse in-place operations where possible","category":"page"},{"location":"api/metrics/metrics/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"OptimisersExt for optimization algorithms","category":"page"},{"location":"api/optical_components/modulators/#Modulators","page":"Modulators","title":"Modulators","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"Phase and amplitude modulation components.","category":"page"},{"location":"api/optical_components/modulators/#Overview","page":"Modulators","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"The Modulators module provides components that modify the amplitude and phase of optical fields through masks, diffractive elements, and reflective surfaces.","category":"page"},{"location":"api/optical_components/modulators/#Examples","page":"Modulators","title":"Examples","text":"","category":"section"},{"location":"api/optical_components/modulators/#Phase-Modulation","page":"Modulators","title":"Phase Modulation","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"using FluxOptics\n\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nu = ScalarField(Gaussian(50.0)(xv, yv), (2.0, 2.0), 1.064)\n\n# Parabolic phase (lens-like)\nphase_lens = Phase(u, (x, y) -> π/(1000^2) * (x^2 + y^2))\n\nistrainable(phase_lens)  # false (static)","category":"page"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"# Trainable phase mask for optimization\nphase_opt = Phase(u, (x, y) -> 0.0; trainable=true, buffered=true)\n\n(istrainable(phase_opt), isbuffered(phase_opt))","category":"page"},{"location":"api/optical_components/modulators/#Amplitude-Modulation","page":"Modulators","title":"Amplitude Modulation","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"# Circular aperture\nradius = 80.0\naperture = Mask(u, (x, y) -> sqrt(x^2 + y^2) < radius ? 1.0 : 0.0)\n\n# Apply to field\nu_masked = propagate(u, aperture, Forward)\n\n# Check power reduction\n(power(u)[], power(u_masked)[])","category":"page"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"# Gaussian apodization (smooth amplitude taper)\nw0 = 100.0\napodization = Mask(u, (x, y) -> exp(-(x^2 + y^2)/(2*w0^2)))\n\nu_apodized = propagate(u, apodization, Forward)\n\npower(u_apodized)[]","category":"page"},{"location":"api/optical_components/modulators/#Diffractive-Elements","page":"Modulators","title":"Diffractive Elements","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"# Sinusoidal grating\nΔn = 0.5  # Refractive index difference\nperiod = 50.0  # Grating period\ngrating = TeaDOE(u, Δn, (x, y) -> 0.5 * sin(2π * x / period))\n\n# Trainable DOE for beam shaping\ndoe_opt = TeaDOE(u, 0.5, (x, y) -> 0.0; trainable=true, buffered=true)\n\nistrainable(doe_opt)","category":"page"},{"location":"api/optical_components/modulators/#Using-in-Systems","page":"Modulators","title":"Using in Systems","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"# Combine multiple modulators\nsource = ScalarSource(u)\nphase = Phase(u, (x, y) -> 0.01 * (x^2 + y^2))\naperture = Mask(u, (x, y) -> sqrt(x^2 + y^2) < 60.0 ? 1.0 : 0.0)\nprop = ASProp(u, 1000.0)\n\nsystem = source |> phase |> aperture |> prop\n\nresult = system()\npower(result.out)[]","category":"page"},{"location":"api/optical_components/modulators/#Key-Types","page":"Modulators","title":"Key Types","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"Phase: Pure phase modulation exp(iφ)\nMask: Amplitude or complex transmission\nTeaDOE: Diffractive element (thin element approximation)\nTeaReflector: Reflective element (mirrors, deformable mirrors)","category":"page"},{"location":"api/optical_components/modulators/#Physical-Behavior","page":"Modulators","title":"Physical Behavior","text":"","category":"section"},{"location":"api/optical_components/modulators/#Phase-Masks","page":"Modulators","title":"Phase Masks","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"Apply transmission: t(x,y) = exp(iφ(x,y))\nForward: +φ, Backward: -φ (adjoint)\nConserve power (unitary)","category":"page"},{"location":"api/optical_components/modulators/#Amplitude-Masks","page":"Modulators","title":"Amplitude Masks","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"Apply transmission: t(x,y) = m(x,y) (complex-valued)\nForward: m, Backward: conj(m) (adjoint)\nReal m: pure amplitude, Complex m: amplitude + phase","category":"page"},{"location":"api/optical_components/modulators/#Diffractive-Elements-(TeaDOE)","page":"Modulators","title":"Diffractive Elements (TeaDOE)","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"Phase from surface height: φ = 2π Δn h(x,y) / λ\nWavelength-dependent (dispersion)\nOptional wavelength-dependent reflectivity","category":"page"},{"location":"api/optical_components/modulators/#Reflectors-(TeaReflector)","page":"Modulators","title":"Reflectors (TeaReflector)","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"Special case: Δn = 2 (reflection doubles optical path)\nPhase: φ = 4π h(x,y) / λ\nModels deformable mirrors, curved mirrors","category":"page"},{"location":"api/optical_components/modulators/#See-Also","page":"Modulators","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"Typical Workflow - Phase mask optimization example\nCore - Trainability system\nFourier - Frequency-domain modulation","category":"page"},{"location":"api/optical_components/modulators/#Index","page":"Modulators","title":"Index","text":"","category":"section"},{"location":"api/optical_components/modulators/","page":"Modulators","title":"Modulators","text":"Modules = [FluxOptics.OpticalComponents]\nPages = [\"modulators.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/optical_components/freespace/freespace/#Free-Space-Propagators-API","page":"API","title":"Free-Space Propagators API","text":"","category":"section"},{"location":"api/optical_components/freespace/freespace/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/optical_components/freespace/freespace/#FluxOptics.OpticalComponents.ASProp","page":"API","title":"FluxOptics.OpticalComponents.ASProp","text":"ASProp(u::ScalarField, ds::NTuple, z::Real; use_cache=true, n0=1, filter=nothing, paraxial=false, double_precision_kernel=use_cache)\nASProp(u::ScalarField, z::Real; kwargs...)\n\nAngular Spectrum propagation in homogeneous media.\n\nPropagates scalar fields through uniform medium with refractive index n0 using FFT-based Angular Spectrum method. Automatically handles both on-axis and tilted beams (unified implementation).\n\nArguments\n\nu::ScalarField: Field template\nds::NTuple: Custom spatial sampling (defaults to u.ds)\nz::Real: Propagation distance (positive or negative)\nuse_cache::Bool: Cache kernels (default: true)\nn0::Real: Refractive index (default: 1)\nfilter: Optional frequency filter function (fx, fy) -> transmission\nparaxial::Bool: Use paraxial approximation (default: false)\ndouble_precision_kernel::Bool: Compute kernels in Float64 (default: use_cache)\n\nReturns\n\nStatic propagator component (not trainable).\n\nNotes\n\nWhen use_cache=true, kernels are computed once and stored, so using Float64 precision (double_precision_kernel=true) adds no computational cost while improving accuracy. For ComplexF64 fields, kernels are always computed in Float64 regardless of this setting. The option primarily affects ComplexF32 fields (e.g., CUDA applications).\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (2.0, 2.0), 1.064)\n\n# Simple propagation in air\nprop = ASProp(u, 1000.0)\n\n# In glass\nprop_glass = ASProp(u, 1000.0; n0=1.5)\n\n# With low-pass filter\nfilter_lp = (fx, fy) -> sqrt(fx^2 + fy^2) < 0.3 ? 1.0 : 0.0\nprop_filtered = ASProp(u, 1000.0; filter=filter_lp)\n\nSee also: ASPropZ, ParaxialProp, RSProp\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/freespace/freespace/#FluxOptics.OpticalComponents.ASPropZ","page":"API","title":"FluxOptics.OpticalComponents.ASPropZ","text":"ASPropZ(u::ScalarField, ds::NTuple, z::Real; n0=1, trainable=false, paraxial=false, filter=nothing, double_precision_kernel=false)\nASPropZ(u::ScalarField, z::Real; kwargs...)\n\nAngular Spectrum propagation with trainable distance.\n\nSimilar to ASProp but with trainable propagation distance z for optimization. Uses automatic differentiation (Zygote, Enzyme) for gradients.\n\nArguments\n\nu::ScalarField: Field template\nds::NTuple: Custom spatial sampling (defaults to u.ds)\nz::Real: Initial propagation distance\nn0::Real: Refractive index (default: 1)\ntrainable::Bool: Enable distance optimization (default: false)\nparaxial::Bool: Use paraxial approximation (default: false)\nfilter: Optional frequency filter\ndouble_precision_kernel::Bool: Use Float64 kernels (default: false)\n\nNotes\n\nUnlike ASProp kernels are never cached, so using Float64 precision (double_precision_kernel=true) adds computational cost in case of ComplexF32 fields (e.g., CUDA applications).\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (2.0, 2.0), 1.064)\n\n# Trainable distance\nprop_z = ASPropZ(u, 500.0; trainable=true)\n\nsystem = source |> phase |> prop_z\n# ... optimize distance via gradients ...\n\nNote: Slower than ASProp for fixed distances due to data allocation and AD overhead.\n\nSee also: ASProp, Trainability\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/freespace/freespace/#FluxOptics.OpticalComponents.RSProp","page":"API","title":"FluxOptics.OpticalComponents.RSProp","text":"RSProp(u::ScalarField, z::Real; use_cache=true, track_tilts=false, double_precision_kernel=use_cache)\nRSProp(u::ScalarField, ds::NTuple, z::Real; kwargs...)\n\nRayleigh-Sommerfeld diffraction propagation.\n\nUses Rayleigh-Sommerfeld diffraction integral for field propagation. Prevents aliasing for large propagation distances but requires finer sampling for short distances.\n\nArguments\n\nu::ScalarField: Field template\nz::Real: Propagation distance\nds::NTuple: Custom spatial sampling (defaults to u.ds)\nuse_cache::Bool: Cache kernels (default: true)\ntrack_tilts::Bool: Track tilt evolution (default: false)\ndouble_precision_kernel::Bool: Use Float64 kernels (default: use_cache)\n\nValidity\n\nCritical distance:\n\nz_c = (N dx / 2) √(4dx²/λ² - 1)\n\nIf z < z_c, a warning is issued. Use ASProp or finer sampling instead.\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (0.5, 0.5), 1.064)  # dx < λ/2\n\n# Short distance propagation\nprop = RSProp(u, 100.0)\n\nu_out = propagate(u, prop, Forward)\n\nSee also: ASProp\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/freespace/freespace/#FluxOptics.OpticalComponents.CollinsProp","page":"API","title":"FluxOptics.OpticalComponents.CollinsProp","text":"CollinsProp(u::ScalarField, ds::NTuple, ds′::NTuple, abd::Tuple; use_cache=true, track_tilts=false, double_precision_kernel=use_cache)\nCollinsProp(u::ScalarField, ds′::NTuple, abd::Tuple; kwargs...)\n\nCollins integral (ABCD matrix) propagation with grid resampling.\n\nImplements paraxial propagation through ABCD optical systems with user-defined grid resampling. The ABCD matrix is [[A, B], [C, D]] where C is determined by AD - BC = 1.\n\nArguments\n\nu::ScalarField: Field template\nds::NTuple: Input sampling (defaults to u.ds)\nds′::NTuple: Output grid sampling\nabd::Tuple{Real, Real, Real}: ABCD parameters (A, B, D)\nuse_cache::Bool: Cache kernels (default: true)\ntrack_tilts::Bool: Track tilt evolution (default: false)\ndouble_precision_kernel::Bool: Use Float64 kernels (default: use_cache)\n\nValidity\n\nCannot be used with B ≃ 0.\n\nABCD Examples\n\nFree space: (1, z, 1)\nThin lens (f): (1, 0, 1) : cannot be used separately, must be combined with an ABCD system where B ≠ 0\nFourier transform: (0, f, 0)\n\nExamples\n\nxv, yv = spatial_vectors(256, 256, 0.25, 0.25)\n\nu = ScalarField(Gaussian(5.0)(xv, yv), (0.5, 0.5), 1.064)\n\n# Free-space with magnification\nprop = CollinsProp(u, (2.0, 2.0), (1, 1500.0, 1))\n\n# Lens system (f = 1000 μm)\nlens_system = CollinsProp(u, (4.0, 4.0), (5.0, 2000.0, -0.5))\n\nu_prop = propagate(u, prop, Forward)\n\nu_sys = propagate(u, lens_system, Forward)\n\nSee also: FourierLens, ParaxialProp\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/freespace/freespace/#FluxOptics.OpticalComponents.FourierLens","page":"API","title":"FluxOptics.OpticalComponents.FourierLens","text":"FourierLens(u::ScalarField, ds::NTuple, ds′::NTuple, fl::Real; use_cache=true, double_precision_kernel=use_cache)\nFourierLens(u::ScalarField, ds′::NTuple, fl::Real; kwargs...)\n\nIdeal Fourier lens with grid resampling.\n\nPerforms Fourier transform with magnification and grid resampling. Equivalent to CollinsProp with ABCD = (0, f, 0).  Unlike the FFT, it does not perform an fftshift, so the beams shift by an amount related to their linear phase, as would be expected.\n\nArguments\n\nu::ScalarField: Field template\nds::NTuple: Input sampling (defaults to u.ds)\nds′::NTuple: Output grid sampling\nfl::Real: Focal length\nuse_cache::Bool: Cache kernels (default: true)\ndouble_precision_kernel::Bool: Use Float64 kernels (default: use_cache)\n\nExamples\n\nxv, yv = spatial_vectors(256, 256, 0.25, 0.25)\n\nu = ScalarField(Gaussian(5.0)(xv, yv), (0.5, 0.5), 1.064)\n\n# Fourier plane with magnification\nlens = FourierLens(u, (1.5, 1.5), 1000.0)\n\n# Beam collimiation\nu_col = propagate(u, lens, Forward)\n\nSee also: CollinsProp, ParaxialProp\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/freespace/freespace/#FluxOptics.OpticalComponents.ParaxialProp","page":"API","title":"FluxOptics.OpticalComponents.ParaxialProp","text":"ParaxialProp(u::ScalarField, ds::NTuple, ds′::NTuple, z::Real; use_cache=true, filter=nothing, double_precision_kernel=use_cache)\nParaxialProp(u::ScalarField, ds′::NTuple, z::Real; kwargs...)\nParaxialProp(u::ScalarField, z::Real; kwargs...)\n\nParaxial propagation with optional grid resampling.\n\nConvenience wrapper: uses ASProp (paraxial mode) when no magnification, or CollinsProp when grid resampling is needed.\n\nArguments\n\nu::ScalarField: Field template\nds::NTuple: Input sampling (defaults to u.ds)\nds′::NTuple: Output sampling (triggers Collins if ≠ input)\nz::Real: Propagation distance\nuse_cache::Bool: Cache kernels (default: true)\nfilter: Optional frequency filter\ndouble_precision_kernel::Bool: Use Float64 kernels (default: use_cache)\n\nExamples\n\nxv, yv = spatial_vectors(256, 256, 0.25, 0.25)\n\nu = ScalarField(Gaussian(5.0)(xv, yv), (0.5, 0.5), 1.064)\n\n# No magnification -> uses ASProp\nprop1 = ParaxialProp(u, 1000.0)\n\n# With magnification -> uses CollinsProp\nprop2 = ParaxialProp(u, (1.0, 1.0), 1000.0)\n\nSee also: ASProp, CollinsProp\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/freespace/freespace/#FluxOptics.OpticalComponents.ShiftProp","page":"API","title":"FluxOptics.OpticalComponents.ShiftProp","text":"ShiftProp(u::ScalarField, ds::NTuple, z::Real; use_cache=true, double_precision_kernel=use_cache)\nShiftProp(u::ScalarField, z::Real; kwargs...)\n\nGeometric shift based on field tilts (no diffraction).\n\nTranslates field geometrically based on tilt metadata. Ignores diffraction entirely, approximating ray optics. Useful for comparison with diffraction-based methods.\n\nArguments\n\nu::ScalarField: Field template (must have tilts defined)\nds::NTuple: Custom sampling (defaults to u.ds)\nz::Real: Propagation distance\nuse_cache::Bool: Cache kernels (default: true)\ndouble_precision_kernel::Bool: Use Float64 kernels (default: use_cache)\n\nPhysics\n\nShift: Δx = z tan(θx), Δy = z tan(θy)\n\nApplied in Fourier domain as linear phase: exp(-i 2π z tan(θ) fx)\n\nLimitation: Only uses tilt metadata, cannot detect phase gradients in the complex field itself.\n\nExamples\n\n# Requires tilted field\nxv, yv = spatial_vectors(256, 256, 0.25, 0.25)\n\nu = ScalarField(Gaussian(50.0)(xv, yv), (2.0, 2.0), 1.064; tilts=(0.01, 0.0))\n\n# Pure geometric shift\nshift = ShiftProp(u, 1000.0)\n\n# Compare with diffraction\nas_prop = ASProp(u, 1000.0)\n\nSee also: ASProp, Shift_BPM\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/freespace/freespace/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/optical_components/freespace/freespace/#Angular-Spectrum-Method","page":"API","title":"Angular Spectrum Method","text":"","category":"section"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"Kernel in frequency domain:","category":"page"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"On-axis: H = exp(i 2π z √(1/λ² - fx² - fy²))\nTilted: Modified with tilt offsets","category":"page"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"Handles both paraxial and non-paraxial regimes.","category":"page"},{"location":"api/optical_components/freespace/freespace/#Rayleigh-Sommerfeld","page":"API","title":"Rayleigh-Sommerfeld","text":"","category":"section"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"Direct convolution with Green's function:","category":"page"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"G(r) = (z/r²)(1/r - ik) exp(ikr) / (2π)","category":"page"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"Requires fine sampling (dx < λ/2) to avoid aliasing.","category":"page"},{"location":"api/optical_components/freespace/freespace/#Collins-Integral","page":"API","title":"Collins Integral","text":"","category":"section"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"ABCD propagation with chirp multiplication and convolution:","category":"page"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"Input chirp: exp(i π A/B (x² + y²) / λ)\nConvolution with kernel\nOutput chirp: exp(i π D/B (x'² + y'²) / λ)\nGrid resampling","category":"page"},{"location":"api/optical_components/freespace/freespace/#Grid-Resampling","page":"API","title":"Grid Resampling","text":"","category":"section"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"FourierLens and CollinsProp change grid sampling:","category":"page"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"Input grid: ds\nOutput grid: ds'\nMagnification: M = ds' / ds","category":"page"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"Grid center (x=0, y=0) is reference, consistent with beam definitions.","category":"page"},{"location":"api/optical_components/freespace/freespace/#Geometric-Shift","page":"API","title":"Geometric Shift","text":"","category":"section"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"Pure translation based on tilt metadata:","category":"page"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"No diffraction\nShift: Δx = z tan(θx)\nApplied as Fourier phase: exp(-i 2π z tan(θ) fx)","category":"page"},{"location":"api/optical_components/freespace/freespace/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/freespace/freespace/","page":"API","title":"API","text":"propagate for field propagation\nBulk Propagators for inhomogeneous media\nCore for component interface","category":"page"},{"location":"api/fields/#Fields","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"The ScalarField type and field operations.","category":"page"},{"location":"api/fields/#Overview","page":"Fields","title":"Overview","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"The Fields module provides:","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"ScalarField type: Central data structure for optical fields\nMulti-wavelength support: Handle multiple wavelengths simultaneously\nTilt tracking: Manage off-axis propagation\nField operations: Power, intensity, phase, normalization","category":"page"},{"location":"api/fields/#Examples","page":"Fields","title":"Examples","text":"","category":"section"},{"location":"api/fields/#Creating-Fields","page":"Fields","title":"Creating Fields","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"using FluxOptics\n\n# Create field from mode\ngaussian = Gaussian(20.0)\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nfield_data = gaussian(xv, yv)\nu = ScalarField(field_data, (2.0, 2.0), 1.064)\n\nsize(u)  # Grid dimensions","category":"page"},{"location":"api/fields/#Field-Operations","page":"Fields","title":"Field Operations","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"# Power calculation and normalization\nP_initial = power(u)[]  # Extract scalar from 0-dimensional array\n\nnormalize_power!(u, 2.5)  # Normalize to 2.5 W\nP_normalized = power(u)[]\n\n(P_initial, P_normalized)  # Before: ~1.0, After: 2.5","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"# Intensity and phase distributions\nI = intensity(u)  # 2D array: total intensity\nφ = phase(u)      # Same size as u: phase at each point\n\n(size(I), size(φ))","category":"page"},{"location":"api/fields/#Field-Manipulation","page":"Fields","title":"Field Manipulation","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"# Copy and fill operations\nu_copy = copy(u)          # Independent copy\nu_tmp = similar(u)        # Allocate uninitialized\n\nfill!(u_tmp, 1.0 + 0.0im) # Fill with constant value\n\n# Update field data\nnew_data = 0.5 .* u.electric\nu_new = set_field_data(u, new_data)\n\npower(u_new)[]  # Power scaled by 0.5² = 0.25","category":"page"},{"location":"api/fields/#Multi-Wavelength-Fields","page":"Fields","title":"Multi-Wavelength Fields","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"# Multiple wavelengths simultaneously\nλs = [0.8, 1.064, 1.55]\ndata_multi = zeros(ComplexF64, 128, 128, 3)\nfor (i, λ) in enumerate(λs)\n    g = Gaussian(20.0)\n    data_multi[:, :, i] .= g(xv, yv)\nend\n\nu_multi = ScalarField(data_multi, (2.0, 2.0), λs)\n\n# Power per wavelength\npower(u_multi)  # Returns 1×1×3 array","category":"page"},{"location":"api/fields/#Field-Comparison","page":"Fields","title":"Field Comparison","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"# Compare with another mode\nhg10 = HermiteGaussian(20.0, 1, 0)\nu2 = ScalarField(hg10(xv, yv), (2.0, 2.0), 1.064)\nnormalize_power!(u2)\n\n# Coupling efficiency (mode overlap)\nη = coupling_efficiency(u, u2)\n\nη[]  # Overlap between Gaussian and HG10","category":"page"},{"location":"api/fields/#Field-with-Tilts","page":"Fields","title":"Field with Tilts","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"# Off-axis propagation\nu_tilted = ScalarField(field_data, (2.0, 2.0), 1.064; tilts=(0.01, 0.005))\n\nis_on_axis(u_tilted)  # false","category":"page"},{"location":"api/fields/#Key-Types","page":"Fields","title":"Key Types","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"ScalarField: Optical field with grid information","category":"page"},{"location":"api/fields/#Key-Functions","page":"Fields","title":"Key Functions","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Field Construction and Data","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"ScalarField: Create optical field\nset_field_data: Update field data\nsimilar: Allocate similar field\ncopy: Copy field\nfill!: Fill field with values\ncopyto!: Copy between fields\ncollect: Convert to CPU array","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Field Properties","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"size: Get field dimensions\nndims: Number of dimensions\neltype: Element type","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Tilts Management","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"set_field_tilts: Update field tilts\noffset_tilts!: Add tilt offset with phase correction\nis_on_axis: Check if field is on-axis","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Power and Intensity","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"power: Calculate field power\nnormalize_power!: Normalize to target power\nintensity: Calculate total intensity\nphase: Extract phase distribution","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Field Comparison","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"coupling_efficiency: Coupling efficiency between fields\ndot: Field overlap integral","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Vectorization","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"vec: Vectorize into independent ScalarFields","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Broadcasting and Indexing","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"broadcasted: Element-wise operations\ngetindex: Access field elements\nconj: Complex conjugate","category":"page"},{"location":"api/fields/#See-Also","page":"Fields","title":"See Also","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Modes for generating optical modes\nGridUtils for coordinate systems","category":"page"},{"location":"api/fields/#Index","page":"Fields","title":"Index","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Modules = [FluxOptics.Fields]\nOrder = [:type, :function]","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complete documentation for all FluxOptics.jl modules and functions.","category":"page"},{"location":"api/#Module-Overview","page":"API Reference","title":"Module Overview","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"FluxOptics is organized into focused modules for different aspects of optical simulation and inverse design.","category":"page"},{"location":"api/#Foundation","page":"API Reference","title":"Foundation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"GridUtils - Coordinate systems and transformations   Creates coordinate systems for evaluating optical modes and components on spatial grids. Provides 2D transformations (translations, rotations) and coordinate composition.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modes - Optical mode generation   Generates common optical beam profiles (Gaussian, Hermite-Gaussian, Laguerre-Gaussian) and spatial layouts for multi-mode configurations. Includes speckle generation with controlled statistics.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Fields - Field representation and operations   Provides the ScalarField type, the central data structure representing optical fields with associated grid information, wavelength, and propagation direction. Supports multi-wavelength, tilt tracking, and field operations.","category":"page"},{"location":"api/#Optical-Components","page":"API Reference","title":"Optical Components","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Optical Components - Building blocks for optical systems","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The heart of FluxOptics, providing all optical elements and system composition tools.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Core infrastructure:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Core - Abstract component hierarchy, trainability system (Static/Trainable/Buffered), and bidirectional propagation interface","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Creating and modifying fields:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Sources - Generate initial optical fields (e.g., ScalarSource). Sources are trainable, allowing optimization of input beam profiles\nModulators - Modify field amplitude and phase: Phase for pure phase modulation, Mask for amplitude/complex transmission, TeaDOE for diffractive elements\nFourier - Frequency-domain operations. FourierWrapper applies components in Fourier space, while FourierPhase and FourierMask provide convenient filtering","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Propagating fields:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Free-Space Propagators - Field propagation through homogeneous media: Angular Spectrum (ASProp), Rayleigh-Sommerfeld (RSProp), Collins integral for ABCD systems, Fourier lenses\nBulk Propagators - Beam Propagation Method (BPM) for inhomogeneous media with spatially-varying refractive index. Supports paraxial and non-paraxial tilted propagation\nActive Media - Stationary gain and amplification with saturable gain sheets","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Building systems:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"System - System construction using pipe operator |> to chain components. Fully differentiable and callable. FieldProbe captures intermediate fields for custom objectives, visualization, and debugging","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Advanced utilities:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Utilities - Helper components: PadCropOperator for aliasing-free Fourier-based convolution, TiltAnchor for off-axis beam tracking, BasisProjectionWrapper for reduced-parameter optimization","category":"page"},{"location":"api/#Optimization","page":"API Reference","title":"Optimization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"OptimisersExt - Optimization algorithms and proximal operators   Custom optimization rules (Descent, Momentum, FISTA) and proximal operators for constrained optimization. Use make_rules for per-component learning rates, ProxRule for regularization (TV, sparsity, constraints). Integration with Optimisers.jl ecosystem.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Metrics - Loss functions for inverse design   Field overlap metrics (DotProduct, PowerCoupling) for mode matching, field and intensity matching objectives (SquaredFieldDifference, SquaredIntensityDifference). Custom gradient implementations for efficiency.","category":"page"},{"location":"api/#Visualization","page":"API Reference","title":"Visualization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Plotting - Visualization tools   Field visualization with multiple representations (intensity, phase, real/imaginary, complex). Stack visualization with animated sliders. Component visualization for phase masks and DOEs. Requires Makie.jl backend (CairoMakie, GLMakie, or WGLMakie).","category":"page"},{"location":"api/#Design-Philosophy","page":"API Reference","title":"Design Philosophy","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"FluxOptics follows these principles:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Differentiable by design: All components work with automatic differentiation\nGPU-ready: Seamless CUDA.jl integration for acceleration\nComposable: Build complex systems from simple components using pipe operator\nEfficient: Pre-allocated buffers on-demand and optimized kernels\nFlexible: Support for multi-wavelength, multi-mode, and off-axis propagation","category":"page"},{"location":"api/#Typical-Workflow:-Beam-Splitter","page":"API Reference","title":"Typical Workflow: Beam Splitter","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This example demonstrates inverse design of a cascaded diffractive optical system that splits a single Gaussian beam into four spots arranged in a square pattern. We use a similar setup to the TorchOptics beam splitter example to enable comparison of both performance and API design philosophy.","category":"page"},{"location":"api/#1.-Setup:-Input-and-Target-modes","page":"API Reference","title":"1. Setup: Input and Target modes","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using FluxOptics, Zygote, Optimisers\nusing CairoMakie\n\n# Input: single Gaussian mode\nds = 10.0  # 10 microns\nxv, yv = spatial_vectors(250, 250, ds, ds)\nw0 = 150.0  # 150 microns\nλ = 0.7  # 700 nm\nu0 = ScalarField(Gaussian(w0)(xv, yv), (ds, ds), λ)\nnormalize_power!(u0)  # normalize u0 to unit power\n\n# Target: coherent superposition of four Gaussian modes\noffset = 3.8 * w0\npositions = [(-offset, -offset), (offset, -offset), (-offset, offset), (offset, offset)]\nvf = sum(positions) do (Δx, Δy)\n    ScalarField(Gaussian(w0)(xv, yv, Shift2D(Δx, Δy)), (ds, ds), λ)\nend\nnormalize_power!(vf)  # normalize vf to unit power\n\n# Visualize input and target\nvisualize(((u0, vf),), intensity; colormap=:inferno, height=120)","category":"page"},{"location":"api/#2.-Build-Trainable-System","page":"API Reference","title":"2. Build Trainable System","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"We use a cascade of three trainable phase masks with Rayleigh-Sommerfeld propagation between them:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"source = ScalarSource(u0)\ndoe1 = Phase(u0, (x, y) -> 0.0; trainable=true, buffered=true)\ndoe2 = Phase(u0, (x, y) -> 0.0; trainable=true, buffered=true)\ndoe3 = Phase(u0, (x, y) -> 0.0; trainable=true, buffered=true)\nprop = RSProp(u0, 2e5; use_cache=true)  # 200mm propagation\n\nsystem = source |> doe1 |> prop |> doe2 |> prop |> doe3 |> prop |> (; inplace=true)\nnothing # hide","category":"page"},{"location":"api/#3.-Define-Loss-and-Optimize","page":"API Reference","title":"3. Define Loss and Optimize","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"We maximize power coupling to the target pattern using the Adam optimizer:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"metric = PowerCoupling(vf)\nloss(m) = sum(1 .- metric(m().out))\n\nopt = FluxOptics.setup(Optimisers.Adam(0.1), system)\n\n# Warm up for accurate allocation estimation\n_, g = withgradient(loss, system);\nFluxOptics.update!(opt, system, g[1])\n\n# Reset phase masks (allows re-running optimization)\nforeach(d -> fill!(d, 0), (doe1, doe2, doe3))\n\n# Setup optimizer\nlosses = Float64[]\n\n# Optimization loop\nmem = @allocated for iter in 1:200\n    val, grads = withgradient(loss, system)\n    FluxOptics.update!(opt, system, grads[1])\n    push!(losses, val)\nend\n\nprintln(\"Memory: \", Base.format_bytes(mem))","category":"page"},{"location":"api/#4.-Results","page":"API Reference","title":"4. Results","text":"","category":"section"},{"location":"api/#Convergence","page":"API Reference","title":"Convergence","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"fig = Figure(size=(300, 250))\nax = Axis(fig[1, 1], \n    yscale=log10, \n    xlabel=\"Iteration\", \n    ylabel=\"Loss\",\n    title=\"Optimization Convergence\"\n)\nlines!(ax, losses; linewidth=2)\nfig","category":"page"},{"location":"api/#Final-Output-Field","page":"API Reference","title":"Final Output Field","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"uf = system().out\nvisualize(uf, (intensity, x -> -phase(x)); \n    colormap=(:inferno, twilight_shifted), height=120)","category":"page"},{"location":"api/#Optimized-Phase-Masks","page":"API Reference","title":"Optimized Phase Masks","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Extract and visualize the three DOE phase profiles\ndoe_phases = hcat(map(d -> -angle.(cis.(collect(d))), (doe1, doe2, doe3)))\n\nvisualize(doe_phases, identity;  colormap=twilight_shifted, height=150)","category":"page"},{"location":"api/#Performance-Benchmark","page":"API Reference","title":"Performance Benchmark","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Hardware: NVIDIA RTX 4070 Super (12GB VRAM)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"CPU Performance (multi-threaded):","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Time: ~5 seconds (200 iterations)\nMemory: 41 MiB","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"GPU Performance:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Time: ~0.27 seconds (200 iterations)  \nGPU Memory: Minimal allocation","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Comparison with TorchOptics:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"CPU: TorchOptics ~7s vs FluxOptics ~5s (1.4× faster)\nGPU: TorchOptics ~3.5s vs FluxOptics ~0.27s (13× faster)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Scalability: The low memory footprint (41 MiB) enables optimization of much larger problems. FluxOptics can handle larger grids, multi-wavelength, and multi-mode problems that exceed GPU memory limits in other frameworks. This qualitative difference—not just speed, but problem accessibility—is the key advantage for real-world optical design.","category":"page"},{"location":"api/#GPU-Acceleration","page":"API Reference","title":"GPU Acceleration","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"To run on GPU, add these lines at the beginning:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using CUDA\nCUDA.allowscalar(false)\n\n# After creating fields\nu0 = cu(u0)\nvf = cu(vf)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"All operations will automatically run on GPU with no other code changes required.","category":"page"},{"location":"api/#Module-Overview-2","page":"API Reference","title":"Module Overview","text":"","category":"section"},{"location":"api/#Foundation-Modules","page":"API Reference","title":"Foundation Modules","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These modules provide the basic building blocks for optical field representation and manipulation.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"GridUtils creates coordinate systems for evaluating optical modes and components on spatial grids.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modes generates common optical beam profiles (Gaussian, Hermite-Gaussian, Laguerre-Gaussian) and spatial layouts for multi-mode configurations.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Fields provides the ScalarField type, the central data structure representing optical fields with associated grid information, wavelength, and propagation direction.","category":"page"},{"location":"api/#Optical-Components-2","page":"API Reference","title":"Optical Components","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The heart of FluxOptics, providing all optical elements and system composition tools.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Core defines the abstract component hierarchy, trainability system (Static/Trainable/Buffered), and bidirectional propagation interface used by all components.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Sources generate initial optical fields (e.g., ScalarSource). Sources are trainable, allowing optimization of the input beam profile.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modulators modify field amplitude and phase: Phase for pure phase modulation, Mask for amplitude/complex transmission, TeaDOE for diffractive elements with a physical thickness that satisfies the Thin Element Approximation.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Fourier provides frequency-domain operations. FourierWrapper applies components in Fourier space, while FourierPhase and FourierMask are convenient constructors for frequency-domain filtering.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"System enables optical system construction. Use the pipe operator |> to chain components: source |> phase |> lens |> propagator. Systems are callable and fully differentiable. FieldProbe captures intermediate fields for use in custom objective functions, visualizations, and debugging.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Utilities contains helper components: PadCropOperator for aliasing-free Fourier-based convolution (pad → convolve → crop), TiltAnchor for off-axis beam tracking, BasisProjectionWrapper for reduced-parameter optimization.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Free-Space Propagators implement field propagation through homogeneous media: Angular Spectrum method (ASProp), Rayleigh-Sommerfeld diffraction (RSProp), Collins integral for ABCD systems, Fourier lenses.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Bulk Propagators use Beam Propagation Method (BPM) for inhomogeneous media with spatially-varying refractive index. Supports paraxial  and non-paraxial tilted propagation.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Active Media models stationary gain and amplification with saturable gain sheets.","category":"page"},{"location":"api/#Optimization-Modules","page":"API Reference","title":"Optimization Modules","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"OptimisersExt provides optimization algorithms and proximal operators. Use make_rules for per-component learning rates, ProxRule for constrained optimization with regularization.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Metrics defines loss functions for inverse design: PowerCoupling for mode matching, SquaredFieldDifference for field shaping, SquaredIntensityDifference for intensity targets.","category":"page"},{"location":"api/gridutils/gridutils/#GridUtils-API","page":"API","title":"GridUtils API","text":"","category":"section"},{"location":"api/gridutils/gridutils/#Spatial-Vectors","page":"API","title":"Spatial Vectors","text":"","category":"section"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.spatial_vectors","page":"API","title":"FluxOptics.GridUtils.spatial_vectors","text":"spatial_vectors(ns::NTuple{Nd,Real}, ds::NTuple{Nd,Real}; offset::NTuple{Nd,Real}=ntuple(_->0, Nd))\nspatial_vectors(nx, dx; xc=0.0)\nspatial_vectors(nx, ny, dx, dy; xc=0.0, yc=0.0)\n\nGenerate spatial coordinate vectors for optical field grids.\n\nCreates coordinate arrays centered at zero with specified sampling and optional offset. Essential for defining spatial grids in optical simulations.\n\nArguments\n\nns::NTuple: Number of points in each dimension.\nds::NTuple: Spatial sampling interval in each dimension (user-defined unit).\noffset::NTuple=ntuple(_->0, Nd): Offset of the zero position from the center of the grid, for each dimension. The center of the grid is then -offset.\n\nReturns\n\nTuple of coordinate vectors, one per spatial dimension. Each coordinate vector is an AbstractRange.\n\nExamples\n\n# 1D case\njulia> x, = spatial_vectors(4, 1.0);\n\njulia> isa(x, AbstractRange)\ntrue\n\njulia> collect(x)\n4-element Vector{Float64}:\n -1.5\n -0.5\n  0.5\n  1.5\n\njulia> x, y = spatial_vectors(4, 4, 1.0, 1.0; xc=2.0); # 2D case with offset\n\njulia> collect(x)\n4-element Vector{Float64}:\n -3.5\n -2.5\n -1.5\n -0.5\n\nSee also: Shift2D, Rot2D\n\n\n\n\n\n","category":"function"},{"location":"api/gridutils/gridutils/#2D-Transformations","page":"API","title":"2D Transformations","text":"","category":"section"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.Shift2D","page":"API","title":"FluxOptics.GridUtils.Shift2D","text":"Shift2D(x::Real, y::Real)\n\nCreate a 2D translation transformation.\n\nRepresents a spatial translation by (x, y) in micrometers. Can be composed  with other transformations using the ∘ operator.\n\nArguments\n\nx::Real: Translation in x direction.\ny::Real: Translation in y direction.\n\nExamples\n\njulia> t = Shift2D(2.0, 3.0);\n\njulia> t([1.0, 1.0])  # Apply transformation\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 3.0\n 4.0\n\njulia> combined = Shift2D(1.0, 0.0) ∘ Rot2D(π/4); # Composition with rotation\n\njulia> combined([1.0, 0.0])  # Rotate then translate\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.7071067811865475\n 0.7071067811865475\n\nSee also: Rot2D, Id2D\n\n\n\n\n\n","category":"type"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.Rot2D","page":"API","title":"FluxOptics.GridUtils.Rot2D","text":"Rot2D(θ::Real)\n\nCreate a 2D rotation transformation.\n\nRepresents a rotation by angle θ (in radians) around the origin.  Can be composed with other transformations using the ∘ operator.\n\nArguments\n\nθ::Real: Rotation angle in radians (positive = counterclockwise).\n\nExamples\n\njulia> r = Rot2D(π/2);  # 90° rotation\n\njulia> r([1.0, 0.0])  # Rotate point\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 6.123233995736766e-17\n 1.0\n\njulia> transform = Rot2D(π/4) ∘ Shift2D(2.0, 0.0); # Composition: translate then rotate\n\njulia> transform([0.0, 0.0])\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.4142135623730951\n 1.414213562373095\n\nSee also: Shift2D, Id2D\n\n\n\n\n\n","category":"type"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.Id2D","page":"API","title":"FluxOptics.GridUtils.Id2D","text":"Id2D()\n\nCreate a 2D identity transformation.\n\nRepresents the identity transformation that leaves coordinates unchanged. Useful as a default value in functions that accept coordinate transformations, or for composing transformation chains where no transformation is needed.\n\nExamples\n\njulia> t = Id2D();\n\njulia> t([1.0, 2.0])  # Apply identity transformation\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 2.0\n\njulia> # Composition with other transformations\n\njulia> combined = Shift2D(1.0, 0.0) ∘ Id2D();\n\njulia> combined([0.0, 0.0])  # Behaves like Shift2D(1.0, 0.0)\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 0.0\n\nSee also: Shift2D, Rot2D\n\n\n\n\n\n","category":"type"},{"location":"api/gridutils/gridutils/#Notes","page":"API","title":"Notes","text":"","category":"section"},{"location":"api/gridutils/gridutils/","page":"API","title":"API","text":"All spatial units should be consistent (typically micrometers)\nRotations are counterclockwise for positive angles\nTransformations compose right-to-left: (f ∘ g)(x) = f(g(x))\nOffsets shift the zero position from grid center","category":"page"},{"location":"api/optical_components/freespace/#Free-Space-Propagators","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"","category":"section"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"Field propagation methods for homogeneous media.","category":"page"},{"location":"api/optical_components/freespace/#Overview","page":"Free-Space Propagators","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"The Free-Space Propagators module provides:","category":"page"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"Angular Spectrum method for general propagation\nRayleigh-Sommerfeld diffraction for short distances\nCollins integral (ABCD) for paraxial systems with magnification\nFourier lenses for ideal optical Fourier transforms\nGeometric shifts without diffraction effects","category":"page"},{"location":"api/optical_components/freespace/#Examples","page":"Free-Space Propagators","title":"Examples","text":"","category":"section"},{"location":"api/optical_components/freespace/#Angular-Spectrum","page":"Free-Space Propagators","title":"Angular Spectrum","text":"","category":"section"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"using FluxOptics, CairoMakie\n\n# Create Gaussian beam\nxv, yv = spatial_vectors(256, 256, 2.0, 2.0)\nu = ScalarField(Gaussian(75.0, 50.0)(xv, yv), (2.0, 2.0), 1.064)\n\n# Basic propagation\nprop = ASProp(u, 12000.0)\nu_out = propagate(u, prop, Forward)\n\n# Compare beams before and after propagation\nvisualize((u, u_out), (intensity, phase); colormap=(:inferno, :viridis), height=120)","category":"page"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"# Propagation in different medium\nprop_glass = ASProp(u, 12000.0; n0=1.5)\nu_glass = propagate(u, prop_glass, Forward)\n\n# With spatial filter\nfilter_lp = (fx, fy) -> sqrt(fx^2 + fy^2) < 0.008 ? 1.0 : 0.0\nprop_filtered = ASProp(u, 12000.0; filter=filter_lp)\nu_filtered = propagate(u, prop_filtered, Forward)\n\n# Compare peak intensities\nvisualize((u_glass, u_filtered), (intensity, phase);\n\tcolormap=(:inferno, :viridis), height=120)","category":"page"},{"location":"api/optical_components/freespace/#Rayleigh-Sommerfeld","page":"Free-Space Propagators","title":"Rayleigh-Sommerfeld","text":"","category":"section"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"using FluxOptics, CairoMakie\n\n# Create Gaussian beam\nxv, yv = spatial_vectors(256, 256, 2.0, 2.0)\nu = ScalarField(Gaussian(75.0, 50.0)(xv, yv), (2.0, 2.0), 1.064)\n\nas_prop = ASProp(u, 50000.0)\nrs_prop = RSProp(u, 50000.0)\n\nu_as = propagate(u, as_prop, Forward)\nu_rs = propagate(u, rs_prop, Forward)\n\n# Compare beams propagated with AS and RS\nvisualize((u_as, u_rs), (intensity, phase); colormap=(:inferno, :viridis), height=120)","category":"page"},{"location":"api/optical_components/freespace/#ABCD-Systems-and-Fourier-Lenses","page":"Free-Space Propagators","title":"ABCD Systems and Fourier Lenses","text":"","category":"section"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"using FluxOptics, CairoMakie\n\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\nu = ScalarField(Gaussian(20.0)(xv, yv), (1.0, 1.0), 1.064)\n\n# Telescope comparison: Two approaches\nf1, f2 = 100.0, 200.0  # Magnification = f2/f1 = 2\n\n# Approach 1: Using FourierLens components\nsource = ScalarSource(u)\nlens1 = FourierLens(u, (0.1, 0.1), f1)  # Magnification of the intermediate grid\nlens2 = FourierLens(u, (0.1, 0.1), (1.5, 1.5), f2)  # Magnification of the output grid\ntelescope_fourier = source |> lens1 |> lens2\n\n# Approach 2: Using ABCD matrix formulation\n# Define matrices\nM_prop1 = [1 f1; 0 1]           # Propagation to lens1\nM_lens1 = [1 0; -1/f1 1]        # First lens\nd = f1 + f2                     # Telescope spacing\nM_prop12 = [1 d; 0 1]           # Propagation from lens1 to lens2\nM_lens2 = [1 0; -1/f2 1]        # Second lens\nM_prop2 = [1 5000; 0 1]         # Auxiliary last propagation to avoid B = 0\n\n# Composite ABCD matrix for telescope\nM = M_prop2 * M_lens2 * M_prop12 * M_lens1 * M_prop1\n\n# Use CollinsProp\ncollins = CollinsProp(u, (1.5, 1.5), (M[1,1], M[1,2], M[2,2]))\ntelescope_abcd = source |> collins |>\n\tASProp(u, (1.5, 1.5), f2-5000)  # Correct last propagation\n\n# Execute both systems\nu_out1 = telescope_fourier().out\nu_out2 = telescope_abcd().out\n\nvisualize((u, -u_out1, -im*u_out2), (intensity, phase);\n    colormap=(:inferno, :viridis), height=120)","category":"page"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"coupling_efficiency(u_out1, u_out2)","category":"page"},{"location":"api/optical_components/freespace/#Key-Types","page":"Free-Space Propagators","title":"Key Types","text":"","category":"section"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"ASProp: Angular Spectrum propagation (static)\nASPropZ: Angular Spectrum with trainable distance\nRSProp: Rayleigh-Sommerfeld diffraction\nCollinsProp: ABCD matrix propagation with resampling\nFourierLens: Ideal Fourier lens\nParaxialProp: Paraxial propagation (convenience wrapper)\nShiftProp: Geometric shift (no diffraction)","category":"page"},{"location":"api/optical_components/freespace/#Method-Selection","page":"Free-Space Propagators","title":"Method Selection","text":"","category":"section"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"Angular Spectrum (ASProp): General-purpose, handles both paraxial and non-paraxial regimes. Default choice for most applications.","category":"page"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"Rayleigh-Sommerfeld (RSProp): Prevents aliasing for large propagation distances but requires finer sampling for short distances.","category":"page"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"Collins Integral (CollinsProp, FourierLens): ABCD systems with grid magnification. Essential for Fourier optics and imaging systems. Works only when B ≠ 0.","category":"page"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"Paraxial (ParaxialProp): Convenience wrapper that selects ASProp or CollinsProp based on whether magnification is needed.","category":"page"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"Geometric (ShiftProp): Pure geometric shift, no diffraction. Useful for tomography phase projection comparisons.","category":"page"},{"location":"api/optical_components/freespace/#See-Also","page":"Free-Space Propagators","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"Bulk Propagators for inhomogeneous media\nCore for trainability system","category":"page"},{"location":"api/optical_components/freespace/#Index","page":"Free-Space Propagators","title":"Index","text":"","category":"section"},{"location":"api/optical_components/freespace/","page":"Free-Space Propagators","title":"Free-Space Propagators","text":"Modules = [FluxOptics.OpticalComponents]\nPages = [\"freespace.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/optical_components/sources/#Sources","page":"Sources","title":"Sources","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"Optical field sources for system initialization.","category":"page"},{"location":"api/optical_components/sources/#Overview","page":"Sources","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"The Sources module provides components that generate optical fields to initialize optical systems. Sources can be static (fixed beam profile) or trainable (optimizable during inverse design).","category":"page"},{"location":"api/optical_components/sources/#Examples","page":"Sources","title":"Examples","text":"","category":"section"},{"location":"api/optical_components/sources/#Creating-Sources","page":"Sources","title":"Creating Sources","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"using FluxOptics\n\n# Create spatial grid and mode\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\ngaussian = Gaussian(20.0)\nu0 = ScalarField(gaussian(xv, yv), (2.0, 2.0), 1.064)\n\n# Static source (fixed beam profile)\nsource_static = ScalarSource(u0)\n\nistrainable(source_static)  # false","category":"page"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"# Trainable source (optimizable)\nsource_train = ScalarSource(u0; trainable=true, buffered=true)\n\n(istrainable(source_train), isbuffered(source_train))","category":"page"},{"location":"api/optical_components/sources/#Using-Sources-in-Systems","page":"Sources","title":"Using Sources in Systems","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"# Generate field from source\nu_generated = propagate(source_static)\n\nsize(u_generated)  # Same as template","category":"page"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"# Build system with trainable source\nphase_mask = Phase(u0, (x, y) -> 0.01*(x^2 + y^2))\npropagator = ASProp(u0, 500.0)\n\nsystem = source_train |> phase_mask |> propagator\n\n# Execute system\nresult = system()\noutput = result.out\n\npower(output)[]  # Propagated through system","category":"page"},{"location":"api/optical_components/sources/#Accessing-Source-Data","page":"Sources","title":"Accessing Source Data","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"# Extract current source field\ncurrent_field = get_source(source_train)\n\n# Access trainable parameters (for optimization)\nparams = trainable(source_train)\n\nkeys(params)","category":"page"},{"location":"api/optical_components/sources/#Key-Types","page":"Sources","title":"Key Types","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"ScalarSource: Source from scalar field template","category":"page"},{"location":"api/optical_components/sources/#Key-Functions","page":"Sources","title":"Key Functions","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"get_source: Access source field data\npropagate: Generate field from source","category":"page"},{"location":"api/optical_components/sources/#Usage-Patterns","page":"Sources","title":"Usage Patterns","text":"","category":"section"},{"location":"api/optical_components/sources/#Static-Sources","page":"Sources","title":"Static Sources","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"Use for fixed, known beam profiles:","category":"page"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"source = ScalarSource(u0)  # trainable=false by default","category":"page"},{"location":"api/optical_components/sources/#Trainable-Sources","page":"Sources","title":"Trainable Sources","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"Enable optimization of source amplitude and phase during inverse design:","category":"page"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"source = ScalarSource(u0; trainable=true, buffered=true)\n# ... optimization updates source field ...\noptimized_beam = get_source(source)","category":"page"},{"location":"api/optical_components/sources/#Multi-Mode-Sources","page":"Sources","title":"Multi-Mode Sources","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"Sources support multi-mode fields:","category":"page"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"# Create multi-mode field\nmodes = hermite_gaussian_groups(15.0, 3)\nmode_data = stack([m(xv, yv) for m in modes], dims=3)\nu_multi = ScalarField(mode_data, (2.0, 2.0), 1.064)\n\nsource_multi = ScalarSource(u_multi; trainable=true)","category":"page"},{"location":"api/optical_components/sources/#See-Also","page":"Sources","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"Typical Workflow - Complete optimization example\nModes - Generating beam profiles\nFields - ScalarField operations\nSystem - Building optical systems","category":"page"},{"location":"api/optical_components/sources/#Index","page":"Sources","title":"Index","text":"","category":"section"},{"location":"api/optical_components/sources/","page":"Sources","title":"Sources","text":"Modules = [FluxOptics.OpticalComponents]\nPages = [\"sources.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/optical_components/#Optical-Components","page":"Optical Components","title":"Optical Components","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Building blocks for optical systems and propagation.","category":"page"},{"location":"api/optical_components/#Overview","page":"Optical Components","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"The Optical Components module provides all the building blocks needed to construct, propagate, and optimize optical systems. From abstract component interfaces to concrete propagators, modulators, and system composition tools.","category":"page"},{"location":"api/optical_components/#Module-Organization","page":"Optical Components","title":"Module Organization","text":"","category":"section"},{"location":"api/optical_components/#[Core](core/index.md)-Foundation","page":"Optical Components","title":"Core - Foundation","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Abstract types, trainability system, and propagation interface.","category":"page"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Component hierarchy (Sources vs Pipes, Pure vs Custom)\nTrainability (Static, Trainable, Buffered)\nBidirectional propagation (Forward/Backward)","category":"page"},{"location":"api/optical_components/#[Sources](sources/index.md)-Field-Generation","page":"Optical Components","title":"Sources - Field Generation","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Components that generate optical fields.","category":"page"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"ScalarSource: Field generation with optional trainability","category":"page"},{"location":"api/optical_components/#[Modulators](modulators/index.md)-Phase-and-Amplitude","page":"Optical Components","title":"Modulators - Phase and Amplitude","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Components that modify field amplitude and phase.","category":"page"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Phase: Pure phase modulation\nMask: Amplitude/complex transmission\nTeaDOE, TeaReflector: Diffractive optical elements","category":"page"},{"location":"api/optical_components/#[Fourier](fourier/index.md)-Frequency-Domain","page":"Optical Components","title":"Fourier - Frequency Domain","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Operations in Fourier space.","category":"page"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"FourierWrapper: Apply components in frequency domain\nFourierPhase, FourierMask: Frequency-domain modulation\nFourierOperator: FFT/IFFT transformations","category":"page"},{"location":"api/optical_components/#[Free-Space-Propagators](freespace/index.md)-Homogeneous-Media","page":"Optical Components","title":"Free-Space Propagators - Homogeneous Media","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Field propagation through uniform media.","category":"page"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"ASProp, ASPropZ: Angular Spectrum method\nRSProp: Rayleigh-Sommerfeld diffraction\nCollinsProp, FourierLens: ABCD systems and Fourier optics\nParaxialProp: Paraxial propagation\nShiftProp: Geometric shift (ray optics)","category":"page"},{"location":"api/optical_components/#[Bulk-Propagators](bulk/index.md)-Inhomogeneous-Media","page":"Optical Components","title":"Bulk Propagators - Inhomogeneous Media","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Beam Propagation Method for varying refractive index.","category":"page"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"AS_BPM: Split-step with Angular Spectrum\nShift_BPM: Split-step with geometric shifts","category":"page"},{"location":"api/optical_components/#[Active-Media](active/index.md)-Gain-and-Amplification","page":"Optical Components","title":"Active Media - Gain and Amplification","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Components with optical gain.","category":"page"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"GainSheet: Saturable gain medium","category":"page"},{"location":"api/optical_components/#[Utilities](utilities/index.md)-Helper-Components","page":"Optical Components","title":"Utilities - Helper Components","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Specialized tools for field manipulation and optimization.","category":"page"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"PadCropOperator: Memory-efficient propagation\nTiltAnchor: Off-axis beam tracking\nBasisProjectionWrapper: Reduced-parameter optimization","category":"page"},{"location":"api/optical_components/#[System](system/index.md)-Composition","page":"Optical Components","title":"System - Composition","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Tools for building complete optical systems.","category":"page"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"OpticalSystem: Complete system with source\nOpticalSequence: Component sequence\nFieldProbe: Intermediate field capture\nPipe operator |> for intuitive construction","category":"page"},{"location":"api/optical_components/#See-Also","page":"Optical Components","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/","page":"Optical Components","title":"Optical Components","text":"Quick Example - Basic system construction with vortex phase mask\nTypical Workflow - Complete example of building and optimizing an optical system\nFields for ScalarField operations\nModes for beam generation\nOptimisersExt for optimization\nMetrics for loss functions","category":"page"},{"location":"api/fields/fields/#Fields-API","page":"API","title":"Fields API","text":"","category":"section"},{"location":"api/fields/fields/#ScalarField-Type","page":"API","title":"ScalarField Type","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.ScalarField","page":"API","title":"FluxOptics.Fields.ScalarField","text":"ScalarField(data::AbstractArray{Complex}, ds::NTuple{Nd,Real}, lambdas; tilts=ntuple(_->0, Nd))\nScalarField(nd::NTuple, ds::NTuple{Nd,Real}, lambdas; tilts=ntuple(_->0, Nd))\n\nRepresent a scalar optical field with spatial grid information, wavelength(s), and optional tilt angles.\n\nThis is the central data structure of FluxOptics.jl for storing and manipulating scalar optical fields. The field data can be multi-dimensional with 1 or 2 transverse dimensions and additional dimensions for  different spatial modes. Each mode can hold independent wavelength and tilt information.\n\nConstructors\n\nFrom existing data:\n\ndata::AbstractArray{Complex}: Complex field amplitude data.\nds::NTuple{Nd,Real}: Spatial sampling intervals (dx,[dy]) in micrometers (or meters as long as consistent units are used everywhere).\nlambdas: Wavelength(s) - can be a scalar Real or AbstractArray{Real} for multiple wavelengths. In case of AbstractArray{Real}, it must be broadcastable on the extra dimensions of data (all dimensions except the spatial ones).\ntilts::NTuple{Nd}=ntuple(_->0, Nd): Tilt angles in radians corresponding to a Fourier offset of fx₀ = sin(θx)/λ, fy₀ = sin(θy)/λ. Array arguments to NTuple are accepted as long as they broadcast with the extra non-spatial dimensions of data.\n\nZero-initialized field (convenience):\n\nnd::NTuple: Dimensions of the data array (nx, [ny,] ...).\nOther arguments same as above.\n\nExamples\n\nCreating from existing data:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = rand(ComplexF64, 4, 4);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> size(u)\n(4, 4)\n\nCreating zero-initialized field:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField((4, 4), (1.0, 1.0), 1.064);\n\njulia> size(u)\n(4, 4)\n\nMulti-wavelength field:\n\njulia> wavelengths = [0.8, 1.064, 1.550];\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = zeros(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), wavelengths);\n\nField with initial tilt:\n\njulia> wavelengths = [0.8, 1.064, 1.55];\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = zeros(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064; tilts=(0.01, 0.005));\n\njulia> v = ScalarField(data, (1.0, 1.0), 1.064; tilts=([0.01, 0.02, 0.03], 0));\n\nSee also: set_field_data, power, normalize_power!\n\n\n\n\n\n","category":"type"},{"location":"api/fields/fields/#Field-Data-Management","page":"API","title":"Field Data Management","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.set_field_data","page":"API","title":"FluxOptics.Fields.set_field_data","text":"set_field_data(u::ScalarField, data::AbstractArray)\n\nCreate a new ScalarField with updated field data, preserving all other parameters.\n\nThis function creates a copy with new amplitude data while keeping the same spatial grid, wavelengths, and tilt information.\n\nArguments\n\nu::ScalarField: Original field.\ndata::AbstractArray: New complex field data.\n\nReturns\n\nNew ScalarField with updated data.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> new_data = rand(ComplexF64, 4, 4);\n\njulia> u_new = set_field_data(u, new_data);\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#Base.similar-Tuple{ScalarField}","page":"API","title":"Base.similar","text":"similar(u::ScalarField)\n\nCreate a new ScalarField with same parameters but uninitialized data.\n\nUseful for creating temporary fields with the same grid, wavelength and tilt structures as an existing field.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> u_tmp = similar(u);  # Same grid/wavelengths/tilts, but data is uninitialized\n\nSee also: copy, set_field_data\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.copy-Tuple{ScalarField}","page":"API","title":"Base.copy","text":"copy(u::ScalarField)\n\nCreate a copy of the scalar field.\n\nCreates a copy of the field data, while sharing the internal representation of other parameters.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> u_copy = copy(u);\n\njulia> # Modifying u_copy.electric will not affect u, but the internal arrays representing\n\njulia> # the wavelengths or tilts must never be modified.\n\nSee also: similar\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.fill!-Tuple{ScalarField, Number}","page":"API","title":"Base.fill!","text":"fill!(u::ScalarField, v) -> ScalarField\n\nFill the electric field with value v in-place.\n\nArguments\n\nu::ScalarField: Field to modify.\nv: Fill value, either a scalar (fills entire field) or array (copied into field).\n\nReturns\n\nModified ScalarField (same as input).\n\nExamples\n\njulia> u = ScalarField((4, 4), (1.0, 1.0), 1.064);\n\njulia> fill!(u, 1.0 + 0.0im);  # Fill with constant\n\njulia> fill!(u, rand(ComplexF64, 4, 4));  # Fill with array\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.copyto!-Tuple{ScalarField, ScalarField}","page":"API","title":"Base.copyto!","text":"copyto!(u::ScalarField, v::ScalarField) -> ScalarField\n\nCopy data from v into u. Modifies u in-place and returns it.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.collect-Tuple{ScalarField}","page":"API","title":"Base.collect","text":"collect(u::ScalarField) -> Array\n\nConvert field data to a regular CPU array. Returns an Array (not a ScalarField).\n\nUseful for converting GPU arrays (e.g., CuArray) to CPU for analysis, plotting, or saving.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> data = collect(u);  # Returns Array, not ScalarField\n\njulia> typeof(data)\nMatrix{ComplexF64} (alias for Array{Complex{Float64}, 2})\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Field-Properties","page":"API","title":"Field Properties","text":"","category":"section"},{"location":"api/fields/fields/#Base.size-Tuple{ScalarField}","page":"API","title":"Base.size","text":"size(u::ScalarField) -> Tuple\nsize(u::ScalarField, k::Integer) -> Int\n\nReturn the size of the electric field array.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.ndims-Tuple{ScalarField}","page":"API","title":"Base.ndims","text":"ndims(u::ScalarField, spatial::Bool=false) -> Int\n\nReturn number of dimensions. If spatial=true, returns only spatial dimensions (Nd), otherwise returns total dimensions of the electric field array.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.eltype-Tuple{ScalarField}","page":"API","title":"Base.eltype","text":"eltype(u::ScalarField) -> Type\n\nReturn the element type of the electric field.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Tilt-Management","page":"API","title":"Tilt Management","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.set_field_tilts","page":"API","title":"FluxOptics.Fields.set_field_tilts","text":"set_field_tilts(u::ScalarField, tilts) -> ScalarField\n\nCreate a new ScalarField with updated tilts, preserving all other parameters.\n\nThis function creates a copy with new tilt values while keeping the same field data, spatial grid, and wavelengths.\n\nArguments\n\nu::ScalarField: Original field.\ntilts: New tilt values as (θx, θy) tuple, where each component can be scalar or array.\n\nReturns\n\nNew ScalarField with updated tilts.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064; tilts=(0.01, 0.0));\n\njulia> u_tilted = set_field_tilts(u, (0.02, 0.01));\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.offset_tilts!","page":"API","title":"FluxOptics.Fields.offset_tilts!","text":"offset_tilts!(u::ScalarField, tilts)\n\nAdd offset to existing tilts and apply corresponding linear phase to the field in-place.\n\nThis function modifies both the tilt metadata and the electric field by:\n\nAdding the offset to the stored tilt values\nMultiplying the field by exp(i 2π/λ (Δθx⋅x + Δθy⋅y)) to maintain consistency\n\nThis shifts the reference frame without rotating the angular spectrum.\n\nArguments\n\nu::ScalarField: Field to modify.\ntilts: Tilt offsets as (Δθx, Δθy) tuple in radians.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064; tilts=(0.01, 0.0));\n\njulia> offset_tilts!(u, (0.005, 0.005));\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.is_on_axis","page":"API","title":"FluxOptics.Fields.is_on_axis","text":"is_on_axis(u::ScalarField) -> Bool\n\nCheck if the field has zero tilts (on-axis propagation).\n\nReturns true if all tilt components are zero, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#Power-and-Intensity","page":"API","title":"Power and Intensity","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.power","page":"API","title":"FluxOptics.Fields.power","text":"power(u::ScalarField)\n\nCompute the optical power of the field.\n\nCalculates the spatial integral of the intensity |u|² over the field domain, properly accounting for the spatial sampling.\n\nMathematical definition\n\nP = ∫∫ |u(x,y)|² dx dy ≈ Σᵢⱼ |u[i,j]|² × dx × dy.\n\nReturns\n\nArray of power value(s) with same dimensions as u, spatial dimensions being reduced to size 1.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = rand(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> P = power(u);  # Returns 1×1×3 Array\n\nSee also: normalize_power!\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.normalize_power!","page":"API","title":"FluxOptics.Fields.normalize_power!","text":"normalize_power!(u::ScalarField, target_power=1)\n\nNormalize the field to have specified optical power (in-place modification).\n\nScales the field amplitudes so that the total optical power equals the target values. This is useful for setting consistent power levels between different fields.\n\nArguments\n\nu::ScalarField: Field to normalize (modified in-place)\ntarget_power=1: Target power value(s) - can be a scalar Real or AbstractArray{Real} as long as it can be broadcasted on the field data.\n\nReturns\n\nThe modified field u\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(rand(ComplexF64, 4, 4, 3), (1.0, 1.0), 1.064);\n\njulia> normalize_power!(u);        # Normalize all fields to 1 W\n\njulia> normalize_power!(u, 1e-3);  # Normalize all fields to 1 mW\n\njulia> all(x -> isapprox(x, 1e-3), power(u))\ntrue\n\njulia> # For multiple fields: normalize each field separately\n\njulia> power_values = reshape([1e-3, 2e-3, 3e-3], 1, 1, 3);\n\njulia> normalize_power!(u, power_values);  # Different power per field\n\njulia> isapprox(power(u), power_values)\ntrue\n\nSee also: power\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.intensity","page":"API","title":"FluxOptics.Fields.intensity","text":"intensity(u::AbstractArray, nd::Integer=2)\nintensity(u::ScalarField)\n\nCompute the total intensity |u|² of optical fields or arrays.\n\nCalculates intensity by summing |u|² over all extra dimensions beyond the spatial ones, returning the combined intensity distribution for the spatial dimensions only.\n\nArguments\n\nu::AbstractArray: Array of complex values.\nnd::Integer=2: Number of spatial dimensions (for AbstractArray case only).\nu::ScalarField: Optical field with potentially multiple modes.\n\nMathematical definition\n\nI[i,j] = Σₖ |u[i,j,k]|² where k runs over all extra dimensions\n\nReturns\n\nAbstractArray: Array with spatial dimensions only, extra dims summed.\nScalarField: Array with spatial dimensions only, containing total intensity.\n\nExamples\n\nAbstractArray case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = ones(ComplexF64, 4, 4, 3);  # 2 spatial + 1 extra dim\n\njulia> I = intensity(data, 2);  # Sum over 3rd dimension\n\njulia> size(I)\n(4, 4)\n\njulia> I[1,1]\n3.0\n\nScalarField case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = ones(ComplexF64, 4, 4, 3);  # 3 modes\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> I = intensity(u);  # Returns 4×4 array (total intensity of all 3 modes)\n\njulia> size(I)\n(4, 4)\n\njulia> I[1,1]\n3.0\n\nSee also: power, phase\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.phase","page":"API","title":"FluxOptics.Fields.phase","text":"phase(u::AbstractArray)\nphase(u::ScalarField)\n\nCompute the phase angle of complex arrays or optical fields.\n\nReturns the argument (angle) of complex values in radians, preserving array structure. For optical fields, this gives the wavefront phase information across all modes.\n\nArguments\n\nu::AbstractArray: Array of complex values.\nu::ScalarField: Optical field (uses underlying data array).\n\nMathematical definition\n\nφ = arg(u) = atan(imag(u), real(u))\n\nReturns\n\nAbstractArray: Array of same dimensions containing phase values in radians [-π, π].\nScalarField: Calls phase(u.electric), returns array with phase values.\n\nExamples\n\nAbstractArray case:\n\njulia> data = [1.0+0.0im, 0.0+1.0im, -1.0+0.0im];\n\njulia> phase(data)\n3-element Vector{Float64}:\n 0.0\n 1.5707963267948966\n 3.141592653589793\n\nScalarField case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = [1.0+0.0im 0.0+1.0im; -1.0+0.0im 0.0-1.0im];\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> phase(u)\n2×2 Matrix{Float64}:\n 0.0       1.5708\n 3.14159  -1.5708\n\nSee also: intensity, phase\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#Field-Comparison","page":"API","title":"Field Comparison","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.coupling_efficiency","page":"API","title":"FluxOptics.Fields.coupling_efficiency","text":"coupling_efficiency(u, v)\ncoupling_efficiency(u::ScalarField, v::ScalarField)\n\nCompute the power coupling efficiency between two optical fields.\n\nFor multi-dimensional fields, computes power coupling efficiency between corresponding field distributions (same extra dimension indices). This normalized metric returns values between 0 and 1, representing the fraction of power that would be transferred from field u to field v.\n\nMathematical definition\n\nη = |⟨u,v⟩|² / (‖u‖ ‖v‖)\n\nArguments\n\nu: First field (ScalarField or AbstractArray).\nv: Second field with same spatial dimensions as u.\n\nReturns\n\nFor AbstractArrays: Scalar coupling efficiency [0,1].\nFor ScalarFields: Array of coupling efficiencies, one for each field distribution.\n\nExamples\n\nArray case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ones(ComplexF64, 4, 4);\n\njulia> v = ones(ComplexF64, 4, 4);\n\njulia> coupling_efficiency(u, v)\n1.0\n\nScalarField single-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = ones(ComplexF64, 4, 4);\n\njulia> field2_data = ones(ComplexF64, 4, 4);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> coupling_efficiency(u, v)\n1-element Vector{Float64}:\n 1.0\n\nScalarField multi-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = ones(ComplexF64, 4, 4, 3);\n\njulia> field2_data = ones(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> coupling_efficiency(u, v)\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\nSee also: power\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#LinearAlgebra.dot-Tuple{ScalarField}","page":"API","title":"LinearAlgebra.dot","text":"dot(u::ScalarField, v::ScalarField)\n\nCompute the inner product ⟨u,v⟩ between two optical fields.\n\nFor multi-dimensional fields, computes the dot product between corresponding field distributions (same extra dimension indices).\n\nMathematical definition\n\n⟨u,v⟩ = ∫∫ u(x,y) v(x,y) dx dy ≈ Σᵢⱼ u[i,j] v[i,j]\n\nArguments\n\nu::ScalarField: First field.\nv::ScalarField: Second field with same spatial dimensions as u.\n\nReturns\n\nVector of complex inner products, one for each field distribution.\n\nExamples\n\nSingle-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = rand(ComplexF64, 4, 4);\n\njulia> field2_data = rand(ComplexF64, 4, 4);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> overlap = dot(u, v);  # 0-dimensional Array storing the complex overlap integral\n\nMulti-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = rand(ComplexF64, 4, 4, 3);\n\njulia> field2_data = rand(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> overlaps = dot(u, v);  # 3-element Vector of complex overlaps\n\nSee also: coupling_efficiency, dot, power\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Vectorization","page":"API","title":"Vectorization","text":"","category":"section"},{"location":"api/fields/fields/#Base.vec-Tuple{ScalarField}","page":"API","title":"Base.vec","text":"vec(u::AbstractArray, nd::Integer=2)\nvec(u::ScalarField)\n\nConvert multi-dimensional arrays or fields into vector of slices.\n\nFor AbstractArray, splits along dimensions beyond the first nd spatial dimensions. For ScalarField, converts into vector of individual ScalarField objects, each representing a single slice along non-spatial dimensions. Useful for iteration and visualization.\n\nArguments\n\nu: Array or ScalarField to vectorize.\nnd::Integer: Number of spatial dimensions (for AbstractArray case only).\n\nReturns\n\nFor AbstractArray: Vector of array slices along non-spatial dimensions.\nFor ScalarField: Vector of ScalarField objects, one per slice along non-spatial dimensions.\n\nExamples\n\nAbstractArray case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = ones(4, 4, 3);  # 2 spatial dims + 1 extra\n\njulia> slices = vec(data, 2);  # Split after 2 spatial dimensions\n\njulia> length(slices)\n3\n\njulia> size(slices[1])\n(4, 4)\n\nScalarField case:\n\njulia> wavelengths = [0.8, 1.064, 1.550];\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = zeros(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), wavelengths);\n\njulia> u_vec = vec(u);  # Returns Vector{ScalarField} of length 3\n\njulia> length(u_vec)\n3\n\njulia> (u_vec[1].lambdas.val, u_vec[2].lambdas.val, u_vec[3].lambdas.val)\n(0.8, 1.064, 1.55)\n\nSee also: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Broadcasting-and-Indexing","page":"API","title":"Broadcasting and Indexing","text":"","category":"section"},{"location":"api/fields/fields/#Base.Broadcast.broadcasted-Tuple{Function, ScalarField}","page":"API","title":"Base.Broadcast.broadcasted","text":"broadcasted(f::Function, u::ScalarField) -> ScalarField\n\nApply function f element-wise to the electric field. Returns a new ScalarField with transformed data.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.getindex-Tuple{ScalarField, Any}","page":"API","title":"Base.getindex","text":"getindex(u::ScalarField, i...)\n\nAccess elements of the electric field. Returns a view into the field data.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.conj-Tuple{ScalarField}","page":"API","title":"Base.conj","text":"conj(u::ScalarField) -> ScalarField\n\nReturn complex conjugate of the field. Creates a new field with conjugated electric field values.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/fields/fields/#Data-Layout","page":"API","title":"Data Layout","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"First Nd dimensions: spatial (x, y for 2D)\nRemaining dimensions: modes, wavelengths, etc.\nContiguous in memory for performance","category":"page"},{"location":"api/fields/fields/#Wavelength-Handling","page":"API","title":"Wavelength Handling","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Single wavelength: stored as scalar, broadcast to field\nMultiple wavelengths: array broadcasts with extra (non-spatial) dimensions","category":"page"},{"location":"api/fields/fields/#Tilt-Handling","page":"API","title":"Tilt Handling","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Tilts are passed as (θx, θy) tuples (scalars or arrays) to the constructor\nInternally stored as tuple of arrays for in-place modification\nEach tilt component broadcasts with extra (non-spatial) dimensions\nTilts represent Fourier offset: fx₀ = sin(θx)/λ","category":"page"},{"location":"api/fields/fields/#Power-Calculation","page":"API","title":"Power Calculation","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Power = ∫∫ |u(x,y)|² dx dy\nNumerical integration: P ≈ Σᵢⱼ |u[i,j]|² × dx × dy\nUnits depend on field amplitude units and spatial units","category":"page"},{"location":"api/fields/fields/#Intensity-vs-Power","page":"API","title":"Intensity vs Power","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Intensity: |u(x,y)|² (per unit area)\nPower: Spatial integral of intensity\nFor multi-mode: intensity sums over modes, power is per-mode","category":"page"},{"location":"api/fields/fields/#Coupling-Efficiency","page":"API","title":"Coupling Efficiency","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"η = |⟨u₁,u₂⟩|² / (‖u₁‖ ‖u₂‖)\nAlways real, between 0 and 1\nInsensitive to global phase\nEquals 1 for identical fields","category":"page"},{"location":"api/fields/fields/#Memory-Considerations","page":"API","title":"Memory Considerations","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"copy() creates independent copy of data\nsimilar() allocates uninitialized memory\nset_field_data() creates new field using provided data and same other parameters\nUse views for slicing without copying","category":"page"},{"location":"api/fields/fields/#Performance-Tips","page":"API","title":"Performance Tips","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Pre-allocate: Use similar() for temporary fields\nIn-place operations: Modify .electric directly when possible\nAvoid unnecessary copies: Use set_field_data() or views\nVectorization: Use vec() only when needed for iteration\nGPU: Field data can be moved to GPU with CUDA.cu(u)","category":"page"},{"location":"api/fields/fields/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Modes for generating field data\nGridUtils for coordinate systems","category":"page"},{"location":"api/modes/#Modes","page":"Modes","title":"Modes","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Optical mode generation and spatial layouts.","category":"page"},{"location":"api/modes/#Overview","page":"Modes","title":"Overview","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"The Modes module provides:","category":"page"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Gaussian beam families (Gaussian, Hermite-Gaussian, Laguerre-Gaussian)\nSpatial layouts for mode composition and multi-mode configurations\nSpeckle generation with controlled statistics and envelope\nMode stacks for multi-mode generation","category":"page"},{"location":"api/modes/#Examples","page":"Modes","title":"Examples","text":"","category":"section"},{"location":"api/modes/#Gaussian-Beams","page":"Modes","title":"Gaussian Beams","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"using FluxOptics\nusing CairoMakie\n\n# Setup coordinates\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\n\n# Gaussian propagated from focus (spherical phase front)\ng = Gaussian(25.0, 1.064, 1000.0)  # 1000 µm from waist\nfield_gauss = g(xv, yv)\n\n# Elliptical Gaussian (cylindrical phase fronts)\ng_ellip = Gaussian(20.0, 30.0, 1.064, 1000.0)\nfield_ellip = g_ellip(xv, yv)\n\n# Visualize\nvisualize((field_gauss, field_ellip), (intensity, phase); \n    colormap=(:inferno, :viridis),\n    height=120)","category":"page"},{"location":"api/modes/#Hermite-Gaussian-Gallery","page":"Modes","title":"Hermite-Gaussian Gallery","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"# Generate HG modes of different orders\nhg_modes = [\n    (HermiteGaussian(20.0, 0, 0), \"HG₀₀\"),\n    (HermiteGaussian(20.0, 1, 0), \"HG₁₀\"),\n    (HermiteGaussian(20.0, 0, 1), \"HG₀₁\"),\n    (HermiteGaussian(20.0, 2, 0), \"HG₂₀\"),\n    (HermiteGaussian(20.0, 1, 1), \"HG₁₁\"),\n    (HermiteGaussian(20.0, 0, 2), \"HG₀₂\")\n]\n\n# Create field stack\nhg_fields = [mode(xv, yv) for (mode, _) in hg_modes]\n\n# Visualize intensity patterns\nfig = Figure(size=(1200, 800))\nfor (i, (field, (_, label))) in enumerate(zip(hg_fields, hg_modes))\n    row = (i - 1) ÷ 3 + 1\n    col = (i - 1) % 3 + 1\n    ax = Axis(fig[row, col], title=label, titlesize=30, aspect=DataAspect())\n    heatmap!(ax, xv, yv, abs2.(field); colormap=:inferno)\n    hidedecorations!(ax)\nend\nfig","category":"page"},{"location":"api/modes/#Laguerre-Gaussian-Gallery","page":"Modes","title":"Laguerre-Gaussian Gallery","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"# Generate LG modes with vortex phases\nlg_modes = [\n    (LaguerreGaussian(20.0, 0, 0), \"LG₀₀\"),\n    (LaguerreGaussian(20.0, 0, 1), \"LG₀₁\"),\n    (LaguerreGaussian(20.0, 0, 2), \"LG₀₂\"),\n    (LaguerreGaussian(20.0, 1, 0), \"LG₁₀\"),\n    (LaguerreGaussian(20.0, 1, 1), \"LG₁₁\"),\n    (LaguerreGaussian(20.0, 0, -2), \"LG₀₋₂\")\n]\n\n# Create fields\nlg_fields = [mode(xv, yv) for (mode, _) in lg_modes]\n\n# Visualize intensity and phase\nfig = Figure(size=(1200, 1600))\nfor (i, (field, (_, label))) in enumerate(zip(lg_fields, lg_modes))\n    row = (i - 1) ÷ 3 + 1\n    col = (i - 1) % 3 + 1\n    \n    # Intensity\n    ax_int = Axis(fig[2*row-1, col], title=label, titlesize=30, aspect=DataAspect())\n    heatmap!(ax_int, xv, yv, abs2.(field); colormap=:inferno)\n    hidedecorations!(ax_int)\n    \n    # Phase\n    ax_phase = Axis(fig[2*row, col], aspect=DataAspect())\n    heatmap!(ax_phase, xv, yv, phase(field); colormap=:viridis)\n    hidedecorations!(ax_phase)\nend\n\n# Add row labels\nLabel(fig[1, 0], \"Intensity\", rotation=π/2, fontsize=30, tellheight=false)\nLabel(fig[2, 0], \"Phase\", rotation=π/2, fontsize=30, tellheight=false)\nLabel(fig[3, 0], \"Intensity\", rotation=π/2, fontsize=30, tellheight=false)\nLabel(fig[4, 0], \"Phase\", rotation=π/2, fontsize=30, tellheight=false)\n\nfig","category":"page"},{"location":"api/modes/#Spatial-Layouts","page":"Modes","title":"Spatial Layouts","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"# 3×3 grid of Gaussian modes\ngaussian = Gaussian(10.0)\nlayout = Modes.GridLayout(3, 3, 60.0, 60.0)\n\n# Generate mode stack\nxv_layout, yv_layout = spatial_vectors(256, 256, 1.0, 1.0)\nmode_stack = generate_mode_stack(layout, 256, 256, 1.0, 1.0, gaussian)\n\n# Visualize first mode and total intensity\nfield_first = mode_stack[:, :, 1]\nfield_total = sum(mode_stack, dims=3)[:, :, 1]\n\nvisualize(((field_first, field_total),), intensity; colormap=:inferno, height=120)","category":"page"},{"location":"api/modes/#Mode-Composition","page":"Modes","title":"Mode Composition","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"# Different modes at each grid position\nhg_mode_list = [HermiteGaussian(12.0, m, n) for m in 0:2 for n in 0:2]\nlayout_hg = Modes.GridLayout(3, 3, 60.0, 60.0)\n\nmode_stack_hg = generate_mode_stack(layout_hg, 256, 256, 1.0, 1.0, hg_mode_list)\n\n# Normalize by peak intensity for better visualization\nfor i in 1:size(mode_stack_hg, 3)\n    mode_stack_hg[:, :, i] ./= maximum(abs, mode_stack_hg[:, :, i])\nend\n\n# Visualize coherent superposition\nfield_superposition = sum(mode_stack_hg, dims=3)[:, :, 1]\n\nvisualize(field_superposition, (intensity, phase); colormap=(:inferno, :viridis), height=120)","category":"page"},{"location":"api/modes/#Speckle-Patterns","page":"Modes","title":"Speckle Patterns","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"# Generate speckle with different correlation lengths\nspeckle_fine = generate_speckle((256, 256), (1.0, 1.0), 1.064, 0.25)  # Medium-fine\nspeckle_coarse = generate_speckle((256, 256), (1.0, 1.0), 1.064, 0.05)  # Low NA\n\n# With Gaussian envelope\nenvelope = Gaussian(80.0)\nspeckle_envelope = generate_speckle((256, 256), (1.0, 1.0), 1.064, 0.2; envelope=envelope)\n\n# Visualize\nvisualize((speckle_fine, speckle_coarse, speckle_envelope), (intensity, complex);\n\tcolormap=(:inferno, :dark), height=120)","category":"page"},{"location":"api/modes/#Key-Types","page":"Modes","title":"Key Types","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Gaussian, HermiteGaussian, LaguerreGaussian: Beam modes\nPointLayout, GridLayout, TriangleLayout: Spatial arrangements\nCustomLayout: User-defined layouts","category":"page"},{"location":"api/modes/#Key-Functions","page":"Modes","title":"Key Functions","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"hermite_gaussian_groups: Generate complete mode sets\ngenerate_mode_stack: Create multi-mode field arrays\ngenerate_speckle: Random speckle patterns","category":"page"},{"location":"api/modes/#See-Also","page":"Modes","title":"See Also","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"GridUtils for coordinate transformations\nFields for using modes with ScalarField","category":"page"},{"location":"api/modes/#Index","page":"Modes","title":"Index","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Modules = [FluxOptics.Modes]\nOrder = [:type, :function]","category":"page"},{"location":"api/modes/modes/#Modes-API","page":"API","title":"Modes API","text":"","category":"section"},{"location":"api/modes/modes/#Gaussian-Beam-Modes","page":"API","title":"Gaussian Beam Modes","text":"","category":"section"},{"location":"api/modes/modes/#Gaussian-Beams","page":"API","title":"Gaussian Beams","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.Gaussian1D","page":"API","title":"FluxOptics.Modes.Gaussian1D","text":"Gaussian1D(w0::Real; norm_constant=nothing)\nGaussian1D(w0::Real, λ::Real, z::Real; constant_phase=true, norm_constant=nothing)\n\nCreate a one-dimensional Gaussian mode.\n\nThe first form creates a Gaussian at the beam waist, while the second includes propagation effects at distance z from the waist.\n\nArguments\n\nw0::Real: Beam waist radius\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\nnorm_constant=nothing: Custom normalization constant - defines the peak intensity (default uses proper Gaussian normalization)\n\nReturns\n\nGaussian1D mode that can be evaluated at spatial positions.\n\nExamples\n\njulia> g = Gaussian1D(10.0);  # 10 μm waist at focus\n\njulia> nx = 40;  # 40 points\n\njulia> dx = 4.0;  # in µm\n\njulia> x, = spatial_vectors(40, dx);\n\njulia> amplitudes = g(x);\n\njulia> isapprox(sum(abs2, amplitudes) * dx, 1)  # Normalization to 1 by default\ntrue\n\njulia> g_prop = Gaussian1D(10.0, 1.064, 1000.0);  # Propagated 1 mm\n\njulia> amplitudes_prop = g_prop(x);\n\njulia> isapprox(sum(abs2, amplitudes_prop) * dx, 1; atol=1e-5)\ntrue\n\nSee also: HermiteGaussian1D, Gaussian, HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.Gaussian","page":"API","title":"FluxOptics.Modes.Gaussian","text":"Gaussian(w0::Real; norm_constant=nothing)\nGaussian(w0x::Real, w0y::Real; norm_constant=nothing)\nGaussian(w0::Real, λ::Real, z::Real; constant_phase=true, norm_constant=nothing)\nGaussian(w0x::Real, w0y::Real, λ::Real, z::Real; constant_phase=true, norm_constant=nothing)\n\nCreate a two-dimensional Gaussian mode.\n\nArguments\n\nw0::Real: Beam waist radius for circular beam\nw0x::Real, w0y::Real: Beam waist radii in x and y directions for elliptical beam\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\nnorm_constant=nothing: Custom normalization constant - defines the peak intensity (default uses proper Gaussian normalization)\n\nReturns\n\nGaussian mode that can be evaluated at spatial coordinates.\n\nExamples\n\njulia> g = Gaussian(10.0);  # Circular beam, 50 μm waist\n\njulia> nx, ny = 64, 64;\n\njulia> dx, dy = 4.0, 4.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> field = zeros(ComplexF64, nx, ny);\n\njulia> g(field, xv, yv);  # Evaluate on grid (in-place)\n\njulia> isapprox(sum(abs2, field) * dx * dy, 1)  # Check normalization\ntrue\n\njulia> g_ellip = Gaussian(10.0, 20.0, 1.064, 1000.0);  # Elliptical beam, wavelength 1.064 µm, propagated 1 mm\n\njulia> field_ellip = g_ellip(xv, yv);  # Direct evaluation (out-of-place)\n\njulia> isapprox(sum(abs2, field_ellip) * dx * dy, 1)\ntrue\n\nSee also: HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#Hermite-Gaussian-Modes","page":"API","title":"Hermite-Gaussian Modes","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.HermiteGaussian1D","page":"API","title":"FluxOptics.Modes.HermiteGaussian1D","text":"HermiteGaussian1D(w0::Real, n::Integer)\nHermiteGaussian1D(w0::Real, n::Integer, λ::Real, z::Real; constant_phase=true)\n\nCreate a one-dimensional Hermite-Gaussian mode HG_n.\n\nArguments\n\nw0::Real: Beam waist radius\nn::Integer: Mode number (≥ 0)\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\n\nReturns\n\nHermiteGaussian1D mode that can be evaluated at spatial positions.\n\nExamples\n\njulia> hg0 = HermiteGaussian1D(20.0, 0);  # HG_0 (Gaussian)\n\njulia> hg1 = HermiteGaussian1D(20.0, 1);  # HG_1 (first excited mode)\n\njulia> nx = 64;\n\njulia> dx = 2.0;\n\njulia> x, = spatial_vectors(nx, dx);\n\njulia> field0 = hg0(x);\n\njulia> field1 = hg1(x);\n\njulia> isapprox(sum(abs2, field0) * dx, 1)  # Check normalization\ntrue\n\njulia> isapprox(sum(field0 .* conj.(field1)) * dx, 0; atol = 1e-15)  # Orthogonality check\ntrue\n\nSee also: Gaussian1D, Gaussian, HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.HermiteGaussian","page":"API","title":"FluxOptics.Modes.HermiteGaussian","text":"HermiteGaussian(w0::Real, m::Integer, n::Integer)\nHermiteGaussian(w0x::Real, w0y::Real, m::Integer, n::Integer)\nHermiteGaussian(w0::Real, m::Integer, n::Integer, λ::Real, z::Real; constant_phase=true)\nHermiteGaussian(w0x::Real, w0y::Real, m::Integer, n::Integer, λ::Real, z::Real; constant_phase=true)\n\nCreate a two-dimensional Hermite-Gaussian mode HG_{m,n}.\n\nArguments\n\nw0::Real: Beam waist radius for circular beam\nw0x::Real, w0y::Real: Beam waist radii in x and y directions\nm::Integer, n::Integer: Mode numbers in x and y directions (≥ 0)\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\n\nReturns\n\nHermiteGaussian mode that can be evaluated at spatial coordinates.\n\nExamples\n\njulia> hg00 = HermiteGaussian(10.0, 0, 0);  # Fundamental mode\n\njulia> hg10 = HermiteGaussian(10.0, 1, 0);  # First excited in x\n\njulia> hg01 = HermiteGaussian(10.0, 0, 1);  # First excited in y\n\njulia> nx, ny = 64, 64;\n\njulia> dx, dy = 2.0, 2.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> field00 = hg00(xv, yv);\n\njulia> field10 = hg10(xv, yv);\n\njulia> isapprox(sum(abs2, field00) * dx * dy, 1)  # Check normalization\ntrue\n\njulia> isapprox(sum(field00 .* conj.(field10)) * dx * dy, 0; atol = 1e-15)  # Orthogonality\ntrue\n\nSee also: Gaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.hermite_gaussian_groups","page":"API","title":"FluxOptics.Modes.hermite_gaussian_groups","text":"hermite_gaussian_groups(w0, n_groups::Int)\n\nGenerate all Hermite-Gaussian modes up to a given group number.\n\nCreates all HGₘₙ modes where m + n < n_groups, ordered by increasing total mode number. This is useful for modal decomposition and beam shaping applications.\n\nArguments\n\nw0: Beam waist radius\nn_groups::Int: Number of groups to generate\n\nReturns\n\nVector of HermiteGaussian modes.\n\nExamples\n\njulia> modes = hermite_gaussian_groups(10.0, 3);\n\njulia> length(modes)  # Modes: HG_00, HG_10, HG_01, HG_20, HG_11, HG_02\n6\n\njulia> nx, ny = 64, 64;\n\njulia> dx, dy = 2.0, 2.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> fields = [mode(xv, yv) for mode in modes];\n\njulia> all(abs(sum(abs2, field) * dx * dy - 1.0) < 1e-10 for field in fields)  # All normalized\ntrue\n\njulia> modes = hermite_gaussian_groups(10.0, 4);\n\njulia> length(modes)  # Groups 0, 1, 2, 3 give 1+2+3+4 = 10 modes\n10\n\nSee also: Gaussian, HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"function"},{"location":"api/modes/modes/#Laguerre-Gaussian-Modes","page":"API","title":"Laguerre-Gaussian Modes","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.LaguerreGaussian","page":"API","title":"FluxOptics.Modes.LaguerreGaussian","text":"LaguerreGaussian(w0::Real, p::Integer, l::Integer; kind=:vortex)\nLaguerreGaussian(w0::Real, p::Integer, l::Integer, λ::Real, z::Real; constant_phase=true, kind=:vortex)\n\nCreate a Laguerre-Gaussian mode LGₚₗ.\n\nArguments\n\nw0::Real: Beam waist radius\np::Integer: Radial mode number (≥ 0)\nl::Integer: Azimuthal mode number (any integer)\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\nkind: Mode type - :vortex (default), :even, or :odd\n:vortex: exp(ilφ) phase dependence\n:even: cos(lφ) dependence  \n:odd: sin(lφ) dependence\n\nReturns\n\nLaguerreGaussian mode that can be evaluated at spatial coordinates.\n\nExamples\n\njulia> lg00 = LaguerreGaussian(10.0, 0, 0);  # Fundamental mode (Gaussian)\n\njulia> lg01 = LaguerreGaussian(10.0, 0, 1);  # Vortex beam\n\njulia> nx, ny = 65, 65;\n\njulia> dx, dy = 2.0, 2.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> field00 = lg00(xv, yv);\n\njulia> field01 = lg01(xv, yv);\n\njulia> isapprox(sum(abs2, field00) * dx * dy, 1)  # Check normalization\ntrue\n\njulia> abs(field01[nx÷2+1, ny÷2+1]) < 1e-10  # LG_01 has zero at center (vortex)\ntrue\n\njulia> lg_even = LaguerreGaussian(10.0, 0, 2; kind=:even);\n\njulia> field_even = lg_even(xv, yv);\n\njulia> all(isreal, field_even)  # Even modes are real-valued\ntrue\n\nSee also: Gaussian, HermiteGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#Spatial-Layouts","page":"API","title":"Spatial Layouts","text":"","category":"section"},{"location":"api/modes/modes/#Layout-Types","page":"API","title":"Layout Types","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.PointLayout","page":"API","title":"FluxOptics.Modes.PointLayout","text":"PointLayout(n, p=(0,0), t=Id2D())\n\nCreate a layout of n identical points.\n\nArguments\n\nn: Number of points\np=(0,0): Position of the point\nt=Id2D(): Coordinate transformation\n\nReturns\n\nPointLayout that can be iterated to get point positions.\n\nExamples\n\njulia> layout = Modes.PointLayout(3, (100.0, 50.0));\n\njulia> positions = collect(layout);\n\njulia> length(positions)\n3\n\njulia> all(pos == (100.0, 50.0) for pos in positions)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.GridLayout","page":"API","title":"FluxOptics.Modes.GridLayout","text":"GridLayout(nx, ny, px, py, t=Id2D())\n\nCreate a regular rectangular grid layout.\n\nArguments\n\nnx, ny: Number of points in x and y directions\npx, py: Spacing between points in x and y\nt=Id2D(): Coordinate transformation\n\nReturns\n\nGridLayout that can be iterated to get point positions.\n\nExamples\n\njulia> layout = Modes.GridLayout(2, 3, 100.0, 50.0);\n\njulia> positions = collect(layout);\n\njulia> length(positions)  # 2×3 = 6 points\n6\n\njulia> positions[1]  # First point (centered grid)\n(-50.0, -50.0)\n\njulia> positions[end]  # Last point\n(50.0, 50.0)\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.TriangleLayout","page":"API","title":"FluxOptics.Modes.TriangleLayout","text":"TriangleLayout(np, px, py, t=Id2D())\n\nCreate a triangular arrangement of points.\n\nArguments\n\nnp: Number of points along triangle edge\npx, py: Spacing between points in x and y\nt=Id2D(): Coordinate transformation\n\nReturns\n\nTriangleLayout with np(np+1)/2 total points.\n\nExamples\n\njulia> layout = Modes.TriangleLayout(3, 100.0, 100.0);\n\njulia> length(layout)  # 3×4/2 = 6 points\n6\n\njulia> layout = Modes.TriangleLayout(4, 50.0, 50.0);\n\njulia> length(layout)  # 4×5/2 = 10 points\n10\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.CustomLayout","page":"API","title":"FluxOptics.Modes.CustomLayout","text":"CustomLayout(positions, t=Id2D())\n\nCreate a layout from custom list of positions.\n\nArguments\n\npositions: Vector of (x,y) tuples specifying point positions\nt=Id2D(): Coordinate transformation applied to all positions\n\nReturns\n\nCustomLayout that can be iterated to get transformed positions.\n\nExamples\n\njulia> positions = [(0.0, 0.0), (100.0, 0.0), (50.0, 86.6)];\n\njulia> layout = Modes.CustomLayout(positions);\n\njulia> collect(layout) == positions\ntrue\n\njulia> layout_rot = Modes.CustomLayout(positions, Rot2D(π/2));\n\njulia> rotated = collect(layout_rot);\n\njulia> all(isapprox.(rotated[2], (0.0, 100.0), atol=1e-12))  # Second point rotated 90°\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#Mode-Stack-Generation","page":"API","title":"Mode Stack Generation","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.generate_mode_stack","page":"API","title":"FluxOptics.Modes.generate_mode_stack","text":"generate_mode_stack(layout, nx, ny, dx, dy, mode; t=Id2D(), normalize=true)\ngenerate_mode_stack(layout, nx, ny, dx, dy, mode_vector; t=Id2D(), normalize=true)\ngenerate_mode_stack(nx, ny, dx, dy, mode_vector; t=Id2D(), normalize=true)\n\nGenerate arrays of optical modes at specified positions.\n\nThe first form replicates the same mode at each layout position. The second form uses different modes from mode_vector at each position. The third form places modes at the origin (single position each).\n\nArguments\n\nlayout: Spatial layout determining mode positions\nnx, ny: Grid size for each mode field\ndx, dy: Pixel size\nmode: Single mode to replicate at all positions\nmode_vector: Vector of modes (one per position)\nt=Id2D(): Additional transformation applied to all modes\nnormalize=true: Normalize each mode to unit power\n\nReturns\n\n3D complex array of size (nx, ny, n_modes) containing mode fields.\n\nExamples\n\njulia> layout = Modes.GridLayout(2, 2, 50.0, 50.0);\n\njulia> gaussian = Gaussian(10.0);\n\njulia> modes = generate_mode_stack(layout, 64, 64, 2.0, 2.0, gaussian);\n\njulia> size(modes)\n(64, 64, 4)\n\njulia> sum(abs2, modes[:, :, 1]) * 2.0 * 2.0  # Check first mode normalization\n1.0000000000000007\n\njulia> hg_modes = [HermiteGaussian(25.0, m, n) for m in 0:1 for n in 0:1];\n\njulia> modes_hg = generate_mode_stack(layout, 64, 64, 2.0, 2.0, hg_modes);\n\njulia> size(modes_hg)\n(64, 64, 4)\n\njulia> lg_modes = [LaguerreGaussian(20.0, 0, l) for l in 0:2];\n\njulia> modes_lg = generate_mode_stack(64, 64, 2.0, 2.0, lg_modes);\n\njulia> size(modes_lg)  # No layout specified, modes at origin\n(64, 64, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/modes/modes/#Speckle-Generation","page":"API","title":"Speckle Generation","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.generate_speckle","page":"API","title":"FluxOptics.Modes.generate_speckle","text":"generate_speckle(ns, ds, λ, NA; envelope=nothing, center=(0,0), t=Id2D(), normalize=true)\n\nGenerate random speckle pattern with controlled numerical aperture.\n\nCreates a complex random field with Fourier components limited by the numerical aperture, producing realistic speckle with controlled correlation length.\n\nArguments\n\nns: Grid dimensions - (nx,) for 1D, (nx, ny) for 2D, (nx, ny, nz) for 3D\nds: Pixel sizes - (dx,), (dx, dy), or (dx, dy, dz)\nλ: Wavelength\nNA: Numerical aperture controlling speckle size\nenvelope=nothing: Optional envelope function (Mode type)\ncenter=(0,0): Center position for envelope\nt=Id2D(): Coordinate transformation for envelope\nnormalize=true: Normalize the speckle distribution to unit power\n\nReturns\n\nComplex array with random speckle pattern.\n\nExamples\n\njulia> speckle = generate_speckle((64, 64), (1.0, 1.0), 1.064, 0.1);\n\njulia> isapprox(sum(abs2, speckle), 1)\ntrue\n\njulia> envelope = Gaussian(20.0);\n\njulia> speckle_env = generate_speckle((64, 64), (1.0, 1.0), 1.064, 0.1; envelope=envelope);\n\njulia> isapprox(sum(abs2, speckle_env), 1)\ntrue\n\njulia> speckle_1d = generate_speckle((128,), (0.5,), 1.064, 0.2);\n\njulia> isapprox(sum(abs2, speckle_1d) * 0.5, 1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/modes/modes/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/modes/modes/#Mode-Normalization","page":"API","title":"Mode Normalization","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"All modes are normalized to unit power by default\nPower = ∫∫ |u(x,y)|² dx dy = 1\nFor custom normalization, use norm_constant parameter","category":"page"},{"location":"api/modes/modes/#Mode-Propagation","page":"API","title":"Mode Propagation","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"Use λ and z parameters for Gaussian beam propagation\nIncludes Gouy phase shift\nconstant_phase=true includes exp(ikz) term","category":"page"},{"location":"api/modes/modes/#Layout-Centering","page":"API","title":"Layout Centering","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"Layouts are centered at (0, 0) by default\nUse coordinate transformations to shift layouts","category":"page"},{"location":"api/modes/modes/#Speckle-Statistics","page":"API","title":"Speckle Statistics","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"Correlation length ≈ λ / NA\nHigh NA → fine speckle (small correlation length)\nLow NA → coarse speckle (large correlation length)\nSpeckle is fully developed (unit contrast) without envelope","category":"page"},{"location":"api/modes/modes/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"GridUtils for coordinate systems\nFields for ScalarField operations","category":"page"},{"location":"api/optical_components/active/active_media/#Active-Media-API","page":"API","title":"Active Media API","text":"","category":"section"},{"location":"api/optical_components/active/active_media/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/optical_components/active/active_media/#FluxOptics.OpticalComponents.GainSheet","page":"API","title":"FluxOptics.OpticalComponents.GainSheet","text":"GainSheet(u::ScalarField, ds::NTuple, dz, Isat, f; trainable=false)\nGainSheet(u::ScalarField, dz, Isat, f; trainable=false)\n\nCreate a saturable gain sheet component.\n\nModels thin gain medium with spatially-varying gain coefficient and saturation. Gain follows: g(u) = g₀ / (1 + I/Isat) where I = |u|² is local intensity.\n\nArguments\n\nu::ScalarField: Field template\nds::NTuple: Spatial sampling (defaults to u.ds)\ndz::Real: Effective gain sheet thickness\nIsat::Real: Saturation intensity\nf::Function: Gain coefficient function (x, y) -> g₀\ntrainable::Bool: Optimize gain profile (default: false)\n\nPhysics\n\nTransmission: u_out = u_in × exp(g(I) × dz)\n\nwhere:\n\ng(u) = g₀ / (1 + I/Isat): Gain coefficient with saturation\nI = |u|²: Local intensity\nHigh intensity → gain saturation (g → 0)\nLow intensity → linear gain (g ≈ g₀)\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (2.0, 2.0), 1.064)\n\n# Uniform gain\ngain = GainSheet(u, (2.0, 2.0), 0.1, 1e6, (x, y) -> 2.0)\n\n# Spatially-varying gain (e.g., pumped region)\ngain_region = GainSheet(u, 0.1, 1e6, (x, y) -> begin\n    r = sqrt(x^2 + y^2)\n    r < 50.0 ? 2.0 : 0.0\nend)\n\n# Trainable gain profile\ngain_opt = GainSheet(u, 0.1, 1e6, (x, y) -> 1.0; trainable=true)\n\nSee also: Phase, Mask\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/active/active_media/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/active/active_media/","page":"API","title":"API","text":"Modulators for passive modulation\nCore for trainability system","category":"page"},{"location":"api/optical_components/bulk/bulk/#Bulk-Propagators-API","page":"API","title":"Bulk Propagators API","text":"","category":"section"},{"location":"api/optical_components/bulk/bulk/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/optical_components/bulk/bulk/#FluxOptics.OpticalComponents.AS_BPM","page":"API","title":"FluxOptics.OpticalComponents.AS_BPM","text":"AS_BPM(u::ScalarField, thickness, n0, dn0; use_cache=true, paraxial=false, trainable=false, buffered=false, aperture=(x,y)->1, double_precision_kernel=use_cache)\n\nBeam Propagation Method using Angular Spectrum for inhomogeneous media.\n\nPropagates through a volume with spatially-varying refractive index using split-step method with Angular Spectrum propagation. Handles both on-axis and tilted beams.\n\nArguments\n\nu::ScalarField: Field template\nthickness::Real: Total propagation distance\nn0::Real: Background refractive index\ndn0::AbstractArray{<:Real}: Refractive index variation (3D: nx × ny × n_slices)\nuse_cache::Bool: Cache propagation kernels (default: true)\nparaxial::Bool: Use paraxial approximation (default: false)\ntrainable::Bool: Optimize refractive index profile (default: false)\nbuffered::Bool: Pre-allocate gradient buffers (default: false)\naperture::Function: Aperture function (x, y) -> transmission (default: unity)\ndouble_precision_kernel::Bool: Use Float64 for kernels (default: use_cache)\n\nPhysics\n\nSplit-step method:\n\nHalf-step propagation in background (n₀)\nApply phase shift: exp(i k₀ Δn(x,y,z) Δz)\nFull-step propagation in background\nRepeat for all slices\n\nPhase correction includes cosine factor for tilted beams to account for oblique propagation geometry.\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256, 256), (2.0, 2.0), 1.064)\n\n# Uniform refractive index variation\nthickness = 1000.0  # μm\nn_slices = 100\ndn = 0.01 * ones(256, 256, n_slices)  # Constant Δn\nbpm = AS_BPM(u, thickness, 1.0, dn)\n\n# Graded-index fiber\nr = sqrt.(xv.^2 .+ yv'.^2)\ndn_fiber = -0.01 * (r/50).^2  # Parabolic index\ndn_3d = repeat(dn_fiber, 1, 1, n_slices)\nbpm_fiber = AS_BPM(u, thickness, 1.5, dn_3d)\n\n# Trainable refractive index (e.g., waveguide design)\ndn_init = zeros(256, 256, n_slices)\nbpm_opt = AS_BPM(u, thickness, 1.0, dn_init; trainable=true, buffered=true)\n\nSee also: Shift_BPM, ASProp\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/bulk/bulk/#FluxOptics.OpticalComponents.Shift_BPM","page":"API","title":"FluxOptics.OpticalComponents.Shift_BPM","text":"Shift_BPM(u::ScalarField, thickness, dn0; use_cache=true, trainable=false, buffered=false, aperture=(x,y)->1, double_precision_kernel=use_cache)\n\nBeam Propagation Method using geometric shift (no diffraction).\n\nPropagates through inhomogeneous media using pure geometric shifts based on field tilts. Equivalent to backprojection in tomography. Useful for comparison with diffraction-based methods or for high-NA/short-wavelength regimes where ray optics dominates.\n\nArguments\n\nu::ScalarField: Field template (must have tilts defined)\nthickness::Real: Total propagation distance\ndn0::AbstractArray{<:Real}: Refractive index variation (3D: nx × ny × n_slices)\nuse_cache::Bool: Cache shift operators (default: true)\ntrainable::Bool: Optimize refractive index profile (default: false)\nbuffered::Bool: Pre-allocate gradient buffers (default: false)\naperture::Function: Aperture function (x, y) -> transmission (default: unity)\ndouble_precision_kernel::Bool: Use Float64 precision (default: use_cache)\n\nPhysics\n\nGeometric propagation:\n\nHalf-step shift based on tilt\nApply phase shift: exp(i k₀ Δn(x,y,z) Δz)\nFull-step shift\nRepeat for all slices\n\nNote: This method ignores diffraction entirely, using only the tilt information stored in ScalarField. It cannot detect phase gradients in the complex field itself.\n\nUse Cases\n\nComparison with diffraction-based BPM to quantify diffraction effects\nRay-tracing approximation for validation\nTomographic reconstruction (backprojection algorithm)\nHigh-frequency limit where λ → 0\n\nLimitation: Pure backprojection is generally inferior to diffraction-based methods in optical regimes. Diffraction matters, especially in fiber optics and waveguide tomography.\n\nExamples\n\n# Tilted beam required\nu = ScalarField(gaussian(xv, yv), (2.0, 2.0), 1.064; tilts=(0.01, 0.0))\n\nthickness = 1000.0\nn_slices = 100\ndn = 0.01 * ones(256, 256, n_slices)\n\n# Geometric shift (no diffraction)\nshift_bpm = Shift_BPM(u, thickness, dn)\n\n# Compare with diffraction\nas_bpm = AS_BPM(u, thickness, 1.0, dn)\n\nu_shift = propagate(u, shift_bpm, Forward)\nu_diffraction = propagate(u, as_bpm, Forward)\n# Difference shows diffraction contribution\n\nSee also: AS_BPM, ShiftProp\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/bulk/bulk/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/optical_components/bulk/bulk/#Split-Step-Method","page":"API","title":"Split-Step Method","text":"","category":"section"},{"location":"api/optical_components/bulk/bulk/","page":"API","title":"API","text":"AS_BPM uses split-step Fourier method:","category":"page"},{"location":"api/optical_components/bulk/bulk/","page":"API","title":"API","text":"Apply phase shift from Δn: exp(i k₀ Δn dz cos(θ))\nPropagate dz in background medium (n₀)\nRepeat for all slices","category":"page"},{"location":"api/optical_components/bulk/bulk/","page":"API","title":"API","text":"Note: Implementation adds half-steps (dz/2) before the first and after the last phase mask for symmetry, though this has minimal impact on results.","category":"page"},{"location":"api/optical_components/bulk/bulk/","page":"API","title":"API","text":"Cosine correction accounts for oblique propagation in tilted beams.","category":"page"},{"location":"api/optical_components/bulk/bulk/#Slice-Discretization","page":"API","title":"Slice Discretization","text":"","category":"section"},{"location":"api/optical_components/bulk/bulk/","page":"API","title":"API","text":"More slices → better accuracy but slower:","category":"page"},{"location":"api/optical_components/bulk/bulk/","page":"API","title":"API","text":"Rule of thumb: dz < λ / (2 max|Δn|)\nFor weak variations: 10-50 slices often sufficient\nFor strong gradients: 100-1000 slices may be needed","category":"page"},{"location":"api/optical_components/bulk/bulk/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/bulk/bulk/","page":"API","title":"API","text":"ASProp for homogeneous propagation\nCore for trainability","category":"page"},{"location":"api/optical_components/fourier/#Fourier","page":"Fourier","title":"Fourier","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"Fourier-domain operations and filtering.","category":"page"},{"location":"api/optical_components/fourier/#Overview","page":"Fourier","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"The Fourier module provides tools for applying operations in the frequency domain, including spatial filtering, frequency-domain masks, and wrapping spatial components to operate on Fourier transforms.","category":"page"},{"location":"api/optical_components/fourier/#Examples","page":"Fourier","title":"Examples","text":"","category":"section"},{"location":"api/optical_components/fourier/#Frequency-Domain-Filtering","page":"Fourier","title":"Frequency-Domain Filtering","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"using FluxOptics\n\nxv, yv = spatial_vectors(128, 128, 1.0, 1.0)\nu = ScalarField(Gaussian(20.0)(xv, yv), (1.0, 1.0), 1.064)\n\n# Sharp low-pass filter\nf_cutoff = 0.02  # 1/μm\nlowpass = FourierMask(u, (fx, fy) -> sqrt(fx^2 + fy^2) < f_cutoff ? 1.0 : 0.0)\n\n# Apply filter\nu_filtered = propagate(u, lowpass, Forward)\n\n# Check power conservation (should be < 1 due to filtering)\npower(u_filtered)[] / power(u)[]","category":"page"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"# Gaussian filter (soft cutoff)\nsigma_f = 0.15  # 1/μm\ngaussian_filter = FourierMask(u, (fx, fy) -> exp(-(fx^2 + fy^2)/(2*sigma_f^2)))\n\nu_smooth = propagate(u, gaussian_filter, Forward)\n\npower(u_smooth)[] / power(u)[]","category":"page"},{"location":"api/optical_components/fourier/#Frequency-Domain-Phase","page":"Fourier","title":"Frequency-Domain Phase","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"# Parabolic phase in frequency (quadratic chirp in spatial domain)\nfourier_phase = FourierPhase(u, (fx, fy) -> π * 0.01 * (fx^2 + fy^2))\n\nu_chirped = propagate(u, fourier_phase, Forward)\n\n# Phase modulation doesn't affect power\npower(u_chirped)[]","category":"page"},{"location":"api/optical_components/fourier/#Wrapping-Spatial-Components","page":"Fourier","title":"Wrapping Spatial Components","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"# Apply spatial phase mask in Fourier domain\nphase_spatial = Phase(u, (x, y) -> 0.01 * x^2; trainable=true)\nphase_in_fourier = FourierWrapper(u, phase_spatial)\n\n# Equivalent to: FFT → phase_spatial → IFFT\nistrainable(phase_in_fourier)","category":"page"},{"location":"api/optical_components/fourier/#Using-in-Systems","page":"Fourier","title":"Using in Systems","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"# Combine spatial and frequency filtering\nsource = ScalarSource(u)\nlowpass = FourierMask(u, (fx, fy) -> sqrt(fx^2 + fy^2) < 0.02 ? 1.0 : 0.0)\nphase = Phase(u, (x, y) -> 0.01 * (x^2 + y^2))\nprop = ASProp(u, 1000.0)\n\nsystem = source |> lowpass |> phase |> prop\n\nresult = system()\npower(result.out)[]","category":"page"},{"location":"api/optical_components/fourier/#Key-Types","page":"Fourier","title":"Key Types","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"FourierOperator: FFT/IFFT transformation (low-level)\nFourierWrapper: Apply component in Fourier domain (FFT → component → IFFT)\nFourierPhase: Phase mask in Fourier space (convenience)\nFourierMask: Amplitude/complex mask in Fourier space (convenience)","category":"page"},{"location":"api/optical_components/fourier/#Coordinate-Convention","page":"Fourier","title":"Coordinate Convention","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"Functions receive frequency arguments (fx, fy) in units of 1/length:","category":"page"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"Frequency grid: fx = fftfreq(nx, 1/dx)\nZero frequency at center after fftshift","category":"page"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"Example: For dx = 1.0 μm and nx = 128, fx ranges from -0.5 to +0.5-1/128 μm⁻¹.","category":"page"},{"location":"api/optical_components/fourier/#Component-Relationships","page":"Fourier","title":"Component Relationships","text":"","category":"section"},{"location":"api/optical_components/fourier/#FourierPhase-and-FourierMask","page":"Fourier","title":"FourierPhase and FourierMask","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"Convenience constructors that internally use FourierWrapper:","category":"page"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"# These are equivalent:\nFourierPhase(u, (fx, fy) -> φ(fx, fy))\nFourierWrapper(u, Phase(u, ...))  # Phase evaluated in frequency\n\nFourierMask(u, (fx, fy) -> m(fx, fy))\nFourierWrapper(u, Mask(u, ...))   # Mask evaluated in frequency","category":"page"},{"location":"api/optical_components/fourier/#FourierWrapper","page":"Fourier","title":"FourierWrapper","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"General wrapper that applies: u → IFFT[component(FFT[u])]","category":"page"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"Useful for applying spatial-domain components to frequency content.","category":"page"},{"location":"api/optical_components/fourier/#See-Also","page":"Fourier","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"Modulators - Spatial-domain phase and amplitude modulation\nCore - Trainability and component interface\nFree-Space Propagators - All propagation methods use FourierWrapper","category":"page"},{"location":"api/optical_components/fourier/#Index","page":"Fourier","title":"Index","text":"","category":"section"},{"location":"api/optical_components/fourier/","page":"Fourier","title":"Fourier","text":"Modules = [FluxOptics.OpticalComponents]\nPages = [\"fourier.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/gridutils/#GridUtils","page":"GridUtils","title":"GridUtils","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Coordinate systems and transformations for optical field grids.","category":"page"},{"location":"api/gridutils/#Overview","page":"GridUtils","title":"Overview","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"The GridUtils module provides:","category":"page"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Spatial coordinate generation for optical field grids\n2D coordinate transformations (translations, rotations)\nCoordinate composition for complex geometries","category":"page"},{"location":"api/gridutils/#Quick-Example","page":"GridUtils","title":"Quick Example","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"using FluxOptics\nusing Statistics\n\n# Generate 2D coordinate grid\nxv, yv = spatial_vectors((128, 128), (2.0, 2.0); offset=(-5.0, 30.5))\n\n(mean(xv), mean(yv))  # Grid center = -offset","category":"page"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"# Create transformation: shift then rotate\ntransform = Rot2D(π/4) ∘ Shift2D(10.0, 5.0)\n\n# Apply to a point\npoint = transform([0.0, 0.0])","category":"page"},{"location":"api/gridutils/#Key-Functions","page":"GridUtils","title":"Key Functions","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"spatial_vectors: Generate coordinate arrays\nShift2D: 2D translation transformation\nRot2D: 2D rotation transformation\nId2D: Identity transformation","category":"page"},{"location":"api/gridutils/#See-Also","page":"GridUtils","title":"See Also","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Modes for using coordinates with optical modes\nFields for ScalarField grid structure","category":"page"},{"location":"api/gridutils/#Index","page":"GridUtils","title":"Index","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Modules = [FluxOptics.GridUtils]\nOrder = [:type, :function]","category":"page"},{"location":"api/optical_components/core/#Core","page":"Core","title":"Core","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Foundational types and interfaces for optical components.","category":"page"},{"location":"api/optical_components/core/#Overview","page":"Core","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"The Core module defines the abstract component hierarchy, trainability system, and propagation interface used by all optical components in FluxOptics.","category":"page"},{"location":"api/optical_components/core/#Examples","page":"Core","title":"Examples","text":"","category":"section"},{"location":"api/optical_components/core/#Component-Trainability","page":"Core","title":"Component Trainability","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"using FluxOptics\n\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\n\n# Static component (not optimizable)\nphase_static = Phase(u, (x, y) -> x^2)\nistrainable(phase_static)  # false","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"# Trainable component (optimizable parameters)\nphase_train = Phase(u, (x, y) -> 0.0; trainable=true)\n\nistrainable(phase_train)  # true","category":"page"},{"location":"api/optical_components/core/#Extracting-Trainable-Parameters","page":"Core","title":"Extracting Trainable Parameters","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"# Access parameters for optimization\nparams = trainable(phase_train)\n\n# params is a NamedTuple containing trainable arrays\nkeys(params)","category":"page"},{"location":"api/optical_components/core/#Propagation-Interface","page":"Core","title":"Propagation Interface","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"# Forward propagation\nu_fwd = propagate(u, phase_static, Forward)\n\n# Backward propagation (applies conjugate phase)\nu_bwd = propagate(u, phase_static, Backward)\n\n# Forward and backward are complex conjugates\nmaximum(abs, u_fwd.electric - conj.(u_bwd.electric))","category":"page"},{"location":"api/optical_components/core/#Buffering-Strategy","page":"Core","title":"Buffering Strategy","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"# Buffered: pre-allocated gradient buffers (faster for iterative optimization)\nphase_buffered = Phase(u, (x, y) -> 0.0; trainable=true, buffered=true)\n\n# Unbuffered: allocates on-demand (lower memory footprint)\nphase_unbuffered = Phase(u, (x, y) -> 0.0; trainable=true, buffered=false)\n\n(isbuffered(phase_buffered), isbuffered(phase_unbuffered))","category":"page"},{"location":"api/optical_components/core/#Component-Hierarchy","page":"Core","title":"Component Hierarchy","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"AbstractOpticalComponent{M}\n├── AbstractOpticalSource{M}        # Generates fields\n│   ├── AbstractPureSource{M}       # Functional sources\n│   └── AbstractCustomSource{M}     # Stateful sources\n└── AbstractPipeComponent{M}        # Transforms fields\n    ├── AbstractPureComponent{M}    # Functional components\n    └── AbstractCustomComponent{M}  # Stateful components","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Where M <: Trainability:","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Static: Non-trainable, fixed parameters\nTrainable{Buffered}: Trainable with pre-allocated buffers\nTrainable{Unbuffered}: Trainable with on-demand allocation","category":"page"},{"location":"api/optical_components/core/#Key-Concepts","page":"Core","title":"Key Concepts","text":"","category":"section"},{"location":"api/optical_components/core/#Trainability","page":"Core","title":"Trainability","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Controls whether component parameters can be optimized:","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Static: Fixed parameters, no gradient computation, faster\nTrainable: Optimizable parameters, enables inverse design","category":"page"},{"location":"api/optical_components/core/#Buffering","page":"Core","title":"Buffering","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Controls memory allocation strategy for trainable components:","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Buffered: Pre-allocates gradient and forward buffers → faster for repeated optimization\nUnbuffered: Allocates on-demand → lower memory usage, good for prototyping","category":"page"},{"location":"api/optical_components/core/#Bidirectional-Propagation","page":"Core","title":"Bidirectional Propagation","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"All components support forward and backward propagation:","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Forward: Standard propagation through the component\nBackward: Computes the adjoint operation (required for gradient computation)\nBackward propagation is used internally during automatic differentiation\nPhysical interpretation: time-reversal with conjugate fields","category":"page"},{"location":"api/optical_components/core/#Pure-vs-Custom-Components","page":"Core","title":"Pure vs Custom Components","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Pure Components (AbstractPureComponent):","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"No manual gradient rules needed\nZygote handles differentiation automatically\nCan wrap complex internal state or AbstractCustomComponent\nExamples: ASPropZ, OpticalSequence, FourierWrapper","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Custom Components (AbstractCustomComponent):","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Custom gradient implementations\nMore control over memory and computation\nBetter performance for specific operations\nExamples: Phase, Mask, ASProp, BPM","category":"page"},{"location":"api/optical_components/core/#Source-vs-Pipe-Components","page":"Core","title":"Source vs Pipe Components","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Sources (AbstractOpticalSource):","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Generate fields\nUse propagate(source) (no input field argument)\nPlaced at beginning of optical systems\nExample: ScalarSource","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Pipe Components (AbstractPipeComponent):","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Transform existing fields\nTake input field as argument\nUse propagate(u, component, direction)\nExamples: Phase, Mask, ASProp, FourierLens","category":"page"},{"location":"api/optical_components/core/#Key-Types","page":"Core","title":"Key Types","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Abstract Types","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"AbstractOpticalComponent: Root type for all components\nAbstractOpticalSource: Field generators\nAbstractPipeComponent: Field transformers\nAbstractPureComponent: Functional interface components\nAbstractCustomComponent: Stateful components","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Trainability","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Trainability: Abstract trainability type\nStatic: Non-trainable components\nTrainable: Trainable components\nBuffering: Buffer management strategy\nBuffered, Unbuffered: Buffering modes","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Direction","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Direction: Abstract direction type\nForward, Backward: Propagation directions","category":"page"},{"location":"api/optical_components/core/#Key-Functions","page":"Core","title":"Key Functions","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Component Interface","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"propagate: Apply component (creates copy)\npropagate!: Apply component in-place\nget_data: Access component parameters\ntrainable: Extract trainable parameters","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Component Queries","category":"page"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"istrainable: Check if component is trainable\nisbuffered: Check if component uses buffers","category":"page"},{"location":"api/optical_components/core/#See-Also","page":"Core","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Typical Workflow - Complete optimization example\nSources - Field generation components\nModulators - Phase and amplitude modulation\nSystem - Building optical systems","category":"page"},{"location":"api/optical_components/core/#Index","page":"Core","title":"Index","text":"","category":"section"},{"location":"api/optical_components/core/","page":"Core","title":"Core","text":"Modules = [FluxOptics.OpticalComponents]\nPages = [\"core.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/optical_components/utilities/utilities/#Utilities-API","page":"API","title":"Utilities API","text":"","category":"section"},{"location":"api/optical_components/utilities/utilities/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/optical_components/utilities/utilities/#FluxOptics.OpticalComponents.PadCropOperator","page":"API","title":"FluxOptics.OpticalComponents.PadCropOperator","text":"PadCropOperator(u::ScalarField, u_tmp::AbstractArray; offset=(0,...), pad_val=0, store_ref=false)\n\nCreate reversible pad/crop operator for efficient memory management.\n\nWraps padding and cropping as an optical component. The adjoint operation swaps pad and crop directions. With store_ref=true, can reuse the original array during crop (avoids allocation) when pad/crop are symmetric.\n\nArguments\n\nu::ScalarField: Original (small) field template\nu_tmp: Padded array template (defines target size)\noffset: Position offset for pad/crop (default: all zeros)\npad_val: Value for padded regions (default: 0)\nstore_ref::Bool: Store reference to enable zero-allocation crop (default: false)\n\nUsage Patterns\n\nBasic usage (with allocation):\n\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\nu_tmp = zeros(ComplexF64, 256, 256)\n\npad_op = PadCropOperator(u, u_tmp)\ncrop_op = adjoint(pad_op)\n\n# Pad then crop\nsystem = source |> pad_op |> propagator |> crop_op\n\nZero-allocation mode (symmetric pad/crop):\n\n# Store reference to reuse original array during crop\npad_op = PadCropOperator(u, u_tmp; store_ref=true)\ncrop_op = adjoint(pad_op)\n\n# Crop reuses original array - no allocation\nsystem = source |> pad_op |> processing |> crop_op\n\nWith offset:\n\n# Center the field in padded array\noffset = ((256-128)÷2, (256-128)÷2)\npad_op = PadCropOperator(u, u_tmp; offset=offset)\n\nTechnical Details\n\nForward direction: Applies pad if ispad=true, crop otherwise\nBackward direction: Swaps operation (crop if ispad=true, pad otherwise)\nadjoint(op): Flips ispad flag, swapping pad/crop behavior\nstore_ref=true: Only works for symmetric operations (same offset, sizes match)\n\nExamples\n\n# Avoid aliasing in propagation\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\nu_tmp = zeros(ComplexF64, 256, 256)\n\npad_op = PadCropOperator(u, u_tmp; store_ref=true)\nprop = ASProp(set_field_data(u, u_tmp), 1000.0)\ncrop_op = adjoint(pad_op)\n\n# Efficient: crop reuses original buffer\nsystem = ScalarSource(u) |> pad_op |> prop |> crop_op\n\nresult = system().out.electric\n\nSee also: pad, crop\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/utilities/utilities/#FluxOptics.OpticalComponents.TiltAnchor","page":"API","title":"FluxOptics.OpticalComponents.TiltAnchor","text":"TiltAnchor(u::ScalarField; trainable=false)\n\nAnchor point for tilt reference in optical systems.\n\nMaintains a reference for beam tilt through a sequence of components. Useful in off-axis systems where tilt changes need to be tracked or reset.\n\nArguments\n\nu::ScalarField: Field template\ntrainable::Bool: Typically false (default: false)\n\nExamples\n\n# Anchor tilt at specific points\nanchor1 = TiltAnchor(u)\nanchor2 = TiltAnchor(u)\n\n# System with tilt anchors\nsystem = source |> anchor1 |> components... |> anchor2\n\n# Maintains tilt reference through propagation\n\nSee also: offset_tilts!, set_field_tilts\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/utilities/utilities/#FluxOptics.OpticalComponents.BasisProjectionWrapper","page":"API","title":"FluxOptics.OpticalComponents.BasisProjectionWrapper","text":"BasisProjectionWrapper(component, basis, coefficients)\n\nWrap a component to optimize over basis coefficients instead of pixel values.\n\nReparametrizes trainable components (Phase, Mask, etc.) to use a lower-dimensional basis representation. Instead of optimizing all pixels independently, optimizes coefficients that reconstruct the component via the basis. Useful for regularizing ill-posed inverse problems or enforcing smoothness constraints.\n\nArguments\n\ncomponent: Trainable component to wrap (Phase, Mask, FourierPhase, etc.)\nbasis: Basis functions for reconstruction (from make_spatial_basis or make_fourier_basis)\ncoefficients: Initial coefficient array (length = number of basis functions)\n\nUse Case\n\nPixel-wise optimization can be ill-posed for inverse problems, leading to artifacts. Basis projection restricts the solution space to smooth/structured functions, providing implicit regularization.\n\nExamples\n\nu = ScalarField(ones(ComplexF64, 256), (2.0,), 1.064)\n\n# Phase mask with polynomial basis (instead of pixel-wise)\nphase_mask = FourierPhase(u, zeros(256); trainable=true)\n\n# Create polynomial basis\nn_basis = 10\nf_cutoff = 1e-3\nbasis = make_fourier_basis((fx, p) -> (abs(fx) < f_cutoff ? fx^p : 0.0), \n                            (256,), (2.0,), (0:n_basis-1))\n\n# Wrap for basis optimization\nphase_wrapper = BasisProjectionWrapper(phase_mask, basis, zeros(n_basis))\n\n# Now optimize n_basis coefficients instead of nx pixels\nsystem = source |> phase_wrapper |> propagator\n# ... optimization optimizes basis coefficients ...\n\nBenefit: Optimization converges with fewer parameters and enforces smoothness.\n\nSee also: make_spatial_basis, make_fourier_basis\n\n\n\n\n\n","category":"type"},{"location":"api/optical_components/utilities/utilities/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/optical_components/utilities/utilities/#FluxOptics.OpticalComponents.pad","page":"API","title":"FluxOptics.OpticalComponents.pad","text":"pad(array, new_size; offset=(0, 0, ...), pad_val=0)\n\nPad array to new size by placing original array at specified offset.\n\nCreates a new array of new_size filled with pad_val, then copies the original array starting at offset. The offset determines where the original array is positioned in the padded result.\n\nArguments\n\narray: Array to pad\nnew_size: Target size (must be ≥ current size in each dimension)\noffset: Starting position for original array in padded result (default: all zeros)\npad_val: Value for padded regions (default: 0)\n\nReturns\n\nPadded array of size new_size with original array at specified offset.\n\nExamples\n\nu = ones(ComplexF64, 128, 128)\n\n# Place at origin (top-left)\nu_pad = pad(u, (256, 256); offset=(0, 0))\n\n# Center the array\noffset_center = ((256-128)÷2, (256-128)÷2)\nu_centered = pad(u, (256, 256); offset=offset_center)\n\n# Offset to specific position\nu_offset = pad(u, (256, 256); offset=(50, 30))\n\nSee also: crop, PadCropOperator\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/utilities/utilities/#FluxOptics.OpticalComponents.crop","page":"API","title":"FluxOptics.OpticalComponents.crop","text":"crop(array, new_size; offset=(0, 0, ...))\n\nExtract sub-region from array starting at specified offset.\n\nExtracts a region of size new_size from the array, starting at offset. The offset determines where extraction begins.\n\nArguments\n\narray: Array to crop\nnew_size: Size of region to extract (must be ≤ current size)\noffset: Starting indices for extraction (default: all zeros)\n\nReturns\n\nCropped array of size new_size.\n\nExamples\n\nu_large = ones(ComplexF64, 256, 256)\n\n# Extract from origin\nu_crop = crop(u_large, (128, 128); offset=(0, 0))\n\n# Extract centered region\noffset_center = ((256-128)÷2, (256-128)÷2)\nu_center = crop(u_large, (128, 128); offset=offset_center)\n\n# Extract from specific position\nu_region = crop(u_large, (128, 128); offset=(50, 30))\n\nSee also: pad, PadCropOperator\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/utilities/utilities/#FluxOptics.OpticalComponents.make_spatial_basis","page":"API","title":"FluxOptics.OpticalComponents.make_spatial_basis","text":"make_spatial_basis(f, size, ds, params...)\n\nCreate basis functions evaluated on a spatial grid.\n\nGenerates a set of basis functions by evaluating function f with different parameters on the spatial grid. Used with BasisProjectionWrapper to reparametrize components.\n\nArguments\n\nf: Basis function (x, y, ..., params...) -> value\nsize: Grid size tuple\nds: Spatial sampling tuple\nparams...: Additional parameter arrays to broadcast (e.g., basis indices)\n\nReturns\n\nBasis array where each slice corresponds to one basis function.\n\nExamples\n\n# Polynomial basis in 1D\nbasis_1d = make_spatial_basis((x, n) -> x^n, (256,), (1.0,), 0:9)\n# Creates 10 basis functions: x^0, x^1, ..., x^9\n\n# Zernike-like radial polynomials in 2D\nfunction zernike_radial(x, y, n, m)\n    r = sqrt(x^2 + y^2)\n    r < 1.0 ? r^n * cos(m*atan(y, x)) : 0.0\nend\n\nns = [0, 1, 1, 2, 2, 2]\nms = [0, -1, 1, -2, 0, 2]\nbasis_2d = make_spatial_basis(zernike_radial, (128, 128), (1.0, 1.0), ns, ms)\n\nSee also: make_fourier_basis, BasisProjectionWrapper\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/utilities/utilities/#FluxOptics.OpticalComponents.make_fourier_basis","page":"API","title":"FluxOptics.OpticalComponents.make_fourier_basis","text":"make_fourier_basis(f, size, ds, params...)\n\nCreate basis functions evaluated on a Fourier grid.\n\nSimilar to make_spatial_basis but evaluates on spatial frequency coordinates. Useful for frequency-domain components like FourierPhase.\n\nArguments\n\nf: Basis function (fx, fy, ..., params...) -> value in Fourier space\nsize: Grid size tuple\nds: Spatial sampling tuple (determines frequency grid)\nparams...: Additional parameter arrays to broadcast\n\nReturns\n\nFourier-domain basis array.\n\nExamples\n\n# Polynomial basis in Fourier domain\nbasis_fourier = make_fourier_basis((fx, n) -> abs(fx)^n, (256,), (1.0,), 0:5)\n\n# Radial polynomial with cutoff\nfunction radial_poly(fx, fy, p, NA, λ)\n    f_mag = sqrt(fx^2 + fy^2)\n    f_mag <= NA/λ ? f_mag^p : 0.0\nend\n\nNA = 0.01\nλ = 1.064\npowers = 0:2:10\nbasis = make_fourier_basis((fx, fy, p) -> radial_poly(fx, fy, p, NA, λ), (128, 128), (1.0, 1.0), powers)\n\nSee also: make_spatial_basis, BasisProjectionWrapper\n\n\n\n\n\n","category":"function"},{"location":"api/optical_components/utilities/utilities/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/optical_components/utilities/utilities/#PadCropOperator","page":"API","title":"PadCropOperator","text":"","category":"section"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Adjoint behavior:","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"adjoint(pad_op) swaps pad and crop\nEnables symmetric operations: source |> pad |> processing |> crop","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Store reference mode:","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"store_ref=true: Reuses original array during crop (zero allocation)\nOnly valid for symmetric operations\nRequires pad and crop to use same offset/sizes","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Direction handling:","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Forward: applies operation based on ispad flag\nBackward: swaps operation","category":"page"},{"location":"api/optical_components/utilities/utilities/#BasisProjectionWrapper","page":"API","title":"BasisProjectionWrapper","text":"","category":"section"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Use cases:","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Inverse problems with ill-posed pixel-wise optimization\nEnforcing smoothness constraints","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Basis selection:","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Polynomials: smooth, global features\nZernike: optical aberrations\nFourier: periodic structures\nCustom: problem-specific functions","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Performance:","category":"page"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Optimization on Nbasis coefficients vs Npixels\nTypical: Nbasis ≪ Npixels (10-100 vs 10⁴-10⁶)","category":"page"},{"location":"api/optical_components/utilities/utilities/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/utilities/utilities/","page":"API","title":"API","text":"Fields for ScalarField operations\nModulators for components to wrap\nSystem for composition","category":"page"},{"location":"api/plotting/plotting/#Plotting-API","page":"API","title":"Plotting API","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Loading: This module is loaded conditionally. Use using Makie (or GLMakie, CairoMakie, WGLMakie) before using plotting functions.","category":"page"},{"location":"api/plotting/plotting/#Visualization-Functions","page":"API","title":"Visualization Functions","text":"","category":"section"},{"location":"api/plotting/plotting/#FluxOptics.Plotting.visualize","page":"API","title":"FluxOptics.Plotting.visualize","text":"visualize(u, fs; colormap=:viridis, height=200, show_colorbars=false)\nvisualize(u_vec, fs; colormap=:viridis, height=200, show_colorbars=false)\n\nDisplay optical fields or components with specified visualization functions.\n\nCreates a static heatmap figure showing one or more fields with one or more visualization functions (intensity, phase, etc.). All views are displayed simultaneously in a grid layout. Works with CairoMakie or GLMakie.\n\nArguments\n\nu: Single plottable object (ScalarField, AbstractOpticalComponent, or 2D array)\nu_vec: Vector or tuple of plottable objects (displayed as rows)\nfs: Visualization function or tuple of functions (displayed as columns)\ncolormap: Colormap name(s) - single symbol or tuple matching fs\nheight: Height in pixels per heatmap (default: 200)\nshow_colorbars: Display colorbars for real-valued plots (default: false)\n\nPlottable Types\n\nScalarField: Optical fields\nAbstractOpticalComponent: Phase masks, DOEs, etc. with 2D data\nAbstractArray{<:Number, 2}: Raw 2D arrays\n\nVisualization Functions\n\nCommon functions:\n\nintensity: Total intensity |u|²\nphase: Phase angle in radians\nreal, imag: Real/imaginary parts\nabs: Magnitude\nidentity: Complex field with HSV colormap\n\nExamples\n\nSingle field, single view:\n\nu = ScalarField(gaussian_data, (2.0, 2.0), 1.064)\nfig = visualize(u, intensity)\n\nMultiple representations:\n\nfig = visualize(u, (intensity, phase, real, imag))\n\nMultiple fields (comparison):\n\nfig = visualize([target, optimized], intensity)\n\nCustom colormaps:\n\nfig = visualize(u, (intensity, phase); \n                colormap=(:viridis, :twilight))\n\nWith colorbars:\n\nfig = visualize(u, intensity; show_colorbars=true, height=300)\n\nVisualize component:\n\nphase_mask = Phase(u, (x, y) -> x^2; trainable=true)\nfig = visualize(phase_mask, identity)\n\nNotes\n\nFor large field stacks, prefer visualize_slider to avoid displaying all at once\nComplex-valued results automatically use HSV colormap (:dark or :light)\nWidth computed automatically to maintain aspect ratio\nCompatible with CairoMakie (static) and GLMakie (interactive)\n\nSee also: visualize_slider, intensity, phase\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/plotting/#FluxOptics.Plotting.visualize_slider","page":"API","title":"FluxOptics.Plotting.visualize_slider","text":"visualize_slider(u_vec, fs; colormap=:viridis, height=400)\n\nDisplay field sequence with interactive slider for navigation.\n\nCreates an interactive figure with a horizontal slider to navigate through a sequence of fields. All visualization functions update in real-time when moving the slider. Requires GLMakie (interactive backend).\n\nThis is preferred over visualize for large field sequences (propagation steps, optimization iterations, etc.) as it avoids displaying all fields simultaneously.\n\nArguments\n\nu_vec: Vector or tuple of plottable objects (sequence to navigate)\nfs: Visualization function or tuple of functions\ncolormap: Colormap name(s) - single symbol or tuple matching fs\nheight: Height in pixels per heatmap (default: 400)\n\nRequirements\n\nMust use GLMakie (interactive backend with slider support)\nCairoMakie and WGLMakie do not support interactive sliders\n\nExamples\n\nPropagation sequence:\n\nusing GLMakie\n\n# Create propagation sequence\ndistances = range(0, 2000, length=50)\nu0 = ScalarField(gaussian_data, (2.0, 2.0), 1.064)\nsequence = [propagate(u0, ASProp(u0, z), Forward) for z in distances]\n\n# Interactive slider\nfig = visualize_slider(sequence, intensity)\ndisplay(fig)\n\nMultiple representations:\n\nfig = visualize_slider(sequence, (intensity, phase))\n\nOptimization iterations:\n\n# Save field at each iteration\nhistory = ScalarField[]\nfor iter in 1:100\n    # ... optimization step ...\n    push!(history, copy(system()))\nend\n\nfig = visualize_slider(history, (intensity, phase))\n\nCustom colormaps:\n\nfig = visualize_slider(sequence, (intensity, phase);\n                       colormap=(:inferno, :twilight),\n                       height=500)\n\nUse Cases\n\nPropagation through optical system\nOptimization convergence visualization\nWavelength sweeps\nParameter scans\nTime evolution\n\nPerformance\n\nOnly current frame is rendered (efficient for large sequences)\nSlider provides smooth navigation\nConsider downsampling very large fields if interactive response is slow\n\nNotes\n\nSlider range: 1 to length(u_vec)\nAll views update synchronously\nGLMakie required - will error with CairoMakie\n\nSee also: visualize, intensity, phase\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/plotting/#Complex-Field-Colormaps","page":"API","title":"Complex Field Colormaps","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"For complex-valued visualizations (when using identity or when function returns complex):","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Dark colormap (default): Hue=phase, Value=magnitude\nfig = visualize(u, identity; colormap=:dark)\n\n# Light colormap: Hue=phase, Saturation=magnitude\nfig = visualize(u, identity; colormap=:light)","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"HSV mapping:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Hue: Phase angle (0 to 2π → 0° to 360°)\nSaturation (light mode): Magnitude\nValue (dark mode): Magnitude","category":"page"},{"location":"api/plotting/plotting/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/plotting/plotting/#Plottable-Types","page":"API","title":"Plottable Types","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"The following can be visualized:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"ScalarField: Optical fields\nAbstractOpticalComponent: Components with 2D data (Phase, Mask, TeaDOE)\nAbstractArray{<:Number, 2}: Raw 2D arrays","category":"page"},{"location":"api/plotting/plotting/#Visualization-Functions-2","page":"API","title":"Visualization Functions","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Functions passed to visualize must:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Accept a plottable object as input\nReturn a 2D array (real, complex, or RGB)","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Common built-in functions:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"intensity(u)  # |u|² - total intensity\nphase(u)      # arg(u) - phase in radians\nreal(u)       # Re(u)\nimag(u)       # Im(u)\nabs(u)        # |u| - magnitude\nidentity(u)   # u itself (complex → HSV colormap)","category":"page"},{"location":"api/plotting/plotting/#Colormap-Selection","page":"API","title":"Colormap Selection","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Real-valued outputs: Use standard Makie colormaps (:viridis, :inferno, :twilight, etc.)\nComplex-valued outputs: Use :dark or :light for HSV mapping\nPer-view colormaps: Pass tuple matching number of views","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Valid colormaps from ColorSchemes.jl are automatically checked.","category":"page"},{"location":"api/plotting/plotting/#Layout-and-Sizing","page":"API","title":"Layout and Sizing","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"height: Control figure height (default: 200 for visualize, 400 for visualize_slider)\nWidth automatically computed to maintain aspect ratio\nMultiple views arranged in grid automatically","category":"page"},{"location":"api/plotting/plotting/#Performance","page":"API","title":"Performance","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Arrays are collected (GPU → CPU) automatically\nConsider downsampling very large fields for interactive visualization","category":"page"},{"location":"api/plotting/plotting/#Slider-Interaction","page":"API","title":"Slider Interaction","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"visualize_slider provides:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Horizontal slider to navigate through sequence\nReal-time update of all displayed views\nRequires GLMakie - interactive backend with slider support\nUseful for propagation sequences, optimization iterations, wavelength sweeps","category":"page"},{"location":"api/plotting/plotting/#Conditional-Loading","page":"API","title":"Conditional Loading","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"The Plotting module uses @require for conditional loading:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# In your script/notebook\nusing FluxOptics\nusing GLMakie  # Triggers Plotting module load\n\n# Now plotting functions are available\nvisualize(field, intensity)","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Supported Makie backends:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"GLMakie: Interactive, OpenGL-based (required for visualize_slider)\nCairoMakie: High-quality static plots (PDF/SVG export) - works with visualize only\nWGLMakie: Web-based interactive plots (for Pluto.jl, etc.) - limited slider support","category":"page"},{"location":"api/plotting/plotting/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Fields for ScalarField operations\nMakie.jl documentation for advanced plotting\nColorSchemes.jl for available colormaps","category":"page"},{"location":"tutorials/01_FoxLi_simulation/#Fox-Li-Cavity-Simulation:-Quasi-Ince-Gaussian-Mode-Formation","page":"FoxLi Simulation","title":"Fox-Li Cavity Simulation: Quasi-Ince-Gaussian Mode Formation","text":"","category":"section"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"This tutorial demonstrates the Fox-Li iterative method for finding cavity eigenmodes in a semi-degenerate laser resonator configuration. Under specific conditions, the cavity supports quasi-Ince-Gaussian modes (quasi-IGᵉ₉₃ in this case) - modes that are nearly invariant under propagation despite not being true IG eigenmodes.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"Quasi-IG vs True IG ModesTrue Ince-Gaussian modes with closed nodal lines cannot be excited with single-lobe pumping away from degeneracy: there will always exist a mode without closed nodal lines that has better overlap with the pump (gain-matching criterion). The quasi-IG patterns observed here only emerge near cavity degeneracies.For details, see: N. Barré, M. Romanelli, and M. Brunel, \"Role of cavity degeneracy for high-order mode excitation in end-pumped solid-state lasers\", Opt. Lett. 39, 1022-1025 (2014).","category":"page"},{"location":"tutorials/01_FoxLi_simulation/#Physical-Setup","page":"FoxLi Simulation","title":"Physical Setup","text":"","category":"section"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"We simulate a laser cavity with:","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"A flat mirror with gain medium (near field)\nA curved output coupler with aperture (far field)\nCavity length close to the stability boundary (semi-degenerate)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"The Fox-Li method iteratively propagates the field through the cavity until convergence to the eigenmode.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"using FluxOptics, CairoMakie\nusing Random\nRandom.seed!(15);  # Determinist example","category":"page"},{"location":"tutorials/01_FoxLi_simulation/#Initial-Field:-Speckle-Pattern","page":"FoxLi Simulation","title":"Initial Field: Speckle Pattern","text":"","category":"section"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"We start with a random speckle pattern as initial condition. This generic field contains contributions from all cavity modes - the iterative process will select the dominant eigenmode through preferential amplification.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"ns = 512, 512\nds = 4.0, 4.0\n\nλ = 1.064\nNA = 0.01\n\nw0 = 500.0\n\nspeckle_dist = generate_speckle(ns, ds, λ, NA; envelope = Gaussian(w0))\nu0 = ScalarField(speckle_dist, ds, λ)\nnormalize_power!(u0, 1e-1)\n\nvisualize(u0, (intensity, complex); colormap=(:inferno, :dark), height=120)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"(Image: Initial speckle field with Gaussian envelope)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/#Gain-Medium-Configuration","page":"FoxLi Simulation","title":"Gain Medium Configuration","text":"","category":"section"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"The gain sheet provides selective amplification with saturable gain dynamics. The off-center Gaussian pump profile (xc = 140 µm) breaks the cylindrical symmetry.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"dz = 1000.0\nIsat = 1.0\ng0m = 2e-3\nwg = 30.0\nxc = 140.0\ngain = GainSheet(u0, dz, Isat, (x, y) -> g0m * exp(-((x-xc)^2+y^2)/wg^2))\n\nvisualize(gain, identity; colormap=:inferno, show_colorbars=true, height=120)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"(Image: Gain profile - off-center Gaussian)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/#Cavity-Geometry:-Semi-Degenerate-Configuration","page":"FoxLi Simulation","title":"Cavity Geometry: Semi-Degenerate Configuration","text":"","category":"section"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"The cavity length ℓ ≈ 101 mm is close to the half-degenerate condition (ℓ = Rc/2), where the stability parameter approaches unity. This near-instability regime supports complex transverse mode structures.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"We use a magnification factor of 2 between the two mirrors to properly sample the field at both ends of the cavity.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"ℓ = 101000.0  # Close to half-degenerate cavity\n\ns = 2\nds′ = s .* ds\n\np12 = ParaxialProp(u0, ds′, ℓ; use_cache = true)  # Magnification ×2\np21 = ParaxialProp(u0, ds′, ds, ℓ; use_cache = true)\n\nhalf_cavity = gain |> p12\n\nuf = half_cavity(u0).out\n\nvisualize(uf, (intensity, complex); colormap=(:inferno, :dark), height=120)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"(Image: Initial field at output mirror plane (magnified))","category":"page"},{"location":"tutorials/01_FoxLi_simulation/#Output-Coupler:-Spherical-Mirror-with-Aperture","page":"FoxLi Simulation","title":"Output Coupler: Spherical Mirror with Aperture","text":"","category":"section"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"The output mirror has 98% reflectivity and 200 mm radius of curvature. The aperture prevents the field from overflowing the computational grid, which would lead to numerical instabilities during iteration.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"R = 0.98\nRc = 200000.0\naperture_radius = 1800.0\nmirror = TeaReflector(uf, (x, y) -> -(x^2+y^2)/(2*Rc); r = -sqrt(R))\nmirror_phase = phase(cis.(2π/λ .* get_data(mirror)))\naperture = Mask(uf, (x, y) -> x^2 + y^2 < aperture_radius^2 ? 1.0 : 0.0)\n\ncavity = half_cavity |> mirror |> aperture |> p21 |> (; inplace = true)\n\nvisualize(((mirror_phase, aperture),), real; show_colorbars=true, height=120)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"(Image: Spherical mirror phase profile (left) and circular aperture (right))","category":"page"},{"location":"tutorials/01_FoxLi_simulation/#Fox-Li-Iteration:-Eigenmode-Convergence","page":"FoxLi Simulation","title":"Fox-Li Iteration: Eigenmode Convergence","text":"","category":"section"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"We iteratively propagate the field through the complete cavity round-trip. Each iteration consists of: gain → propagation → mirror+aperture → back-propagation. After ~5000 iterations, the field converges to the cavity eigenmode.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"u0c = copy(u0)\nutmp = u0c\n\nfor i in 1:5000\n    utmp = cavity(utmp).out\nend","category":"page"},{"location":"tutorials/01_FoxLi_simulation/#Converged-Eigenmode:-Quasi-Ince-Gaussian-IGᵉ","page":"FoxLi Simulation","title":"Converged Eigenmode: Quasi-Ince-Gaussian IGᵉ₉₃","text":"","category":"section"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"The converged mode exhibits an elliptical intensity pattern reminiscent of Ince-Gaussian modes. This quasi-IG mode only exists near the cavity degeneracy point and maintains its structure approximately through propagation.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"u_near = cavity(utmp).out\nu_mirror = half_cavity(u_near).out\n\nvisualize((u_near, u_mirror), (intensity, phase);\n           colormap=(:inferno, :twilight), show_colorbars=true, height=150)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"(Image: Converged eigenmode at near field (left) and far field mirror (right))","category":"page"},{"location":"tutorials/01_FoxLi_simulation/#Far-Field-Characterization","page":"FoxLi Simulation","title":"Far-Field Characterization","text":"","category":"section"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"Propagating the eigenmode to twice the cavity length reveals the far-field intensity distribution and phase structure.","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"p_far = ParaxialProp(u_near, 2 .* ds, 2*ℓ; use_cache = true)\nu_far = propagate(u_near, p_far, Forward)\n\nvisualize(u_far, (intensity, phase);\n           colormap=(:inferno, :twilight), show_colorbars=true, height=150)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"(Image: Far-field intensity and phase at 2ℓ distance)","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"","category":"page"},{"location":"tutorials/01_FoxLi_simulation/","page":"FoxLi Simulation","title":"FoxLi Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/optimisers/optimisers/#OptimisersExt-API","page":"API","title":"OptimisersExt API","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Setup-and-Update","page":"API","title":"Setup and Update","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.make_rules","page":"API","title":"FluxOptics.OptimisersExt.make_rules","text":"make_rules(pairs::Pair{<:AbstractArray, <:AbstractRule}...)\nmake_rules(pairs::Pair{<:AbstractOpticalComponent, <:AbstractRule}...)\n\nCreate a dictionary of optimization rules for specific parameters or optical components.\n\nThis function creates an IdDict that maps parameter arrays to their corresponding optimization rules. This allows different parts of the optical system to use different optimizers (e.g., different learning rates, different algorithms).\n\nArguments\n\npairs: Pairs of (parameter/component, rule) where:\nFirst element: AbstractArray (parameter) or AbstractOpticalComponent \nSecond element: AbstractRule (optimization rule like Descent(0.01))\n\nReturns\n\nIdDict{AbstractArray, AbstractRule} mapping parameter arrays to optimization rules.\n\nExamples\n\njulia> u = ScalarField(zeros(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> phase_mask = Phase(u, (x, y) -> 0.1*(x^2 + y^2); trainable=true);\n\njulia> source = ScalarSource(u; trainable=true);\n\njulia> rules = make_rules(\n           phase_mask => Descent(0.01),    # Slow learning for phase\n           source => Descent(0.1)     # Fast learning for source\n       );\n\njulia> typeof(rules)\nIdDict{AbstractArray, Optimisers.AbstractRule}\n\njulia> length(rules)\n2\n\njulia> opt_state = setup(rules, source |> phase_mask);\n\nSee also: setup, ProxRule, Phase, ScalarSource\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#Optimisers.setup-Tuple{IdDict}","page":"API","title":"Optimisers.setup","text":"setup(rules::IdDict{<:AbstractArray, <:AbstractRule}, model)\nsetup(rules::IdDict{<:AbstractArray, <:AbstractRule}, default_rule::AbstractRule, model)\n\nSet up optimization state with different rules for different parameters.\n\nThis extends Optimisers.setup to accept a dictionary of rules, allowing fine-grained control over which optimizer is used for which parameters. Parameters not in the rules dictionary use the default rule (or NoDescent() if no default provided).\n\nArguments\n\nrules: Dictionary mapping parameter arrays to optimization rules\ndefault_rule: Default rule for parameters not in the rules dictionary\nmodel: The model/parameters to optimize\n\nReturns\n\nNested optimization state structure matching the model structure.\n\nExamples\n\njulia> u = ScalarField(zeros(ComplexF64, 32, 32), (2.0, 2.0), 1.064);\n\njulia> phase_mask = Phase(u, (x, y) -> 0.0; trainable=true);\n\njulia> mask = Mask(u, (x, y) -> 1.0; trainable=true);\n\njulia> rules = make_rules(\n           phase_mask => Descent(0.01),\n           mask => Momentum(0.1, 0.9)\n       );\n\njulia> u = ScalarField(zeros(ComplexF64, 32, 32), (2.0, 2.0), 1.064);\n\njulia> source = ScalarSource(u; trainable=true);\n\njulia> opt_state = setup(rules, NoDescent(), source |> phase_mask |> mask);\n\nSee also: make_rules, Optimisers.update!, ProxRule, NoDescent\n\n\n\n\n\n","category":"method"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Note: update!(opt_state, params, grads) is re-exported from Optimisers.jl. It applies the optimization step to update parameters. See their documentation for details.","category":"page"},{"location":"api/optimisers/optimisers/#Optimization-Rules","page":"API","title":"Optimization Rules","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Custom-Rules","page":"API","title":"Custom Rules","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.Fista","page":"API","title":"FluxOptics.OptimisersExt.Fista","text":"Fista(η)\n\nFast Iterative Shrinkage-Thresholding Algorithm (FISTA) optimizer.\n\nFISTA is an accelerated gradient method particularly effective for problems with proximal operators. It provides faster convergence than standard gradient descent for sparse and constrained optimization problems common in computational optics.\n\nArguments\n\nη: Learning rate (stored as η²)\n\nExamples\n\njulia> fista_opt = Fista(0.1);\n\njulia> sparse_rule = ProxRule(Fista(0.05), IstaProx(0.001, 0.0));  # Sparse optimization\n\nSee also: ProxRule, IstaProx, TVProx\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.NoDescent","page":"API","title":"FluxOptics.OptimisersExt.NoDescent","text":"NoDescent()\n\nNo-operation optimizer that performs no parameter updates.\n\nUseful as a default rule for parameters that should remain fixed during optimization, or for ablation studies where you want to disable optimization for certain components.\n\nExamples\n\nrules = make_rules(\n           fixed_component => NoDescent(),    # Don't optimize this\n           active_component => Descent(0.01)  # Optimize this one\n       );\n\nSee also: make_rules, setup, ProxRule\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.ProxRule","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.ProxRule","text":"ProxRule(rule::AbstractRule, prox::AbstractProximalOperator)\n\nCombine an optimization rule with a proximal operator.\n\nThis creates a composite optimization rule that first applies the standard optimization step, then applies a proximal operator for regularization or constraints. This is useful for constrained optimization in inverse optics design.\n\nArguments\n\nrule: Base optimization rule (e.g., Descent, Momentum)\nprox: Proximal operator to apply after the optimization step\n\nReturns\n\nProxRule that applies both the optimizer and proximal operator.\n\nExamples\n\njulia> prox_descent = ProxRule(Descent(0.01), PositiveProx());  # Positive constraint\n\njulia> tv_regularized = ProxRule(Momentum(0.1, 0.9), TVProx(0.001));  # TV regularization\n\njulia> clamped = ProxRule(Descent(0.05), ClampProx(0.0, 1.0));  # Clamp to [0,1]\n\nSee also: IstaProx, TVProx, ClampProx, Fista\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#From-Optimisers.jl","page":"API","title":"From Optimisers.jl","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"FluxOptics also exports standard rules from Optimisers.jl:","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Descent(η): Gradient descent with learning rate η\nMomentum(η, ρ): Momentum optimizer\nNesterov(η, ρ): Nesterov accelerated gradient","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"See Optimisers.jl documentation for more rules (Adam, AdaGrad, etc.).","category":"page"},{"location":"api/optimisers/optimisers/#Proximal-Operators","page":"API","title":"Proximal Operators","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Abstract-Type","page":"API","title":"Abstract Type","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.AbstractProximalOperator","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.AbstractProximalOperator","text":"AbstractProximalOperator\n\nAbstract base type for proximal-like operators used in constrained optimization.\n\nIn the classical sense, proximal operators implement:\n\nprox_λf(x) = argmin_z { f(z) + (1/2λ)||z - x||² }\n\nHowever, this module takes a pragmatic approach and includes:\n\nExact proximal operators: Mathematically rigorous (e.g., soft thresholding)\nProjections: Onto constraint sets (e.g., ClampProx, PositiveProx)\nPlug-and-play operators: Operators that work well empirically for inverse problems,  even without strict proximal interpretation (e.g., learned denoisers, heuristic constraints)\n\nThis flexibility follows the spirit of plug-and-play priors in computational imaging,  where practical performance often matters more than theoretical guarantees.\n\nInterface\n\nSubtypes must implement:\n\ninit(prox::AbstractProximalOperator, x::AbstractArray): Initialize operator state\napply!(prox::AbstractProximalOperator, state, x::AbstractArray): Apply operator in-place\n\nAvailable Operators\n\nPointwiseProx: Apply function element-wise (custom constraints)\nClampProx: Box constraints [a, b]\nPositiveProx: Non-negativity constraint\nIstaProx: Soft thresholding (exact prox of L1 norm)\nTVProx: Total variation denoising (approximate prox)\n\nComposition\n\nOperators can be composed with ∘:\n\ncombined = ClampProx(0.0, 1.0) ∘ PositiveProx()\n\nExamples\n\n# Use with ProxRule\nprox = ClampProx(-π, π)\nrule = ProxRule(Descent(0.01), prox)\n\n# Compose multiple constraints\nprox = ClampProx(0.0, 1.0) ∘ PositiveProx()\nrule = ProxRule(Momentum(0.1, 0.9), prox)\n\nReferences\n\nFor plug-and-play priors: Venkatakrishnan et al., \"Plug-and-Play Priors for Model Based Reconstruction\" (2013)\n\nSee also: ProxRule, IstaProx, TVProx\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#Pointwise-Operators","page":"API","title":"Pointwise Operators","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx","text":"PointwiseProx(f)\n\nApply a function pointwise as a proximal operator.\n\nCreates a proximal operator that applies function f element-wise to the parameter array. The function should take the current parameter value and return the projected/regularized value.\n\nArguments\n\nf: Function to apply element-wise\n\nExamples\n\njulia> clamp_prox = PointwiseProx(x -> clamp(x, -1, 1));\n\njulia> threshold_prox = PointwiseProx(x -> abs(x) < 0.1 ? 0 : x);\n\njulia> model = randn(10, 10);\n\njulia> prox_state = ProximalOperators.init(clamp_prox, model);\n\njulia> ProximalOperators.apply!(clamp_prox, prox_state, model);\n\njulia> all(x -> -1 ≤ x ≤ 1, model)  # All values clamped\ntrue\n\nSee also: ClampProx, PositiveProx, ProxRule\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.ClampProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.ClampProx","text":"ClampProx(lo, hi)\n\nClamp values to the range [lo, hi].\n\nSimple box constraint proximal operator that projects parameters onto a box. Useful for physically meaningful constraints (e.g., transmittance ∈ [0,1]).\n\nArguments\n\nlo: Lower bound\nhi: Upper bound\n\nExamples\n\njulia> unit_clamp = ClampProx(0.0, 1.0);  # Unit interval\n\njulia> phase_clamp = ClampProx(-π, π);    # Phase wrapping alternative\n\njulia> x = [-0.5, 0.3, 1.2, 0.8];\n\njulia> prox_state = ProximalOperators.init(unit_clamp, x);\n\njulia> ProximalOperators.apply!(unit_clamp, prox_state, x);\n\njulia> x  # Values clamped to [0,1]\n4-element Vector{Float64}:\n 0.0\n 0.3\n 1.0\n 0.8\n\nSee also: PositiveProx, ProxRule, PointwiseProx\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.PositiveProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.PositiveProx","text":"PositiveProx()\n\nProject values onto the non-negative orthant (set negative values to zero).\n\nSimple constraint for physical parameters that must be non-negative, such as intensities, thicknesses, or absorption coefficients.\n\nExamples\n\njulia> pos_prox = PositiveProx();\n\njulia> x = [-0.1, 0.0, 0.5, -0.3, 1.2];\n\njulia> prox_state = ProximalOperators.init(pos_prox, x);\n\njulia> ProximalOperators.apply!(pos_prox, prox_state, x);\n\njulia> x  # Negative values set to zero\n5-element Vector{Float64}:\n 0.0\n 0.0\n 0.5\n 0.0\n 1.2\n\nSee also: ClampProx, ProxRule, PointwiseProx\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#Sparsity-and-Regularization","page":"API","title":"Sparsity and Regularization","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.IstaProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.IstaProx","text":"IstaProx(λ, center=0)\n\nIterative Shrinkage-Thresholding (ISTA) proximal operator for sparse optimization.\n\nApplies soft thresholding to promote sparsity in the parameters. Values close to center are shrunk towards center, promoting sparse solutions.\n\nArguments\n\nλ: Shrinkage parameter (larger values → more sparsity)\ncenter=0: Center value for thresholding\n\nExamples\n\njulia> sparse_prox = IstaProx(0.01, 0.0);  # Shrink towards zero\n\njulia> x = [-0.5, -0.005, 0.0, 0.003, 0.2];\n\njulia> prox_state = ProximalOperators.init(sparse_prox, x);\n\njulia> ProximalOperators.apply!(sparse_prox, prox_state, x);\n\njulia> x  # Small values shrunk to zero\n5-element Vector{Float64}:\n -0.49\n  0.0\n  0.0\n  0.0\n  0.19\n\nSee also: PointwiseProx, ProxRule, Fista\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.TVProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.TVProx","text":"TVProx(λ, n_iter=50; tol=nothing, isotropic=true, rule=Fista(...))\n\nTotal Variation (TV) regularization proximal operator.\n\nApply total variation denoising to promote piecewise smooth solutions in n dimensions.\n\nThis works on arrays of any dimensionality: 1D signals, 2D surfaces, 3D volumes, or higher-dimensional data. Particularly useful for optical applications where smooth profiles are desired while preserving sharp edges.\n\nArguments\n\nλ: Regularization strength (larger values → smoother results)\nn_iter=50: Maximum number of internal iterations\ntol=nothing: Convergence tolerance (if provided)\nisotropic=true: Use isotropic TV (L₂ norm of gradient) vs anisotropic (L₁)\nrule: Optimization rule for internal TV solver\n\nExamples\n\njulia> tv_smooth = TVProx(0.1, 100; isotropic=false);  # Light anisotropic smoothing\n\njulia> tv_strong = TVProx(1.2, 100);  # Strong isotropic TV\n\njulia> noisy_surface = 1 .+ 0.1*randn(32, 32);\n\njulia> prox_state = ProximalOperators.init(tv_strong, noisy_surface);\n\njulia> strongly_smoothed_surface = ProximalOperators.apply!(tv_strong, prox_state, copy(noisy_surface));\n\nSee also: TV_denoise!, ProxRule\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.TV_denoise!","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.TV_denoise!","text":"TV_denoise!(x, λ, n_iter=50; tol=nothing, isotropic=true, rule=Fista(...))\n\nApply total variation denoising directly to an n-dimensional array.\n\nConvenience function that applies TV regularization without setting up the full proximal operator infrastructure. Modifies the input array in-place.\n\nArguments\n\nx: Input array to denoise (modified in-place)\nλ: Regularization strength\nn_iter=50: Maximum iterations\ntol=nothing: Convergence tolerance\nisotropic=true: Isotropic vs anisotropic TV\nrule: Optimization rule for internal TV solver\n\nReturns\n\nThe modified input array (for chaining).\n\nExamples\n\njulia> using Statistics\n\njulia> noisy = randn(64, 64) + 5 * sin.(0.1 * (1:64)) * sin.(0.1 * (1:64)');\n\njulia> original_var = var(noisy);\n\njulia> TV_denoise!(noisy, 0.1, 100);\n\njulia> denoised_var = var(noisy);\n\njulia> denoised_var < original_var  # Reduced variation\ntrue\n\njulia> # Can chain operations:\n\njulia> result = TV_denoise!(copy(noisy), 0.05) |> x -> clamp.(x, 0, 1);\n\nSee also: TVProx, ClampProx, PositiveProx\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#Optimization-Patterns","page":"API","title":"Optimization Patterns","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Sparse-Phase-Mask-Design","page":"API","title":"Sparse Phase Mask Design","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Encourage sparsity with soft thresholding\nsparse_rule = ProxRule(\n    Fista(0.01),\n    IstaProx(0.001, 0.0)  # L1 penalty\n)\n\nrules = make_rules(phase => sparse_rule)\nopt_state = setup(rules, system)","category":"page"},{"location":"api/optimisers/optimisers/#Smooth-Phase-with-TV-Regularization","page":"API","title":"Smooth Phase with TV Regularization","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Total variation for smooth phase profiles\ntv_rule = ProxRule(\n    Momentum(0.05, 0.9),\n    TVProx(0.01)  # Smoothness penalty\n)\n\nrules = make_rules(phase => tv_rule)\nopt_state = setup(rules, system)","category":"page"},{"location":"api/optimisers/optimisers/#Mixed-Optimization-Strategy","page":"API","title":"Mixed Optimization Strategy","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Different strategies for different components\nrules = make_rules(\n    phase => ProxRule(Fista(0.05), ClampProx(-π, π)),       # Constrained\n    mask => ProxRule(Momentum(0.1, 0.9), PositiveProx())    # Positive only\n)\n\nopt_state = setup(rules, Descent(0.001), system)","category":"page"},{"location":"api/optimisers/optimisers/#Freezing-Specific-Components","page":"API","title":"Freezing Specific Components","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Keep some components fixed during optimization\nrules = make_rules(\n    component_to_freeze => NoDescent()\n)\n\n# Others use default rule\nopt_state = setup(rules, Descent(0.01), system)","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Note: NoDescent() prevents parameter updates but still computes gradients. For better performance when permanently freezing components, create them with trainable=false at construction. However, this requires rebuilding the system to change trainability.","category":"page"},{"location":"api/optimisers/optimisers/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/optimisers/optimisers/#ProxRule","page":"API","title":"ProxRule","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"ProxRule combines optimization with proximal operators:","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Apply gradient step: x_temp = x - η∇f(x)\nApply proximal operator: x_new = prox(x_temp)","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"This enables constrained optimization while maintaining differentiability.","category":"page"},{"location":"api/optimisers/optimisers/#make_rules-Behavior","page":"API","title":"make_rules Behavior","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Maps components/arrays to optimization rules\nExtracts trainable arrays from components automatically\nReturns IdDict{AbstractArray, AbstractRule}\nCompatible with nested structures (OpticalSystem, sequences)","category":"page"},{"location":"api/optimisers/optimisers/#setup-with-Rules-Dictionary","page":"API","title":"setup with Rules Dictionary","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Parameters in rules dict use specified rules\nOther parameters use default rule (or NoDescent if no default)\nWarning if no trainable parameters found","category":"page"},{"location":"api/optimisers/optimisers/#Operator-Composition","page":"API","title":"Operator Composition","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Proximal operators can be composed with ∘:","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"combined = ClampProx(0.0, 1.0) ∘ PositiveProx()","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Operators applied right-to-left (like function composition). The resulting operator may not be a rigorous proximal operator but can still be used as a Plug and Play prior.","category":"page"},{"location":"api/optimisers/optimisers/#Performance","page":"API","title":"Performance","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Proximal operators work in-place when possible\nPre-allocated buffers avoid allocations\nTV denoising uses efficient iterative algorithm\nGPU-compatible (works with CuArrays)","category":"page"},{"location":"api/optimisers/optimisers/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Metrics for loss functions\nFields for field operations\nOpticalComponents for trainable components\nOptimisers.jl for more optimization algorithms","category":"page"},{"location":"api/optical_components/bulk/#Bulk-Propagators","page":"Bulk Propagators","title":"Bulk Propagators","text":"","category":"section"},{"location":"api/optical_components/bulk/","page":"Bulk Propagators","title":"Bulk Propagators","text":"Beam Propagation Method for inhomogeneous media.","category":"page"},{"location":"api/optical_components/bulk/#Overview","page":"Bulk Propagators","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/bulk/","page":"Bulk Propagators","title":"Bulk Propagators","text":"The Bulk Propagators module provides:","category":"page"},{"location":"api/optical_components/bulk/","page":"Bulk Propagators","title":"Bulk Propagators","text":"Beam Propagation Method with Angular Spectrum\nSplit-step propagation through varying refractive index\nGeometric shift propagation for comparison\nTrainable refractive index for inverse design","category":"page"},{"location":"api/optical_components/bulk/#Quick-Example","page":"Bulk Propagators","title":"Quick Example","text":"","category":"section"},{"location":"api/optical_components/bulk/","page":"Bulk Propagators","title":"Bulk Propagators","text":"using FluxOptics, CairoMakie\n\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\nu = ScalarField(LaguerreGaussian(25.0, 2, 1)(xv, yv), (1.0, 1.0), 1.064)\n\n# Graded-index medium\nthickness = 1500.0  # μm\nn_slices = 100\nr = sqrt.(xv.^2 .+ yv'.^2)\ndn = -0.008 * (r/50).^2  # Parabolic profile\ndn_3d = repeat(dn, 1, 1, n_slices)\n\nn0 = 1.5  # Bulk refractive index\nbpm = AS_BPM(u, thickness, n0, dn_3d)\nu_out = propagate(u, bpm, Forward)\n\nvisualize((u, u_out), (intensity, phase); colormap=(:inferno, :viridis), height=120)","category":"page"},{"location":"api/optical_components/bulk/#Key-Types","page":"Bulk Propagators","title":"Key Types","text":"","category":"section"},{"location":"api/optical_components/bulk/","page":"Bulk Propagators","title":"Bulk Propagators","text":"AS_BPM: BPM with Angular Spectrum propagation\nShift_BPM: BPM with geometric shifts (no diffraction)","category":"page"},{"location":"api/optical_components/bulk/#See-Also","page":"Bulk Propagators","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/bulk/","page":"Bulk Propagators","title":"Bulk Propagators","text":"Free-Space Propagators for homogeneous propagation\nCore for trainability system","category":"page"},{"location":"api/optical_components/bulk/#Index","page":"Bulk Propagators","title":"Index","text":"","category":"section"},{"location":"api/optical_components/bulk/","page":"Bulk Propagators","title":"Bulk Propagators","text":"Modules = [FluxOptics.OpticalComponents]\nPages = [\"bulk.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"api/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Visualization tools for optical fields and components.","category":"page"},{"location":"api/plotting/#Overview","page":"Plotting","title":"Overview","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"The Plotting module provides:","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Field visualization: Heatmaps for 2D optical fields\nMultiple representations: Intensity, phase, real/imaginary, complex\nStack visualization: Animated sliders for field evolution\nComponent visualization: Display phase masks, DOEs, and other 2D components\nComplex colormaps: HSV-based visualization for complex fields","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Note: This module is loaded conditionally when using Makie is called.","category":"page"},{"location":"api/plotting/#Examples","page":"Plotting","title":"Examples","text":"","category":"section"},{"location":"api/plotting/#Single-Field-Visualization","page":"Plotting","title":"Single Field Visualization","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"using FluxOptics, CairoMakie\n\n# Create Gaussian beam\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\nu = ScalarField(Gaussian(30.0)(xv, yv), (1.0, 1.0), 1.064)\n\n# Visualize intensity\nvisualize(u, intensity; height=120)","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"# Visualize phase (with quadratic phase)\nquadratic_phase =  cis.(0.002 .* (xv.^2 .+ yv'.^2))\nu_quad_phase = ScalarField(Gaussian(30.0)(xv, yv) .* quadratic_phase, (1.0, 1.0), 1.064)\nvisualize(u_quad_phase, phase; colormap=:twilight, height=120)","category":"page"},{"location":"api/plotting/#Multiple-Representations","page":"Plotting","title":"Multiple Representations","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"using FluxOptics, CairoMakie\n\n# Create vortex beam\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\ngaussian = Gaussian(30.0)(xv, yv)\nvortex = gaussian .* cis.(atan.(yv', xv))\nu_vortex = ScalarField(vortex, (1.0, 1.0), 1.064)\n\n# Show multiple views\nvisualize(u_vortex, (intensity, phase, real, imag); \n          colormap=(:inferno, :viridis, :RdBu, :RdBu), height=120)","category":"page"},{"location":"api/plotting/#Complex-Field-Visualization","page":"Plotting","title":"Complex Field Visualization","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"using FluxOptics, CairoMakie\n\n# Create Laguerre-Gaussian mode\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\nlg = LaguerreGaussian(30.0, 2, 2)\nu_lg = ScalarField(lg(xv, yv), (1.0, 1.0), 1.064)\n\n# Complex visualization with HSV colormap\nvisualize(u_lg, (identity, identity); colormap=(:dark, :light), height=120)","category":"page"},{"location":"api/plotting/#Field-Comparison","page":"Plotting","title":"Field Comparison","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"using FluxOptics, CairoMakie\n\n# Create initial and propagated fields\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\nu_initial = ScalarField(Gaussian(20.0)(xv, yv), (1.0, 1.0), 1.064)\nu_prop = propagate(u_initial, ASProp(u_initial, 1000.0), Forward)\n\n# Compare side by side\nvisualize((u_initial, u_prop), (intensity, phase);\n          colormap=(:inferno, :viridis), height=120)","category":"page"},{"location":"api/plotting/#Component-Visualization","page":"Plotting","title":"Component Visualization","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"using FluxOptics, CairoMakie\n\n# Create phase mask\nxv, yv = spatial_vectors(256, 256, 2.0, 2.0)\nu = ScalarField(ones(ComplexF64, 256, 256), (2.0, 2.0), 1.064)\n\n# Quadratic phase mask\nphase_mask = Phase(u, (x, y) -> 0.001*(x^2 + y^2))\n\n# Visualize the component directly\nvisualize(phase_mask, (identity, x -> phase(cis.(x))); show_colorbars=true, height=120)","category":"page"},{"location":"api/plotting/#Multi-Mode-Fields","page":"Plotting","title":"Multi-Mode Fields","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"using FluxOptics, CairoMakie\n\n# Create Hermite-Gaussian modes\nxv, yv = spatial_vectors(128, 128, 1.0, 1.0)\nhg00 = HermiteGaussian(15.0, 0, 0)(xv, yv, Shift2D(-15.0, 0))\nhg10 = HermiteGaussian(15.0, 1, 0)(xv, yv)\nhg01 = HermiteGaussian(15.0, 0, 1)(xv, yv)\nhg11 = HermiteGaussian(15.0, 1, 1)(xv, yv, Shift2D(20.0, 0) ∘ Rot2D(π/4))\n\n# Stack modes\nmodes = cat(hg00, hg10, hg01, 1.3*hg11; dims=3)\nu_modes = ScalarField(modes, (1.0, 1.0), 1.064)\n\n# Total intensity\nvisualize(u_modes, intensity; colormap=:inferno, height=120)","category":"page"},{"location":"api/plotting/#Propagation-Sequence","page":"Plotting","title":"Propagation Sequence","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"using FluxOptics, CairoMakie\n\n# Create propagation sequence\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\nu0 = ScalarField(Gaussian(20.0)(xv, yv), (1.0, 1.0), 1.064)\n\n# Propagate at different distances\ndistances = [0, 100, 500, 1000, 2000]\npropagation = [propagate(u0, ASProp(u0, z), Forward) for z in distances]\n\n# Visualize evolution\nvisualize(propagation, (intensity, phase); colormap=(:inferno, :twilight), height=120)","category":"page"},{"location":"api/plotting/#Key-Functions","page":"Plotting","title":"Key Functions","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"visualize: Display field(s) with specified representation(s)\nvisualize_slider: Interactive slider for field sequences (requires GLMakie)","category":"page"},{"location":"api/plotting/#Visualization-Functions","page":"Plotting","title":"Visualization Functions","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Common functions for field visualization:","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"intensity: Total intensity |u|²\nphase: Phase angle\nreal: Real part\nimag: Imaginary part\nabs: Magnitude\nidentity / complex: Complex field with HSV colormap","category":"page"},{"location":"api/plotting/#See-Also","page":"Plotting","title":"See Also","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Fields for ScalarField type\nMakie.jl for plotting backend documentation","category":"page"},{"location":"api/plotting/#Index","page":"Plotting","title":"Index","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Modules = [FluxOptics.Plotting]\nOrder = [:type, :function]","category":"page"},{"location":"tutorials/02_field_retrieval/#Field-Retrieval:-Reconstructing-Complex-Fields-from-Intensity-Measurements","page":"Field Retrieval","title":"Field Retrieval: Reconstructing Complex Fields from Intensity Measurements","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"This tutorial demonstrates phase retrieval using gradient-based optimization. From intensity-only measurements in two planes, we reconstruct the full complex field (amplitude and phase) using automatic differentiation.","category":"page"},{"location":"tutorials/02_field_retrieval/#The-Phase-Problem","page":"Field Retrieval","title":"The Phase Problem","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"Standard detectors measure only intensity |u|², losing phase information. However, with measurements at multiple propagation distances, the complex field can be recovered through optimization - a generalization of the Gerchberg-Saxton algorithm using gradients rather than alternating projections.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"using FluxOptics, Zygote, CairoMakie\nusing Random\nRandom.seed!(15);  # Determinist example","category":"page"},{"location":"tutorials/02_field_retrieval/#Ground-Truth:-Laguerre-Gaussian-Mode","page":"Field Retrieval","title":"Ground Truth: Laguerre-Gaussian Mode","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"We create a high-order LG mode as our target field. This will serve as the ground truth - we'll measure its intensity at two planes, then attempt to reconstruct the complex field from these measurements alone.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"ns = 512, 512\nds = 2.0, 2.0\nx_vec, y_vec = spatial_vectors(ns, ds)\n\nλ = 1.064\nz1 = 5000.0\nz2 = 15000.0\n\nw0 = 50.0\nm, n = 2, 3\n\nu0_th = LaguerreGaussian(w0, m, n; kind = :odd)(x_vec, y_vec)\nu1_th = LaguerreGaussian(w0, m, n, λ, z1; kind = :odd)(x_vec, y_vec)\nu2_th = LaguerreGaussian(w0, m, n, λ, z2; kind = :odd)(x_vec, y_vec)\n\nvisualize(((u0_th, u1_th, u2_th),), intensity; colormap=:inferno, height=120)","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"(Image: Ground truth LG mode at z=0, z₁, and z₂)","category":"page"},{"location":"tutorials/02_field_retrieval/#Intensity-Measurements","page":"Field Retrieval","title":"Intensity Measurements","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"In a real experiment, we would measure only the intensity at two planes. Here we simulate these measurements from our known ground truth.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"I1 = abs.(u1_th) .^ 2\nI2 = abs.(u2_th) .^ 2\n\n@assert isapprox(sum(I1)*prod(ds), 1; atol = 1e-7)  # Power normalized to unity\n@assert isapprox(sum(I2)*prod(ds), 1; atol = 1e-7)  # Power normalized to unity\n\n\nvisualize(((I1, I2),), real; colormap=:inferno, height=120)","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"(Image: Intensity measurements at z₁=5mm and z₂=15mm)","category":"page"},{"location":"tutorials/02_field_retrieval/#Initial-Guess:-Random-Speckle","page":"Field Retrieval","title":"Initial Guess: Random Speckle","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"We start from a random speckle pattern - a generic field with no knowledge of the target mode. The optimization will transform this into the LG mode.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"NA = 0.01\nspeckle_dist = generate_speckle(ns, ds, λ, NA; envelope = Gaussian(3*w0))\nu0 = ScalarField(speckle_dist, ds, λ)\n\nvisualize(u0, (intensity, complex); colormap=(:inferno, :dark), height=120)","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"(Image: Initial random speckle field)","category":"page"},{"location":"tutorials/02_field_retrieval/#Optical-System-Setup","page":"Field Retrieval","title":"Optical System Setup","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"We construct the propagation system with probes to capture fields at measurement planes. The source field is trainable - its complex values will be optimized.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"p1 = RSProp(u0, z1; use_cache = true)\np2 = RSProp(u0, z2-z1; use_cache = true)\n\ns = ScalarSource(u0; trainable = true, buffered = true)\nfp1 = FieldProbe()\nfp2 = FieldProbe()\n\nsystem = s |> p1 |> fp1 |> p2 |> fp2 |> (; inplace = true);","category":"page"},{"location":"tutorials/02_field_retrieval/#Loss-Function","page":"Field Retrieval","title":"Loss Function","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"We minimize the difference between predicted and measured intensities using a correlation-based metric. The loss is defined as 2 - (correlation₁ + correlation₂), where perfect reconstruction gives loss = 0.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"sI1 = sqrt.(I1)\nsI2 = sqrt.(I2)\neps = 1e-15 * maximum(I1)\n\nfunction f_opt(m)\n    _, probes = m()\n    u1 = probes[fp1]\n    u2 = probes[fp2]\n    (2 -\n     (dot(sqrt.(abs2.(u1.electric) .+ eps), sI1) +\n      dot(sqrt.(abs2.(u2.electric) .+ eps), sI2)) * prod(ds))\nend","category":"page"},{"location":"tutorials/02_field_retrieval/#Optimization","page":"Field Retrieval","title":"Optimization","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"We use FISTA (Fast Iterative Shrinkage-Thresholding Algorithm) with gradient-based optimization. The non-convex nature of phase retrieval means convergence can take many iterations, with the optimizer navigating through local minima. Power normalization at each step prevents divergence.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"opt = setup(Fista(1), system)\n\nfill!(s, u0)\nlosses = Float64[]\n\nfor i in 1:1000\n    val, grads = Zygote.withgradient(f_opt, system)\n    FluxOptics.update!(opt, system, grads[1])\n    normalize_power!(get_source(s), 1)  # Power normalization to avoid divergence\n    push!(losses, val)\nend","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"The convergence curve reveals the non-convex nature of the phase retrieval problem, with several plateaus before reaching the global minimum.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"(Image: Convergence showing non-convex optimization landscape with multiple plateaus)","category":"page"},{"location":"tutorials/02_field_retrieval/#Reconstructed-Field","page":"Field Retrieval","title":"Reconstructed Field","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"After optimization, we extract the reconstructed field and propagated versions at the measurement planes. The complex field structure (intensity and phase) is successfully recovered from intensity-only measurements.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"_, probes = system()\nu1 = probes[fp1]\nu2 = probes[fp2]\n\nvisualize((s, u1, u2), (intensity, phase);\n           colormap=(:inferno, :twilight), show_colorbars=true, height=150)","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"(Image: Reconstructed field at z=0, z₁, and z₂ - intensity (top) and phase (bottom))","category":"page"},{"location":"tutorials/02_field_retrieval/#Reconstruction-Quality","page":"Field Retrieval","title":"Reconstruction Quality","text":"","category":"section"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"We quantify reconstruction quality using coupling efficiency - the overlap integral between reconstructed and true fields. Values above 99% indicate excellent reconstruction.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"Plane Coupling Efficiency\nz = 0 99.995%\nz₁ = 5 mm 99.995%\nz₂ = 15 mm 99.995%","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"The reconstruction achieves >99.99% coupling efficiency, demonstrating accurate recovery of both amplitude and phase from intensity measurements alone.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"Extension to Noisy MeasurementsWith realistic measurement noise, regularization techniques such as Total Variation (TV) or support constraints become necessary. The core optimization framework remains the same, with proximal operators added to the optimization rule.","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"","category":"page"},{"location":"tutorials/02_field_retrieval/","page":"Field Retrieval","title":"Field Retrieval","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/optical_components/active/#Active-Media","page":"Active Media","title":"Active Media","text":"","category":"section"},{"location":"api/optical_components/active/","page":"Active Media","title":"Active Media","text":"Gain and amplification components.","category":"page"},{"location":"api/optical_components/active/#Overview","page":"Active Media","title":"Overview","text":"","category":"section"},{"location":"api/optical_components/active/","page":"Active Media","title":"Active Media","text":"The Active Media module provides trainable saturable gain sheets for laser amplifiers.","category":"page"},{"location":"api/optical_components/active/#Quick-Example","page":"Active Media","title":"Quick Example","text":"","category":"section"},{"location":"api/optical_components/active/","page":"Active Media","title":"Active Media","text":"using FluxOptics, CairoMakie\n\nλ = 1.064\nspeckle_dist = generate_speckle((256, 256), (1.0, 1.0), λ, 0.05)\nu = ScalarField(speckle_dist, (1.0, 1.0), λ)\n\n# Pumped region (Gaussian)\ngain_pumped = GainSheet(u, 1.5, 1.0, (x, y) -> exp(-((x-50)^2 + y^2)/50^2))\n\nsource = ScalarSource(u)\n\n# Use in system\nsystem = source |> gain_pumped\n\nu_out = system().out\n\nvisualize((u, u_out), (intensity, complex); colormap=(:inferno, :dark), height=120)","category":"page"},{"location":"api/optical_components/active/#Key-Types","page":"Active Media","title":"Key Types","text":"","category":"section"},{"location":"api/optical_components/active/","page":"Active Media","title":"Active Media","text":"GainSheet: Saturable gain medium","category":"page"},{"location":"api/optical_components/active/#See-Also","page":"Active Media","title":"See Also","text":"","category":"section"},{"location":"api/optical_components/active/","page":"Active Media","title":"Active Media","text":"Modulators for phase and amplitude modulation\nCore for component interface","category":"page"},{"location":"api/optical_components/active/#Index","page":"Active Media","title":"Index","text":"","category":"section"},{"location":"api/optical_components/active/","page":"Active Media","title":"Active Media","text":"Modules = [FluxOptics.OpticalComponents]\nPages = [\"active_media.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Waveguide-Tomography:-Cross-Section-Reconstruction","page":"Waveguide Tomography","title":"Waveguide Tomography: Cross-Section Reconstruction","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"This tutorial demonstrates tomographic reconstruction of the refractive index profile of a photoinscribed waveguide in glass. By measuring the transmitted intensity at multiple illumination angles, we reconstruct the 2D cross-section of the waveguide using angular spectrum beam propagation and inverse optimization.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"ReferenceThis tutorial follows the approach described in: N. Barré, R. Shivaraman, L. Ackermann, S. Moser, M. Schmidt, P. Salter, M. Booth, and A. Jesacher, \"Tomographic refractive index profiling of direct laser written waveguides\", Opt. Express 29, 35414-35425 (2021).","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Unlike traditional tomography based on the Born or Rytov approximations, this approach uses full wave propagation through the sample with accelerated proximal gradient descent. This handles strong refractive index contrasts and gradients without approximation. A key feature is joint estimation of optical aberrations alongside the refractive index profile, which is critical for using high-angle data and achieving accurate reconstructions.","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Physical-Setup","page":"Waveguide Tomography","title":"Physical Setup","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"The waveguide is invariant along the propagation direction (y), allowing us to treat it as a 2D problem. We illuminate the sample at different angles θ and measure the transmitted intensity pattern. The angular diversity provides the tomographic information needed to reconstruct the refractive index profile Δn(x,z).","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"using FluxOptics, Zygote, CairoMakie\nusing JLD","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Experimental-Data","page":"Waveguide Tomography","title":"Experimental Data","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"We load the measured intensity map I(x,θ) showing the transmitted field intensity as a function of transverse position x and illumination angle θ. The data comes from a photoinscribed waveguide in borosilicate glass.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"data = \"docs/literate/data\"\n\ntomogram_data = load(\"$(data)/tomogram_guide_b.jld\")\n\ndx = tomogram_data[\"dx\"]              # Pixel size (μm)\nI_measured = tomogram_data[\"I\"]       # Intensity map I(x,θ)\nθ_angles = tomogram_data[\"θ_l\"];      # Illumination angles (rad)","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Visualize the full measured tomogram showing intensity variation with angle","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"fig_full = Figure(size = (380, 300))\nax = Axis(fig_full[1, 1], xlabel = \"Angle θ (°)\", ylabel = \"Position x (μm)\", aspect = 1.1)\nhm = heatmap!(ax, rad2deg.(θ_angles), (0:size(I_measured, 1)-1) .* dx, I_measured')\nColorbar(fig_full[1, 2], hm)\nfig_full","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"(Image: Full measured tomogram showing intensity vs angle and position)","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Angular-Selection","page":"Waveguide Tomography","title":"Angular Selection","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"We select a subset of angles around normal incidence (θ ≈ 0) for reconstruction. Each angle provides a different view of the waveguide structure. The intensities are normalized to unit power at each angle.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"angle_indices = (25 - 20):1:(25 + 22)\nθ_selected = θ_angles[angle_indices]\nI_selected = I_measured[:, angle_indices]\nI_selected .*= size(I_selected, 1) ./ sum(I_selected, dims = 1)\n\nnx = size(I_selected, 1)\nn_angles = length(θ_selected);","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Visualize the selected angular range used for reconstruction","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"fig_selected = Figure(size = (380, 300))\nax = Axis(fig_selected[1, 1], xlabel = \"Angle θ (°)\", ylabel = \"Position x (μm)\", aspect = 1.1)\nhm = heatmap!(ax, rad2deg.(θ_selected), (0:nx-1) .* dx, I_selected')\nColorbar(fig_selected[1, 2], hm)\nfig_selected","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"(Image: Selected angular range for reconstruction)","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Forward-Model:-Beam-Propagation-Through-Sample","page":"Waveguide Tomography","title":"Forward Model: Beam Propagation Through Sample","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"We construct the optical system modeling wave propagation through the waveguide. The system consists of:","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Multi-angle plane wave illumination with tilts θ\nAS-BPM propagation through the sample (trainable refractive index)\nFree-space propagation with NA-limited collection aperture\nAberration correction using a Fourier-space phase basis","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"n_bulk = 1.52        # Bulk refractive index of glass\nλ = 0.455            # Blue illumination wavelength (μm)\nNA = 1.4             # Numerical aperture of collection optics\nnz = 300             # Number of propagation steps\nL_sample = 20        # Sample thickness (μm)\nΔn_initial = zeros(nx, nz);  # Initial refractive index perturbation","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Create multi-angle source field","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"u0 = ScalarField((nx, n_angles), (dx,), λ; tilts = (θ_selected,))\nfill!(u0, 1)\ns = ScalarSource(u0);","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Beam propagation through sample (trainable)","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"sample = AS_BPM(u0, L_sample, n_bulk, Δn_initial;\n                use_cache = false, trainable = true, buffered = true);","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"NA-limited collection aperture","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"make_diaphragm(NA, λ) = fx -> abs(fx) <= abs(NA/λ) ? true : false\n\nΔz_propagation = -6  # Free-space propagation distance (μm)\np_collection = ASProp(u0, Δz_propagation; n0 = n_bulk,\n                      filter = make_diaphragm(NA, λ),\n                      use_cache = false);  # Small data: cache slower than recompute","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Aberration-Correction","page":"Waveguide Tomography","title":"Aberration Correction","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Optical aberrations in the collection path (e.g., from refractive index mismatch between sample and immersion medium) are modeled using a radial polynomial basis in Fourier space. We jointly estimate these aberrations alongside the refractive index profile - a form of blind deconvolution.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"This joint estimation is crucial: the paper shows that neglecting aberrations produces significant artifacts in the reconstructed index profile, especially when using high-angle illumination data. The radial polynomial basis (even orders up to 16th) captures spherical-like aberrations common in high-NA imaging systems.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"spatial_freq_offsets = sin.(θ_selected) .* (n_bulk/λ)\n\nfunction radial_polynomial(fx, f0, λ, NA, p)\n    abs(fx + f0) <= abs(NA/λ) ? (abs(fx + f0) * λ / NA)^(2*p) : 0.0\nend\n\naberration_mask = FourierPhase(u0, zeros(nx, n_angles);\n                               trainable = true, buffered = true);\n\nn_basis = 8\nbasis_functions = make_fourier_basis((fx, f0, p) -> radial_polynomial(fx, f0, λ, NA, p),\n                                     (nx,), (dx,), spatial_freq_offsets, (1:n_basis)')\naberration_wrapper = BasisProjectionWrapper(aberration_mask, basis_functions,\n                                            zeros(n_basis));","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Complete optical system","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"system = s |> sample |> p_collection |> aberration_wrapper |>\n         (; inplace = true, merge_components = true);","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Loss-Function-and-Optimization-Setup","page":"Waveguide Tomography","title":"Loss Function and Optimization Setup","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"We minimize the squared difference between measured and simulated intensities. The waveguide refractive index and aberration coefficients are jointly optimized.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"For regularization, we use ISTA (Iterative Shrinkage-Thresholding Algorithm) which promotes sparsity in the reconstruction. This is simpler than the TV-norm regularization used in the original paper, and produces smoother profiles without the \"staircase\" artifacts characteristic of total variation methods.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"I_target = similar(u0.electric, real(eltype(u0)))\ncopyto!(I_target, I_selected)\n\nintensity_metric = SquaredIntensityDifference((u0, I_target));\n\nf_opt = m -> sum(intensity_metric(m().out));","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Initialize trainable components","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"fill!(sample, 0)\nfill!(aberration_wrapper, 0)\nfill!(aberration_mask, 0);","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Separate optimization rules for sample and aberrations","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"sample_rule = ProxRule(Fista(0.01), IstaProx(3e-5))  # ISTA regularization\naberration_rule = Fista(0.03)\n\nrules_dict = make_rules(sample => sample_rule,\n                        aberration_wrapper => aberration_rule)\n\nopt = FluxOptics.setup(rules_dict, system)","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Reconstruction-Loop","page":"Waveguide Tomography","title":"Reconstruction Loop","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"We run 50 iterations of FISTA with proximal regularization. The algorithm alternates between updating the refractive index profile and correcting for optical aberrations, progressively refining the tomographic reconstruction.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"losses = Float64[]\n\nfor i in 1:50\n    val, grads = Zygote.withgradient(f_opt, system)\n    FluxOptics.update!(opt, system, grads[1])\n    push!(losses, val)\nend","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Convergence curve showing reconstruction progress","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"fig_loss = Figure(size = (380, 300))\nax = Makie.Axis(fig_loss[1, 1], yscale = log10, xlabel = \"Iteration\", ylabel = \"Loss\")\nlines!(ax, losses; linewidth = 2)\nfig_loss","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"(Image: Convergence of tomographic reconstruction)","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Reconstructed-Intensity-Pattern","page":"Waveguide Tomography","title":"Reconstructed Intensity Pattern","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"The optimized forward model closely matches the measured intensities across all angles, validating the reconstruction accuracy.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"I_reconstructed = abs2.(collect(system().out))\n\nfig_recon_intensity = Figure(size = (380, 300))\nax = Axis(fig_recon_intensity[1, 1],\n           xlabel = \"Angle θ (°)\", ylabel = \"Position x (μm)\", aspect = 1.1)\nI_reconstructed = abs2.(collect(system().out))\nhm = heatmap!(ax, rad2deg.(θ_selected), (0:nx-1) .* dx, I_reconstructed')\nColorbar(fig_recon_intensity[1, 2], hm)\nfig_recon_intensity","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"(Image: Reconstructed intensity pattern matching measurements)","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Refractive-Index-Profile","page":"Waveguide Tomography","title":"Refractive Index Profile","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"The reconstructed 2D refractive index perturbation Δn(x,z) reveals the waveguide cross-section. The computational domain was chosen large enough to accommodate high-angle illumination without edge effects. We now crop to the central region containing the waveguide for visualization. The photoinscribed region shows increased refractive index, characteristic of direct laser writing in glass.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"n_trim = 550  # Crop to central region containing the waveguide\nΔn_reconstructed = collect(sample)[(1 + n_trim):(end - n_trim), end:-1:1]\n\nfig_profile = Figure(size = (420, 300))\nax = Axis(fig_profile[1, 1], xlabel = \"Position x (μm)\", ylabel = \"Depth z (μm)\")\nhm = heatmap!(ax, (0:(nx - 2*n_trim - 1)) .* dx, (0:(nz-1)) .* (L_sample/nz), Δn_reconstructed)\nax.aspect = DataAspect()\nylims!(ax, L_sample, 0)\nColorbar(fig_profile[1, 2], hm, label = \"Δn\")\nfig_profile","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"(Image: Reconstructed refractive index profile Δn(x,z) of the photoinscribed waveguide)","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Recovered-Aberration-Profile","page":"Waveguide Tomography","title":"Recovered Aberration Profile","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"The optimization also recovers the optical aberration profile as a function of numerical aperture. The radial polynomial basis captures symmetric aberrations in the collection optics. The phase correction is valid within the collection NA window (shown by red dashed lines).","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"NA_range = (-NA):0.01:NA\nfx_range = NA_range ./ λ\ncoefficients = collect(aberration_wrapper)\naberration_phase = sum([coefficients[i] * radial_polynomial.(fx_range, 0, λ, NA, p)\n                        for (i, p) in enumerate(1:n_basis)])\n\nfig_aberration = Figure(size = (380, 280))\nax = Axis(fig_aberration[1, 1], xlabel = \"Numerical Aperture\", ylabel = \"Phase (rad)\",\n          xticks = ([-NA, 0, NA], [\"-NA\", \"0\", \"NA\"]))\nlines!(ax, NA_range, aberration_phase; linewidth = 2)\nvlines!(ax, [NA, -NA]; linestyle = :dash, color = :red, linewidth = 1.5)\nfig_aberration","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"(Image: Reconstructed aberration profile as a function of numerical aperture)","category":"page"},{"location":"tutorials/04_waveguide_tomography/#Summary","page":"Waveguide Tomography","title":"Summary","text":"","category":"section"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"This tomographic reconstruction demonstrates several key capabilities:","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Full wave propagation: Unlike Born/Rytov approximations, we use full angular spectrum beam propagation, handling strong index contrasts accurately.\nJoint optimization: Simultaneous reconstruction of refractive index profile and optical aberrations (blind deconvolution) enables use of high-angle data.\nModern optimization: FISTA with proximal operators provides efficient convergence. ISTA regularization produces smooth profiles without the staircase artifacts of TV-norm methods used in earlier implementations.\nQuantitative imaging: The method achieves sub-micrometer spatial resolution and can detect refractive index changes below 10⁻³, essential for characterizing photoinscribed optical structures.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"Applications include optical metrology, waveguide characterization for integrated photonics, quality control in direct laser writing, and quantitative phase imaging of phase objects.","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"","category":"page"},{"location":"tutorials/04_waveguide_tomography/","page":"Waveguide Tomography","title":"Waveguide Tomography","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n  <img src=\"assets/logo_large.svg\" alt=\"FluxOptics.jl\" width=\"600\"/>\n</p>","category":"page"},{"location":"#FluxOptics.jl","page":"Home","title":"FluxOptics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differentiable optical propagation and inverse design in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"FluxOptics.jl is a Julia package for simulating scalar optical field propagation with full support for automatic differentiation. Design and optimize optical systems through gradient-based methods.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🌊 Scalar field propagation: Angular Spectrum, Rayleigh-Sommerfeld, Collins integral, Beam Propagation Method\n🎭 Optical components: Phase masks, amplitude masks, DOEs, graded-index media\n🎯 Optimization ready: Fully differentiable with Zygote/Enzyme support via ChainRulesCore\n🔧 Proximal operators: TV regularization, sparsity, constraints\n📊 Built-in metrics: Power coupling, field matching, intensity shaping\n🚀 GPU support: CUDA acceleration available","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using FluxOptics, CairoMakie\n\n# 1. Create Gaussian source\ngaussian = Gaussian(20.0)\nxv, yv = spatial_vectors(256, 256, 1.0, 1.0)\nu = ScalarField(gaussian(xv, yv), (1.0, 1.0), 1.064)\nsource = ScalarSource(u)\n\n# 2. Optical system with vortex phase mask\nprobe = FieldProbe()\nvortex_phase = Phase(u, (x, y) -> atan(y, x))  # topological charge l=1\npropagator = ASProp(u, 1000.0)  # 1mm far-field propagation\n\nsystem = source |> vortex_phase |> probe |> propagator\n\n# 3. Execute system\nresult = system()\noutput_mode = result.out\nprobe_mode = result.probes[probe]\n\n# 4. Visualize evolution\nvisualize((probe_mode, output_mode), (intensity, phase);\n\tcolormap=(:inferno, :viridis), show_colorbars=true, height=120)","category":"page"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Learn FluxOptics through practical examples covering inverse design and optical simulation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fox-Li Cavity Simulation: Find cavity eigenmodes in a semi-degenerate laser resonator. Demonstrates iterative simulation, gain media, and quasi-Ince-Gaussian mode formation near degeneracy points.\nPhase Retrieval from Intensity: Reconstruct complex optical fields from intensity-only measurements. Shows gradient-based optimization, multi-plane propagation, and handling non-convex inverse problems.\nMulti-Wavelength Beam Shaping: Design chromatic diffractive optical elements that independently control red, green, and blue beams. Illustrates wavelength-dependent optimization and cascaded DOE systems.\nWaveguide Tomography: Reconstruct refractive index profiles of photoinscribed waveguides from angle-resolved intensity data. Demonstrates full-wave tomography with joint aberration estimation.","category":"page"},{"location":"#[API-Reference](api/index.md)","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Complete documentation of all modules, types, and functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"GridUtils: Coordinate systems and transformations\nModes: Gaussian beams, HG/LG modes, spatial layouts\nFields: ScalarField type and field operations\nOptical Components: Propagators, masks, sources, systems\nOptimisersExt: Optimization rules and proximal operators\nMetrics: Loss functions for inverse design","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"📖 Browse the API Reference for detailed function documentation\n💬 Open an issue on GitHub for bugs or feature requests\n📧 Contact the maintainers for questions","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use FluxOptics.jl in your research, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{fluxoptics2025,\n  author = {Barré, Nicolas},\n  title = {FluxOptics.jl: Differentiable Optical Simulations},\n  year = {2025},\n  url = {https://github.com/anscoil/FluxOptics.jl}\n}","category":"page"},{"location":"api/optimisers/#OptimisersExt","page":"OptimisersExt","title":"OptimisersExt","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"Optimization rules and proximal operators for constrained inverse design.","category":"page"},{"location":"api/optimisers/#Overview","page":"OptimisersExt","title":"Overview","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"The OptimisersExt module extends Optimisers.jl with:","category":"page"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"Custom optimization rules: FISTA, NoDescent\nProximal operators: Constraints and regularization (TV, sparsity, clamping)\nPer-parameter rules: Different optimizers for different components\nProximal-gradient methods: Combine optimization with constraints","category":"page"},{"location":"api/optimisers/#Quick-Example","page":"OptimisersExt","title":"Quick Example","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"using FluxOptics\n\n# Define source\nxv, yv = spatial_vectors(128, 128, 1.0, 1.0)\nu = ScalarField(Gaussian(20.0)(xv, yv), (1.0, 1.0), 1.064)\nsource = ScalarSource(u)\n\n# Define optical components\nphasemask = Phase(u, (x, y) -> 0.0; trainable=true)\nmask = FourierMask(u, (fx, fy) -> 1.0; trainable=true)\n\n# Define optical system\nsystem = source |> phasemask |> mask\n\n# Per-component optimization rules\nrules = make_rules(\n    phasemask => ProxRule(Descent(0.01), ClampProx(-π, π)),  # Constrained phase\n    mask => Momentum(0.1, 0.9)                               # Momentum for mask\n)\n\n# Setup\nopt_state = setup(rules, system)","category":"page"},{"location":"api/optimisers/#Key-Types","page":"OptimisersExt","title":"Key Types","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"ProxRule: Combine optimizer with proximal operator\nFista: Fast iterative shrinkage-thresholding\nNoDescent: No-op optimizer for fixed parameters","category":"page"},{"location":"api/optimisers/#Proximal-Operators","page":"OptimisersExt","title":"Proximal Operators","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"IstaProx: Soft thresholding for sparsity\nTVProx: Total variation regularization\nClampProx: Box constraints\nPositiveProx: Non-negativity constraint\nPointwiseProx: Custom element-wise constraints","category":"page"},{"location":"api/optimisers/#Key-Functions","page":"OptimisersExt","title":"Key Functions","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"make_rules: Create per-parameter optimization rules\nsetup: Initialize optimization state with custom rules\nupdate!: Apply optimization step (from Optimisers.jl)","category":"page"},{"location":"api/optimisers/#See-Also","page":"OptimisersExt","title":"See Also","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"Typical Workflow - Complete example of building and optimizing an optical system\nMetrics for loss functions\nOptimisers.jl for base optimization algorithms","category":"page"},{"location":"api/optimisers/#Index","page":"OptimisersExt","title":"Index","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"Modules = [FluxOptics.OptimisersExt, FluxOptics.OptimisersExt.ProximalOperators]\nOrder = [:type, :function]","category":"page"}]
}
