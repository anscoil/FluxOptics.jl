var documenterSearchIndex = {"docs":
[{"location":"api/metrics/#Metrics","page":"Metrics","title":"Metrics","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Metric types for inverse design optimization.","category":"page"},{"location":"api/metrics/#Overview","page":"Metrics","title":"Overview","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"The Metrics module provides:","category":"page"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Metric types: Object-oriented approach to optimization objectives\nField overlap: DotProduct and PowerCoupling metrics\nField matching: SquaredFieldDifference for complex field matching\nIntensity matching: SquaredIntensityDifference for intensity-based objectives\nAD-compatible: Automatic differentiation support via custom gradients","category":"page"},{"location":"api/metrics/#Quick-Example","page":"Metrics","title":"Quick Example","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"using FluxOptics\n\n# Create target field\ntarget = ScalarField(target_data, (2.0, 2.0), 1.064)\n\n# Power coupling metric\nmetric = PowerCoupling(target)\n\n# Evaluate on current field\nu_current = system()\nloss = metric(u_current)  # Returns power coupled to target\n\n# Use in optimization\nfunction objective()\n    u = system()\n    1.0 - metric(u)[]  # Maximize coupling\nend","category":"page"},{"location":"api/metrics/#Key-Types","page":"Metrics","title":"Key Types","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"DotProduct: Complex overlap integral ⟨u,v⟩\nPowerCoupling: Power coupled to target mode(s)\nSquaredFieldDifference: |u - v|² field matching\nSquaredIntensityDifference: |Iu - Iv|² intensity matching","category":"page"},{"location":"api/metrics/#Key-Functions","page":"Metrics","title":"Key Functions","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"(AbstractMetric): Callable interface (preferred) - evaluate metric\nFluxOptics.Metrics.compute_metric: Explicit evaluation function\nFluxOptics.Metrics.backpropagate_metric: Gradient computation (internal)","category":"page"},{"location":"api/metrics/#See-Also","page":"Metrics","title":"See Also","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"OptimisersExt for optimization algorithms","category":"page"},{"location":"api/metrics/#Index","page":"Metrics","title":"Index","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Modules = [FluxOptics.Metrics]\nOrder = [:type, :function]","category":"page"},{"location":"api/metrics/metrics/#Metrics-API","page":"API","title":"Metrics API","text":"","category":"section"},{"location":"api/metrics/metrics/#Abstract-Types","page":"API","title":"Abstract Types","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.AbstractMetric","page":"API","title":"FluxOptics.Metrics.AbstractMetric","text":"AbstractMetric\n\nAbstract base type for optimization metrics in inverse optics design.\n\nMetrics are callable objects that evaluate optimization objectives on optical fields. They encapsulate target references and pre-allocated buffers for efficient gradient computation during iterative optimization.\n\nInterface\n\nSubtypes must implement:\n\ncompute_metric(m::AbstractMetric, u::NTuple{N, ScalarField}): Evaluate metric\nbackpropagate_metric(m::AbstractMetric, u::NTuple{N, ScalarField}, ∂c): Compute gradients\n\nCallable Interface\n\nAll metrics are callable:\n\nmetric = PowerCoupling(target)\nloss = metric(u)                    # Single field\nlosses = metric(u1, u2)             # Multiple fields\n\nAvailable Metrics\n\nDotProduct: Complex overlap integral ⟨u,v⟩\nPowerCoupling: Power coupled to target modes\nSquaredFieldDifference: Field amplitude/phase matching\nSquaredIntensityDifference: Intensity pattern matching\n\nDesign Philosophy\n\nStateful: Pre-allocate buffers at construction for zero-allocation evaluation\nFlexible: Support single or multiple fields, mode-selective or full matrices\nEfficient: Custom gradient implementations via backpropagate_metric\nComposable: Combine metrics for multi-objective optimization\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Core-Functions","page":"API","title":"Core Functions","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.AbstractMetric-Tuple{ScalarField}","page":"API","title":"FluxOptics.Metrics.AbstractMetric","text":"(m::AbstractMetric)(u::Vararg{ScalarField})\n(m::AbstractMetric)(u::ScalarField)\n\nCallable interface for metrics. Equivalent to compute_metric(m, u).\n\nThis is the preferred way to evaluate metrics.\n\nExamples\n\nmetric = PowerCoupling(target)\n\n# Single field\nloss = metric(u)\n\n# Multiple fields\nmetric_multi = DotProduct(target1, target2)\nlosses = metric_multi(u1, u2)\n\nSee also: compute_metric\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.compute_metric","page":"API","title":"FluxOptics.Metrics.compute_metric","text":"compute_metric(m::AbstractMetric, u::NTuple{N, ScalarField})\ncompute_metric(m::AbstractMetric, u::ScalarField)\n\nEvaluate a metric on one or more optical fields.\n\nThis is the core evaluation function for metrics. In practice, prefer using the callable interface metric(u) which calls this function internally.\n\nArguments\n\nm::AbstractMetric: The metric to evaluate.\nu: Single ScalarField or tuple of ScalarFields.\n\nReturns\n\nArray(s) containing metric values. Dimensions depend on the specific metric type and whether mode_selective=true.\n\nExamples\n\nmetric = PowerCoupling(target)\n\n# Callable interface (preferred)\nloss = metric(u)\n\n# Explicit call (equivalent)\nloss = compute_metric(metric, u)\n\n# Multiple fields\nmetric_multi = DotProduct(target1, target2)\nlosses = compute_metric(metric_multi, (u1, u2))\n\nSee also: backpropagate_metric, AbstractMetric\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.backpropagate_metric","page":"API","title":"FluxOptics.Metrics.backpropagate_metric","text":"backpropagate_metric(m::AbstractMetric, u::NTuple{N, ScalarField}, ∂c)\n\nCompute gradients of metric with respect to input fields.\n\nUsed internally by automatic differentiation. Most users don't need to call this directly.\n\nArguments\n\nm::AbstractMetric: The metric.\nu: Tuple of input fields.\n∂c: Gradient w.r.t. metric output.\n\nReturns\n\nTuple of ScalarFields containing gradients w.r.t. each input field.\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/metrics/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"using FluxOptics\n\n# Create metric\ntarget = ScalarField(target_data, (2.0, 2.0), 1.064)\nmetric = PowerCoupling(target)\n\n# Evaluate metric\nu = system()\nloss = compute_metric(metric, u)\n\n# Or use callable interface\nloss = metric(u)\n\n# With multiple fields\nmetric_multi = DotProduct(target1, target2)\nlosses = metric_multi(u1, u2)","category":"page"},{"location":"api/metrics/metrics/#Dot-Product-Metrics","page":"API","title":"Dot Product Metrics","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.DotProduct","page":"API","title":"FluxOptics.Metrics.DotProduct","text":"DotProduct(fields...; mode_selective::Bool=true)\n\nCompute dot product (inner product) between optical fields for optimization.\n\nThis metric calculates the complex overlap integral ⟨u,v⟩ between fields, commonly used  for mode coupling analysis and field matching objectives in inverse design.\n\nArguments\n\nfields...: Reference ScalarField(s) to compare against.\nmode_selective::Bool=true: If true, compute per-mode overlaps. If false, compute full overlap matrix.\n\nMathematical definition\n\n⟨u,v⟩ = ∫∫ u*(x,y) v(x,y) dx dy\n\nExamples\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 2);\n\njulia> data[3:end,:,2] .= -ones(ComplexF64, 2, 4);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> normalize_power!(u);\n\njulia> metric_selective = DotProduct(u);\n\njulia> metric_selective(u)\n1×1×2 Array{ComplexF64, 3}:\n[:, :, 1] =\n 1.0 + 0.0im\n\n[:, :, 2] =\n 1.0 + 0.0im\n\njulia> metric_non_selective = DotProduct(u; mode_selective = false);\n\njulia> metric_non_selective(u)\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\nSee also: PowerCoupling\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Mode-selective dot product (default)\ntarget = ScalarField(target_data, (64, 64, 3), (2.0, 2.0), 1.064)\nmetric = DotProduct(target; mode_selective=true)\n\nu = system()\noverlaps = metric(u)  # 1×1×3 array (per-mode)\n\n# Full overlap matrix\nmetric_full = DotProduct(target; mode_selective=false)\noverlap_matrix = metric_full(u)  # 3×3 matrix\n\n# Multiple targets\nmetric_multi = DotProduct(target1, target2)\noverlaps = metric_multi(u1, u2)","category":"page"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.PowerCoupling","page":"API","title":"FluxOptics.Metrics.PowerCoupling","text":"PowerCoupling(fields...; mode_selective::Bool=true)\n\nCompute power coupled into target optical modes.\n\nThis metric calculates |⟨u,v̂⟩|², the optical power (in Watts) coupled from field u  into normalized target modes v̂. The target fields are copied and normalized internally  to unit power, leaving the original fields unmodified.\n\nArguments\n\nfields...: Target ScalarField(s) to couple into (copied and normalized internally).\nmode_selective::Bool=true: If true, compute per-mode coupling. If false, compute full coupling matrix.\n\nMathematical definition\n\nP_coupled = |⟨u,v̂⟩|² where v̂ are normalized copies of the target fields\n\nExamples\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 2);\n\njulia> data[3:end,:,2] .= -ones(ComplexF64, 2, 4);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> normalize_power!(u);\n\njulia> metric_selective = PowerCoupling(u);\n\njulia> metric_selective(u)\n1×1×2 Array{Float64, 3}:\n[:, :, 1] =\n 1.0\n\n[:, :, 2] =\n 1.0\n\njulia> metric_non_selective = PowerCoupling(u; mode_selective = false);\n\njulia> metric_non_selective(u)\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\nSee also: DotProduct\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Examples-3","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Single target mode\ntarget = ScalarField(target_data, (128, 128), (2.0, 2.0), 1.064)\nnormalize_power!(target)  # Not required - done internally\n\nmetric = PowerCoupling(target)\nu = system()\npower_coupled = metric(u)[]  # Scalar power in Watts\n\n# Multi-mode coupling\nmodes_data = generate_mode_stack(layout, 128, 128, 2.0, 2.0, Gaussian(15.0))\nmodes = ScalarField(modes_data, (2.0, 2.0), 1.064)\n\nmetric = PowerCoupling(modes; mode_selective=true)\nu = system()\npowers = metric(u)  # Power per mode\n\n# Use in optimization\nfunction loss()\n    u = system()\n    -sum(metric(u))  # Maximize total coupled power\nend","category":"page"},{"location":"api/metrics/metrics/#Field-Difference-Metrics","page":"API","title":"Field Difference Metrics","text":"","category":"section"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.SquaredFieldDifference","page":"API","title":"FluxOptics.Metrics.SquaredFieldDifference","text":"SquaredFieldDifference(fields...)\n\nCompute squared L² norm difference between complex optical fields.\n\nThis metric calculates ‖u - v‖², the squared field difference, commonly used as a loss function for direct field matching in inverse design problems.\n\nArguments\n\nfields...: Reference ScalarField(s) to match against.\n\nMathematical definition\n\nL = ∫∫ |u(x,y) - v(x,y)|² dx dy = ‖u - v‖²\n\nExamples\n\n# Small example for documentation - use larger arrays in practice\njulia> data1 = ones(ComplexF64, 4, 4);\n\njulia> target = ScalarField(data1, (1.0, 1.0), 1.064);\n\njulia> data2 = zeros(ComplexF64, 4, 4);\n\njulia> current = ScalarField(data2, (1.0, 1.0), 1.064);\n\njulia> metric = SquaredFieldDifference(target);\n\njulia> metric(current)\n1×1 Matrix{Float64}:\n 16.0\n\nSee also: SquaredIntensityDifference\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Examples-4","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Complex field matching\ntarget = ScalarField(target_data, (128, 128), (2.0, 2.0), 1.064)\n\nmetric = SquaredFieldDifference(target)\nu = system()\nloss = metric(u)[]\n\n# Multi-mode matching\ntarget_multi = ScalarField(target_data, (64, 64, 3), (2.0, 2.0), 1.064)\nmetric_multi = SquaredFieldDifference(target_multi)\nu_multi = system()\nlosses_per_mode = metric_multi(u_multi)  # 1×1×3 array","category":"page"},{"location":"api/metrics/metrics/#FluxOptics.Metrics.SquaredIntensityDifference","page":"API","title":"FluxOptics.Metrics.SquaredIntensityDifference","text":"SquaredIntensityDifference(field_intensity_pairs...)\n\nCompute squared difference between field intensities and target patterns.\n\nThis metric supports two modes depending on target array dimensions:\n\nFull dimensions: Target has same dimensions as field → compare each mode individually\nSpatial only: Target has only spatial dimensions → compare total intensity across all modes\n\nArguments\n\nfield_intensity_pairs...: Tuples of (ScalarField, targetintensityarray).\n\nMathematical definition\n\nFull dimensions case: L = ∫∫ |uₖ(x,y)|² - Itargetₖ(x,y)|² dx dy (per mode)\n\nSpatial only case: L = ∫∫ |(∑ₖ |uₖ(x,y)|²) - Itarget(x,y)|² dx dy (total intensity)\n\nExamples\n\nFull dimensions case (mode-by-mode comparison):\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 2);\n\njulia> field = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> target_intensity = zeros(4, 4, 2);  # Same dimensions as field\n\njulia> metric = SquaredIntensityDifference((field, target_intensity));\n\njulia> metric(field)\n1×1×2 Array{Float64, 3}:\n[:, :, 1] =\n 16.0\n\n[:, :, 2] =\n 16.0\n\nSpatial only case (total intensity comparison):\n\n# Small example for documentation - use larger arrays in practice\njulia> data = ones(ComplexF64, 4, 4, 3);\n\njulia> field = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> target_intensity = 3*ones(4, 4);  # Only spatial dimensions\n\njulia> metric = SquaredIntensityDifference((field, target_intensity));\n\njulia> metric(field)\n1×1 Matrix{Float64}:\n 0.0\n\nSee also: SquaredFieldDifference\n\n\n\n\n\n","category":"type"},{"location":"api/metrics/metrics/#Examples-5","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Mode-by-mode intensity matching\ntarget_intensity = abs2.(target_data)  # 128×128×3\nu = ScalarField(ones(ComplexF64, 128, 128, 3), (2.0, 2.0), 1.064)\n\nmetric = SquaredIntensityDifference((u, target_intensity))\nloss_per_mode = metric(u)  # 1×1×3 array\n\n# Total intensity matching (summed over modes)\ntarget_intensity_total = sum(abs2.(target_data), dims=3)[:,:,1]  # 128×128\nmetric_total = SquaredIntensityDifference((u, target_intensity_total))\nloss_total = metric_total(u)[]  # Scalar\n\n# Multiple field-target pairs\nmetric_multi = SquaredIntensityDifference(\n    (field1, target1),\n    (field2, target2)\n)\nlosses = metric_multi(field1, field2)","category":"page"},{"location":"api/metrics/metrics/#Optimization-Patterns","page":"API","title":"Optimization Patterns","text":"","category":"section"},{"location":"api/metrics/metrics/#Basic-Optimization","page":"API","title":"Basic Optimization","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"using Zygote, Optimisers\n\n# Setup system and metric\nsystem = source |> phase_mask |> propagator\ntarget = ScalarField(target_data, (2.0, 2.0), 1.064)\nmetric = PowerCoupling(target)\n\n# Loss function\nfunction loss()\n    u = system()\n    -metric(u)[]  # Maximize coupling (minimize negative)\nend\n\n# Optimize\nparams = Functors.fmap(trainable, system)\nopt_state = Optimisers.setup(Optimisers.Adam(0.01), params)\n\nfor iter in 1:100\n    grads = gradient(loss, params)[1]\n    Optimisers.update!(opt_state, params, grads)\nend","category":"page"},{"location":"api/metrics/metrics/#Multi-Objective-Optimization","page":"API","title":"Multi-Objective Optimization","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Combine multiple metrics\ntarget_mode = ScalarField(mode_data, (2.0, 2.0), 1.064)\ntarget_intensity = desired_intensity_pattern\n\nmetric_coupling = PowerCoupling(target_mode)\nmetric_intensity = SquaredIntensityDifference((target_mode, target_intensity))\n\nfunction combined_loss()\n    u = system()\n    α = 0.7  # Weighting factor\n    α * (1.0 - metric_coupling(u)[]) + (1-α) * metric_intensity(u)[]\nend","category":"page"},{"location":"api/metrics/metrics/#Mode-Selective-Optimization","page":"API","title":"Mode-Selective Optimization","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Optimize specific modes\nmodes = ScalarField(mode_stack, (2.0, 2.0), 1.064)\nmetric = PowerCoupling(modes; mode_selective=true)\n\nfunction selective_loss()\n    u = system()\n    powers = metric(u)\n    \n    # Weight different modes\n    weights = [1.0, 0.5, 0.2]  # Prioritize first mode\n    -sum(reshape(weights, 1, 1, 3) .* powers)\nend","category":"page"},{"location":"api/metrics/metrics/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/metrics/metrics/#Metric-Types","page":"API","title":"Metric Types","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"All metrics are subtypes of AbstractMetric\nMetrics are callable: metric(field) calls compute_metric\nSupport single or multiple field arguments","category":"page"},{"location":"api/metrics/metrics/#Mode-Selectivity","page":"API","title":"Mode Selectivity","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"mode_selective=true: Compute per-mode metrics (diagonal)\nmode_selective=false: Compute full coupling matrix\nAffects output dimensionality and computational cost","category":"page"},{"location":"api/metrics/metrics/#Normalization","page":"API","title":"Normalization","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"PowerCoupling normalizes targets internally (copies first)\nDotProduct uses fields as-is\nConsider normalizing input fields before metrics","category":"page"},{"location":"api/metrics/metrics/#Gradient-Computation","page":"API","title":"Gradient Computation","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"Metrics implement custom backpropagate_metric for efficiency\nCompatible with Zygote and other AD libraries\nGradients flow through metric computations","category":"page"},{"location":"api/metrics/metrics/#Performance","page":"API","title":"Performance","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"Metrics cache internal buffers to avoid allocations\nPre-compute metrics once, reuse for multiple evaluations\nUse in-place operations where possible","category":"page"},{"location":"api/metrics/metrics/#Memory-Layout","page":"API","title":"Memory Layout","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"Metrics store internal arrays matching field structure\nBuffers allocated at construction time\nGPU-compatible when using CuArrays","category":"page"},{"location":"api/metrics/metrics/#Advanced-Usage","page":"API","title":"Advanced Usage","text":"","category":"section"},{"location":"api/metrics/metrics/#Custom-Metric","page":"API","title":"Custom Metric","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Define new metric type\nstruct MyMetric <: AbstractMetric\n    reference::ScalarField\n    buffer::Array{ComplexF64}\nend\n\n# Implement required methods\nfunction compute_metric(m::MyMetric, u::Tuple{ScalarField})\n    # Your metric computation\nend\n\nfunction backpropagate_metric(m::MyMetric, u::Tuple{ScalarField}, ∂c)\n    # Your gradient computation\nend","category":"page"},{"location":"api/metrics/metrics/#Combining-Metrics","page":"API","title":"Combining Metrics","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"# Wrapper for weighted sum\nstruct WeightedSum{M<:Tuple} <: AbstractMetric\n    metrics::M\n    weights::Vector{Float64}\nend\n\nfunction compute_metric(m::WeightedSum, u::NTuple{N, ScalarField}) where N\n    sum(w * compute_metric(metric, u) for (w, metric) in zip(m.weights, m.metrics))\nend","category":"page"},{"location":"api/metrics/metrics/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/metrics/metrics/","page":"API","title":"API","text":"OptimisersExt for optimization algorithms","category":"page"},{"location":"api/fields/#Fields","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"The ScalarField type and field operations.","category":"page"},{"location":"api/fields/#Overview","page":"Fields","title":"Overview","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"The Fields module provides:","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"ScalarField type: Central data structure for optical fields\nMulti-wavelength support: Handle multiple wavelengths simultaneously\nTilt tracking: Manage off-axis propagation\nField operations: Power, intensity, phase, normalization","category":"page"},{"location":"api/fields/#Quick-Example","page":"Fields","title":"Quick Example","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"using FluxOptics\n\n# Create a field\ndata = ones(ComplexF64, 128, 128, 3)  # 3 modes\nu = ScalarField(data, (2.0, 2.0), [0.8, 1.064, 1.55])\n\n# Field operations\nP = power(u)              # Power per mode\nI = intensity(u)          # Total intensity\nnormalize_power!(u)       # Normalize to unit power\nφ = phase(u)              # Phase distribution\n\n# Access and modify\nu[:, :, 1] .= 0.0        # Clear first mode\nu_copy = copy(u)         # Independent copy","category":"page"},{"location":"api/fields/#Key-Types","page":"Fields","title":"Key Types","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"ScalarField: Optical field with grid information","category":"page"},{"location":"api/fields/#Key-Functions","page":"Fields","title":"Key Functions","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Field Construction and Data","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"ScalarField: Create optical field\nset_field_data: Update field data\nsimilar: Allocate similar field\ncopy: Copy field\nfill!: Fill field with values\ncopyto!: Copy between fields\ncollect: Convert to CPU array","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Field Properties","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"size: Get field dimensions\nndims: Number of dimensions\neltype: Element type","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Tilts Management","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"set_field_tilts: Update field tilts\noffset_tilts!: Add tilt offset with phase correction\nis_on_axis: Check if field is on-axis","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Power and Intensity","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"power: Calculate field power\nnormalize_power!: Normalize to target power\nintensity: Calculate total intensity\nphase: Extract phase distribution","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Field Comparison","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"coupling_efficiency: Coupling efficiency between fields\ndot: Field overlap integral","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Vectorization","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"vec: Vectorize into independent ScalarFields","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Broadcasting and Indexing","category":"page"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"broadcasted: Element-wise operations\ngetindex: Access field elements\nconj: Complex conjugate","category":"page"},{"location":"api/fields/#See-Also","page":"Fields","title":"See Also","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Modes for generating optical modes\nGridUtils for coordinate systems","category":"page"},{"location":"api/fields/#Index","page":"Fields","title":"Index","text":"","category":"section"},{"location":"api/fields/","page":"Fields","title":"Fields","text":"Modules = [FluxOptics.Fields]\nOrder = [:type, :function]","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This section provides detailed documentation for all FluxOptics.jl modules and functions.","category":"page"},{"location":"api/#Quick-Navigation","page":"API Reference","title":"Quick Navigation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"FluxOptics is organized into focused modules for different aspects of optical simulation and inverse design:","category":"page"},{"location":"api/#Foundation","page":"API Reference","title":"Foundation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"GridUtils - Coordinate systems and transformations","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Spatial coordinate generation for optical grids\n2D transformations (translations, rotations)\nCoordinate composition for complex geometries","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modes - Optical mode generation","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Gaussian beam families (Gaussian, Hermite-Gaussian, Laguerre-Gaussian)\nSpatial layouts for multi-mode configurations\nSpeckle generation with controlled statistics","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Fields - Field representation and operations","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"ScalarField type for optical fields\nMulti-wavelength and tilt support\nPower, intensity, and field comparison operations","category":"page"},{"location":"api/#Propagation-and-Components","page":"API Reference","title":"Propagation & Components","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Optical Components - Building blocks for optical systems","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Core: Abstract types, sources, static components (Phase, Mask, TeaDOE)\nFree-Space Propagators: Angular Spectrum, Rayleigh-Sommerfeld, Collins integral\nBulk Propagators: Beam Propagation Method for inhomogeneous media\nActive Media: Gain sheets and amplifiers\nOptical systems with piping syntax","category":"page"},{"location":"api/#Optimization","page":"API Reference","title":"Optimization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"OptimisersExt - Optimization algorithms and rules","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Custom optimization rules (Descent, Momentum, FISTA)\nProximal operators for constrained optimization\nIntegration with Optimisers.jl ecosystem","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Metrics - Loss functions for inverse design","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Field overlap metrics (DotProduct, PowerCoupling)\nField and intensity matching objectives\nCustom gradient implementations for efficiency","category":"page"},{"location":"api/#Design-Philosophy","page":"API Reference","title":"Design Philosophy","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"FluxOptics follows these principles:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Differentiable by design: All components work with automatic differentiation\nGPU-ready: Seamless CUDA.jl integration for acceleration\nComposable: Build complex systems from simple components\nEfficient: Pre-allocated buffers on-demand and optimized kernels\nFlexible: Support for multi-wavelength, multi-mode, and off-axis propagation","category":"page"},{"location":"api/#Typical-Workflow","page":"API Reference","title":"Typical Workflow","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using FluxOptics\n\n# 1. Define spatial grid and modes\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\ngaussian = Gaussian(20.0)\n\n# 2. Create field\nu = ScalarField(gaussian(xv, yv), (2.0, 2.0), 1.064)\n\n# 3. Build optical system\nsource = ScalarSource(u; trainable=true)\nphase = Phase(u, (x, y) -> 0.0; trainable=true)\npropagator = ASProp(u, 1000.0)\nsystem = source |> phase |> propagator\n\n# 4. Define optimization objective\ntarget = ScalarField(target_data, (2.0, 2.0), 1.064)\nmetric = PowerCoupling(target)\n\n# 5. Optimize\nusing Zygote\nloss() = 1.0 - metric(system())[]\n# ... gradient descent ...","category":"page"},{"location":"api/#Module-Overview","page":"API Reference","title":"Module Overview","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pages = [\n    \"gridutils/index.md\",\n    \"modes/index.md\",\n    \"fields/index.md\",\n    \"optical_components/index.md\",\n    \"optimisers/index.md\",\n    \"metrics/index.md\",\n]\nDepth = 1","category":"page"},{"location":"api/gridutils/gridutils/#GridUtils-API","page":"API","title":"GridUtils API","text":"","category":"section"},{"location":"api/gridutils/gridutils/#Spatial-Vectors","page":"API","title":"Spatial Vectors","text":"","category":"section"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.spatial_vectors","page":"API","title":"FluxOptics.GridUtils.spatial_vectors","text":"spatial_vectors(ns::NTuple{Nd,Real}, ds::NTuple{Nd,Real}; offset::NTuple{Nd,Real}=ntuple(_->0, Nd))\nspatial_vectors(nx, dx; xc=0.0)\nspatial_vectors(nx, ny, dx, dy; xc=0.0, yc=0.0)\n\nGenerate spatial coordinate vectors for optical field grids.\n\nCreates coordinate arrays centered at zero with specified sampling and optional offset. Essential for defining spatial grids in optical simulations.\n\nArguments\n\nns::NTuple: Number of points in each dimension.\nds::NTuple: Spatial sampling interval in each dimension (user-defined unit).\noffset::NTuple=ntuple(_->0, Nd): Offset of the zero position from the center of the grid, for each dimension. The center of the grid is then -offset.\n\nReturns\n\nTuple of coordinate vectors, one per spatial dimension. Each coordinate vector is an AbstractRange.\n\nExamples\n\n# 1D case\njulia> x, = spatial_vectors(4, 1.0);\n\njulia> isa(x, AbstractRange)\ntrue\n\njulia> collect(x)\n4-element Vector{Float64}:\n -1.5\n -0.5\n  0.5\n  1.5\n\njulia> x, y = spatial_vectors(4, 4, 1.0, 1.0; xc=2.0); # 2D case with offset\n\njulia> collect(x)\n4-element Vector{Float64}:\n -3.5\n -2.5\n -1.5\n -0.5\n\nSee also: Shift2D, Rot2D\n\n\n\n\n\n","category":"function"},{"location":"api/gridutils/gridutils/#2D-Transformations","page":"API","title":"2D Transformations","text":"","category":"section"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.Shift2D","page":"API","title":"FluxOptics.GridUtils.Shift2D","text":"Shift2D(x::Real, y::Real)\n\nCreate a 2D translation transformation.\n\nRepresents a spatial translation by (x, y) in micrometers. Can be composed  with other transformations using the ∘ operator.\n\nArguments\n\nx::Real: Translation in x direction.\ny::Real: Translation in y direction.\n\nExamples\n\njulia> t = Shift2D(2.0, 3.0);\n\njulia> t([1.0, 1.0])  # Apply transformation\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 3.0\n 4.0\n\njulia> combined = Shift2D(1.0, 0.0) ∘ Rot2D(π/4); # Composition with rotation\n\njulia> combined([1.0, 0.0])  # Rotate then translate\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.7071067811865475\n 0.7071067811865475\n\nSee also: Rot2D, Id2D\n\n\n\n\n\n","category":"type"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.Rot2D","page":"API","title":"FluxOptics.GridUtils.Rot2D","text":"Rot2D(θ::Real)\n\nCreate a 2D rotation transformation.\n\nRepresents a rotation by angle θ (in radians) around the origin.  Can be composed with other transformations using the ∘ operator.\n\nArguments\n\nθ::Real: Rotation angle in radians (positive = counterclockwise).\n\nExamples\n\njulia> r = Rot2D(π/2);  # 90° rotation\n\njulia> r([1.0, 0.0])  # Rotate point\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 6.123233995736766e-17\n 1.0\n\njulia> transform = Rot2D(π/4) ∘ Shift2D(2.0, 0.0); # Composition: translate then rotate\n\njulia> transform([0.0, 0.0])\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.4142135623730951\n 1.414213562373095\n\nSee also: Shift2D, Id2D\n\n\n\n\n\n","category":"type"},{"location":"api/gridutils/gridutils/#FluxOptics.GridUtils.Id2D","page":"API","title":"FluxOptics.GridUtils.Id2D","text":"Id2D()\n\nCreate a 2D identity transformation.\n\nRepresents the identity transformation that leaves coordinates unchanged. Useful as a default value in functions that accept coordinate transformations, or for composing transformation chains where no transformation is needed.\n\nExamples\n\njulia> t = Id2D();\n\njulia> t([1.0, 2.0])  # Apply identity transformation\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 2.0\n\njulia> # Composition with other transformations\n\njulia> combined = Shift2D(1.0, 0.0) ∘ Id2D();\n\njulia> combined([0.0, 0.0])  # Behaves like Shift2D(1.0, 0.0)\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 0.0\n\nSee also: Shift2D, Rot2D\n\n\n\n\n\n","category":"type"},{"location":"api/gridutils/gridutils/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/gridutils/gridutils/#Basic-Coordinate-Generation","page":"API","title":"Basic Coordinate Generation","text":"","category":"section"},{"location":"api/gridutils/gridutils/","page":"API","title":"API","text":"# 1D coordinates\nx, = spatial_vectors(64, 2.0)  # 64 points, 2.0 μm spacing\n\n# 2D coordinates\nxv, yv = spatial_vectors(128, 128, 1.5, 1.5)\n\n# With offset (shift zero position)\nxv, yv = spatial_vectors(128, 128, 1.5, 1.5; xc=10.0, yc=-5.0)","category":"page"},{"location":"api/gridutils/gridutils/#Coordinate-Transformations","page":"API","title":"Coordinate Transformations","text":"","category":"section"},{"location":"api/gridutils/gridutils/","page":"API","title":"API","text":"# Simple translation\nshift = Shift2D(20.0, -10.0)\nnew_point = shift([0.0, 0.0])  # [20.0, -10.0]\n\n# Simple rotation (45°)\nrot = Rot2D(π/4)\nrotated = rot([1.0, 0.0])  # [√2/2, √2/2]\n\n# Composition: translate then rotate\ntransform = Rot2D(π/6) ∘ Shift2D(5.0, 0.0)\nresult = transform([0.0, 0.0])","category":"page"},{"location":"api/gridutils/gridutils/#Use-with-Modes","page":"API","title":"Use with Modes","text":"","category":"section"},{"location":"api/gridutils/gridutils/","page":"API","title":"API","text":"using FluxOptics\n\n# Create offset and rotated Gaussian\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\ngaussian = Gaussian(15.0)\n\n# Apply transformation\ntransform = Shift2D(20.0, 10.0) ∘ Rot2D(π/8)\nfield = gaussian(xv, yv, transform)","category":"page"},{"location":"api/gridutils/gridutils/#Notes","page":"API","title":"Notes","text":"","category":"section"},{"location":"api/gridutils/gridutils/","page":"API","title":"API","text":"All spatial units should be consistent (typically micrometers)\nRotations are counterclockwise for positive angles\nTransformations compose right-to-left: (f ∘ g)(x) = f(g(x))\nOffsets shift the zero position from grid center","category":"page"},{"location":"api/fields/fields/#Fields-API","page":"API","title":"Fields API","text":"","category":"section"},{"location":"api/fields/fields/#ScalarField-Type","page":"API","title":"ScalarField Type","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.ScalarField","page":"API","title":"FluxOptics.Fields.ScalarField","text":"ScalarField(data::AbstractArray{Complex}, ds::NTuple{Nd,Real}, lambdas; tilts=ntuple(_->0, Nd))\nScalarField(nd::NTuple, ds::NTuple{Nd,Real}, lambdas; tilts=ntuple(_->0, Nd))\n\nRepresent a scalar optical field with spatial grid information, wavelength(s), and optional tilt angles.\n\nThis is the central data structure of FluxOptics.jl for storing and manipulating scalar optical fields. The field data can be multi-dimensional with 1 or 2 transverse dimensions and additional dimensions for  different spatial modes. Each mode can hold independent wavelength and tilt information.\n\nConstructors\n\nFrom existing data:\n\ndata::AbstractArray{Complex}: Complex field amplitude data.\nds::NTuple{Nd,Real}: Spatial sampling intervals (dx,[dy]) in micrometers (or meters as long as consistent units are used everywhere).\nlambdas: Wavelength(s) - can be a scalar Real or AbstractArray{Real} for multiple wavelengths. In case of AbstractArray{Real}, it must be broadcastable on the extra dimensions of data (all dimensions except the spatial ones).\ntilts::NTuple{Nd}=ntuple(_->0, Nd): Tilt angles in radians corresponding to a Fourier offset of fx₀ = sin(θx)/λ, fy₀ = sin(θy)/λ. Array arguments to NTuple are accepted as long as they broadcast with the extra non-spatial dimensions of data.\n\nZero-initialized field (convenience):\n\nnd::NTuple: Dimensions of the data array (nx, [ny,] ...).\nOther arguments same as above.\n\nExamples\n\nCreating from existing data:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = rand(ComplexF64, 4, 4);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> size(u)\n(4, 4)\n\nCreating zero-initialized field:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField((4, 4), (1.0, 1.0), 1.064);\n\njulia> size(u)\n(4, 4)\n\nMulti-wavelength field:\n\njulia> wavelengths = [0.8, 1.064, 1.550];\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = zeros(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), wavelengths);\n\nField with initial tilt:\n\njulia> wavelengths = [0.8, 1.064, 1.55];\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = zeros(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064; tilts=(0.01, 0.005));\n\njulia> v = ScalarField(data, (1.0, 1.0), 1.064; tilts=([0.01, 0.02, 0.03], 0));\n\nSee also: set_field_data, power, normalize_power!\n\n\n\n\n\n","category":"type"},{"location":"api/fields/fields/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"using FluxOptics\n\n# From existing data\ndata = rand(ComplexF64, 64, 64)\nu = ScalarField(data, (2.0, 2.0), 1.064)\n\n# Zero-initialized\nu = ScalarField((128, 128), (1.5, 1.5), 1.064)\n\n# Multi-mode field\ndata = zeros(ComplexF64, 128, 128, 5)\nu = ScalarField(data, (2.0, 2.0), 1.064)\n\n# Multi-wavelength field\nλs = [0.8, 1.064, 1.55]\ndata = zeros(ComplexF64, 64, 64, 3)\nu = ScalarField(data, (1.0, 1.0), λs)\n\n# Field with tilts\nu = ScalarField(data, (2.0, 2.0), 1.064; tilts=(0.01, 0.005))","category":"page"},{"location":"api/fields/fields/#Field-Data-Management","page":"API","title":"Field Data Management","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.set_field_data","page":"API","title":"FluxOptics.Fields.set_field_data","text":"set_field_data(u::ScalarField, data::AbstractArray)\n\nCreate a new ScalarField with updated field data, preserving all other parameters.\n\nThis function creates a copy with new amplitude data while keeping the same spatial grid, wavelengths, and tilt information.\n\nArguments\n\nu::ScalarField: Original field.\ndata::AbstractArray: New complex field data.\n\nReturns\n\nNew ScalarField with updated data.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> new_data = rand(ComplexF64, 4, 4);\n\njulia> u_new = set_field_data(u, new_data);\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#Base.similar-Tuple{ScalarField}","page":"API","title":"Base.similar","text":"similar(u::ScalarField)\n\nCreate a new ScalarField with same parameters but uninitialized data.\n\nUseful for creating temporary fields with the same grid, wavelength and tilt structures as an existing field.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> u_tmp = similar(u);  # Same grid/wavelengths/tilts, but data is uninitialized\n\nSee also: copy, set_field_data\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.copy-Tuple{ScalarField}","page":"API","title":"Base.copy","text":"copy(u::ScalarField)\n\nCreate a copy of the scalar field.\n\nCreates a copy of the field data, while sharing the internal representation of other parameters.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> u_copy = copy(u);\n\njulia> # Modifying u_copy.electric will not affect u, but the internal arrays representing\n\njulia> # the wavelengths or tilts must never be modified.\n\nSee also: similar\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.fill!-Tuple{ScalarField, Number}","page":"API","title":"Base.fill!","text":"fill!(u::ScalarField, v) -> ScalarField\n\nFill the electric field with value v in-place.\n\nArguments\n\nu::ScalarField: Field to modify.\nv: Fill value, either a scalar (fills entire field) or array (copied into field).\n\nReturns\n\nModified ScalarField (same as input).\n\nExamples\n\njulia> u = ScalarField((4, 4), (1.0, 1.0), 1.064);\n\njulia> fill!(u, 1.0 + 0.0im);  # Fill with constant\n\njulia> fill!(u, rand(ComplexF64, 4, 4));  # Fill with array\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.copyto!-Tuple{ScalarField, ScalarField}","page":"API","title":"Base.copyto!","text":"copyto!(u::ScalarField, v::ScalarField) -> ScalarField\n\nCopy data from v into u. Modifies u in-place and returns it.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.collect-Tuple{ScalarField}","page":"API","title":"Base.collect","text":"collect(u::ScalarField) -> Array\n\nConvert field data to a regular CPU array. Returns an Array (not a ScalarField).\n\nUseful for converting GPU arrays (e.g., CuArray) to CPU for analysis, plotting, or saving.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064);\n\njulia> data = collect(u);  # Returns Array, not ScalarField\n\njulia> typeof(data)\nMatrix{ComplexF64} (alias for Array{Complex{Float64}, 2})\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Update field data\nnew_data = rand(ComplexF64, size(u)...)\nu_new = set_field_data(u, new_data)\n\n# Copy and allocate\nu_copy = copy(u)\nu_tmp = similar(u)\n\n# Fill operations\nfill!(u, 1.0 + 0.0im)\nfill!(u, rand(ComplexF64, size(u)...))\n\n# Copy between fields\ncopyto!(u_tmp, u)\n\n# Convert GPU to CPU array\ndata = collect(u)  # Returns Array","category":"page"},{"location":"api/fields/fields/#Field-Properties","page":"API","title":"Field Properties","text":"","category":"section"},{"location":"api/fields/fields/#Base.size-Tuple{ScalarField}","page":"API","title":"Base.size","text":"size(u::ScalarField) -> Tuple\nsize(u::ScalarField, k::Integer) -> Int\n\nReturn the size of the electric field array.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.ndims-Tuple{ScalarField}","page":"API","title":"Base.ndims","text":"ndims(u::ScalarField, spatial::Bool=false) -> Int\n\nReturn number of dimensions. If spatial=true, returns only spatial dimensions (Nd), otherwise returns total dimensions of the electric field array.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.eltype-Tuple{ScalarField}","page":"API","title":"Base.eltype","text":"eltype(u::ScalarField) -> Type\n\nReturn the element type of the electric field.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-3","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Get dimensions\nnx, ny = size(u)[1:2]\nn_modes = size(u, 3)\n\n# Number of dimensions\nndims(u)           # Total dimensions\nndims(u, true)     # Spatial dimensions only\n\n# Element type\neltype(u)  # ComplexF64 or ComplexF32","category":"page"},{"location":"api/fields/fields/#Tilt-Management","page":"API","title":"Tilt Management","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.set_field_tilts","page":"API","title":"FluxOptics.Fields.set_field_tilts","text":"set_field_tilts(u::ScalarField, tilts) -> ScalarField\n\nCreate a new ScalarField with updated tilts, preserving all other parameters.\n\nThis function creates a copy with new tilt values while keeping the same field data, spatial grid, and wavelengths.\n\nArguments\n\nu::ScalarField: Original field.\ntilts: New tilt values as (θx, θy) tuple, where each component can be scalar or array.\n\nReturns\n\nNew ScalarField with updated tilts.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064; tilts=(0.01, 0.0));\n\njulia> u_tilted = set_field_tilts(u, (0.02, 0.01));\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.offset_tilts!","page":"API","title":"FluxOptics.Fields.offset_tilts!","text":"offset_tilts!(u::ScalarField, tilts)\n\nAdd offset to existing tilts and apply corresponding linear phase to the field in-place.\n\nThis function modifies both the tilt metadata and the electric field by:\n\nAdding the offset to the stored tilt values\nMultiplying the field by exp(i 2π/λ (Δθx⋅x + Δθy⋅y)) to maintain consistency\n\nThis shifts the reference frame without rotating the angular spectrum.\n\nArguments\n\nu::ScalarField: Field to modify.\ntilts: Tilt offsets as (Δθx, Δθy) tuple in radians.\n\nExamples\n\njulia> u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064; tilts=(0.01, 0.0));\n\njulia> offset_tilts!(u, (0.005, 0.005));\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.is_on_axis","page":"API","title":"FluxOptics.Fields.is_on_axis","text":"is_on_axis(u::ScalarField) -> Bool\n\nCheck if the field has zero tilts (on-axis propagation).\n\nReturns true if all tilt components are zero, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#Examples-4","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Set new tilts\nu_tilted = set_field_tilts(u, (0.02, 0.015))\n\n# Add tilt offset (modifies tilts and applies phase)\noffset_tilts!(u, (0.01, 0.005))\n\n# Check if on-axis\nis_on_axis(u)  # true/false","category":"page"},{"location":"api/fields/fields/#Power-and-Intensity","page":"API","title":"Power and Intensity","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.power","page":"API","title":"FluxOptics.Fields.power","text":"power(u::ScalarField)\n\nCompute the optical power of the field.\n\nCalculates the spatial integral of the intensity |u|² over the field domain, properly accounting for the spatial sampling.\n\nMathematical definition\n\nP = ∫∫ |u(x,y)|² dx dy ≈ Σᵢⱼ |u[i,j]|² × dx × dy.\n\nReturns\n\nArray of power value(s) with same dimensions as u, spatial dimensions being reduced to size 1.\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = rand(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> P = power(u);  # Returns 1×1×3 Array\n\nSee also: normalize_power!\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.normalize_power!","page":"API","title":"FluxOptics.Fields.normalize_power!","text":"normalize_power!(u::ScalarField, target_power=1)\n\nNormalize the field to have specified optical power (in-place modification).\n\nScales the field amplitudes so that the total optical power equals the target values. This is useful for setting consistent power levels between different fields.\n\nArguments\n\nu::ScalarField: Field to normalize (modified in-place)\ntarget_power=1: Target power value(s) - can be a scalar Real or AbstractArray{Real} as long as it can be broadcasted on the field data.\n\nReturns\n\nThe modified field u\n\nExamples\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ScalarField(rand(ComplexF64, 4, 4, 3), (1.0, 1.0), 1.064);\n\njulia> normalize_power!(u);        # Normalize all fields to 1 W\n\njulia> normalize_power!(u, 1e-3);  # Normalize all fields to 1 mW\n\njulia> all(x -> isapprox(x, 1e-3), power(u))\ntrue\n\njulia> # For multiple fields: normalize each field separately\n\njulia> power_values = reshape([1e-3, 2e-3, 3e-3], 1, 1, 3);\n\njulia> normalize_power!(u, power_values);  # Different power per field\n\njulia> isapprox(power(u), power_values)\ntrue\n\nSee also: power\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.intensity","page":"API","title":"FluxOptics.Fields.intensity","text":"intensity(u::AbstractArray, nd::Integer=2)\nintensity(u::ScalarField)\n\nCompute the total intensity |u|² of optical fields or arrays.\n\nCalculates intensity by summing |u|² over all extra dimensions beyond the spatial ones, returning the combined intensity distribution for the spatial dimensions only.\n\nArguments\n\nu::AbstractArray: Array of complex values.\nnd::Integer=2: Number of spatial dimensions (for AbstractArray case only).\nu::ScalarField: Optical field with potentially multiple modes.\n\nMathematical definition\n\nI[i,j] = Σₖ |u[i,j,k]|² where k runs over all extra dimensions\n\nReturns\n\nAbstractArray: Array with spatial dimensions only, extra dims summed.\nScalarField: Array with spatial dimensions only, containing total intensity.\n\nExamples\n\nAbstractArray case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = ones(ComplexF64, 4, 4, 3);  # 2 spatial + 1 extra dim\n\njulia> I = intensity(data, 2);  # Sum over 3rd dimension\n\njulia> size(I)\n(4, 4)\n\njulia> I[1,1]\n3.0\n\nScalarField case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = ones(ComplexF64, 4, 4, 3);  # 3 modes\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> I = intensity(u);  # Returns 4×4 array (total intensity of all 3 modes)\n\njulia> size(I)\n(4, 4)\n\njulia> I[1,1]\n3.0\n\nSee also: power, phase\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#FluxOptics.Fields.phase","page":"API","title":"FluxOptics.Fields.phase","text":"phase(u::AbstractArray)\nphase(u::ScalarField)\n\nCompute the phase angle of complex arrays or optical fields.\n\nReturns the argument (angle) of complex values in radians, preserving array structure. For optical fields, this gives the wavefront phase information across all modes.\n\nArguments\n\nu::AbstractArray: Array of complex values.\nu::ScalarField: Optical field (uses underlying data array).\n\nMathematical definition\n\nφ = arg(u) = atan(imag(u), real(u))\n\nReturns\n\nAbstractArray: Array of same dimensions containing phase values in radians [-π, π].\nScalarField: Calls phase(u.electric), returns array with phase values.\n\nExamples\n\nAbstractArray case:\n\njulia> data = [1.0+0.0im, 0.0+1.0im, -1.0+0.0im];\n\njulia> phase(data)\n3-element Vector{Float64}:\n 0.0\n 1.5707963267948966\n 3.141592653589793\n\nScalarField case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = [1.0+0.0im 0.0+1.0im; -1.0+0.0im 0.0-1.0im];\n\njulia> u = ScalarField(data, (1.0, 1.0), 1.064);\n\njulia> phase(u)\n2×2 Matrix{Float64}:\n 0.0       1.5708\n 3.14159  -1.5708\n\nSee also: intensity, phase\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#Examples-5","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Single mode field\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\nP = power(u)  # Returns 1×1 array\n\n# Normalize to 1 W\nnormalize_power!(u)\n@assert isapprox(power(u)[], 1.0)\n\n# Normalize to specific power\nnormalize_power!(u, 1e-3)  # 1 mW\n\n# Multi-mode field\ndata = rand(ComplexF64, 64, 64, 3)\nu = ScalarField(data, (1.0, 1.0), 1.064)\nP = power(u)  # Returns 1×1×3 array\n\n# Different power per mode\ntarget_powers = reshape([1.0, 1.5, 2.0], 1, 1, 3)\nnormalize_power!(u, target_powers)\n\n# Total intensity (sum over all modes)\nI_total = intensity(u)  # Returns 2D array\n\n# Phase extraction\nφ = phase(u)  # Returns array same size as u","category":"page"},{"location":"api/fields/fields/#Field-Comparison","page":"API","title":"Field Comparison","text":"","category":"section"},{"location":"api/fields/fields/#FluxOptics.Fields.coupling_efficiency","page":"API","title":"FluxOptics.Fields.coupling_efficiency","text":"coupling_efficiency(u, v)\ncoupling_efficiency(u::ScalarField, v::ScalarField)\n\nCompute the power coupling efficiency between two optical fields.\n\nFor multi-dimensional fields, computes power coupling efficiency between corresponding field distributions (same extra dimension indices). This normalized metric returns values between 0 and 1, representing the fraction of power that would be transferred from field u to field v.\n\nMathematical definition\n\nη = |⟨u,v⟩|² / (‖u‖ ‖v‖)\n\nArguments\n\nu: First field (ScalarField or AbstractArray).\nv: Second field with same spatial dimensions as u.\n\nReturns\n\nFor AbstractArrays: Scalar coupling efficiency [0,1].\nFor ScalarFields: Array of coupling efficiencies, one for each field distribution.\n\nExamples\n\nArray case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> u = ones(ComplexF64, 4, 4);\n\njulia> v = ones(ComplexF64, 4, 4);\n\njulia> coupling_efficiency(u, v)\n1.0\n\nScalarField single-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = ones(ComplexF64, 4, 4);\n\njulia> field2_data = ones(ComplexF64, 4, 4);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> coupling_efficiency(u, v)\n1-element Vector{Float64}:\n 1.0\n\nScalarField multi-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = ones(ComplexF64, 4, 4, 3);\n\njulia> field2_data = ones(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> coupling_efficiency(u, v)\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\nSee also: power\n\n\n\n\n\n","category":"function"},{"location":"api/fields/fields/#LinearAlgebra.dot-Tuple{ScalarField}","page":"API","title":"LinearAlgebra.dot","text":"dot(u::ScalarField, v::ScalarField)\n\nCompute the inner product ⟨u,v⟩ between two optical fields.\n\nFor multi-dimensional fields, computes the dot product between corresponding field distributions (same extra dimension indices).\n\nMathematical definition\n\n⟨u,v⟩ = ∫∫ u(x,y) v(x,y) dx dy ≈ Σᵢⱼ u[i,j] v[i,j]\n\nArguments\n\nu::ScalarField: First field.\nv::ScalarField: Second field with same spatial dimensions as u.\n\nReturns\n\nVector of complex inner products, one for each field distribution.\n\nExamples\n\nSingle-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = rand(ComplexF64, 4, 4);\n\njulia> field2_data = rand(ComplexF64, 4, 4);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> overlap = dot(u, v);  # 0-dimensional Array storing the complex overlap integral\n\nMulti-mode case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> field1_data = rand(ComplexF64, 4, 4, 3);\n\njulia> field2_data = rand(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(field1_data, (1.0, 1.0), 1.064);\n\njulia> v = ScalarField(field2_data, (1.0, 1.0), 1.064);\n\njulia> overlaps = dot(u, v);  # 3-element Vector of complex overlaps\n\nSee also: coupling_efficiency, dot, power\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-6","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Modal overlap integral\nu1 = ScalarField(gaussian1(xv, yv), (2.0, 2.0), 1.064)\nu2 = ScalarField(gaussian2(xv, yv), (2.0, 2.0), 1.064)\n\noverlap = dot(u1, u2)  # Complex overlap\nη = coupling_efficiency(u1, u2)  # Real, between 0 and 1\n\n# Multi-mode fields\ndata1 = rand(ComplexF64, 64, 64, 3)\ndata2 = rand(ComplexF64, 64, 64, 3)\nu1 = ScalarField(data1, (2.0, 2.0), 1.064)\nu2 = ScalarField(data2, (2.0, 2.0), 1.064)\n\noverlaps = dot(u1, u2)  # 3-element array\nefficiencies = coupling_efficiency(u1, u2)  # 3-element array","category":"page"},{"location":"api/fields/fields/#Vectorization","page":"API","title":"Vectorization","text":"","category":"section"},{"location":"api/fields/fields/#Base.vec-Tuple{ScalarField}","page":"API","title":"Base.vec","text":"vec(u::AbstractArray, nd::Integer=2)\nvec(u::ScalarField)\n\nConvert multi-dimensional arrays or fields into vector of slices.\n\nFor AbstractArray, splits along dimensions beyond the first nd spatial dimensions. For ScalarField, converts into vector of individual ScalarField objects, each representing a single slice along non-spatial dimensions. Useful for iteration and visualization.\n\nArguments\n\nu: Array or ScalarField to vectorize.\nnd::Integer: Number of spatial dimensions (for AbstractArray case only).\n\nReturns\n\nFor AbstractArray: Vector of array slices along non-spatial dimensions.\nFor ScalarField: Vector of ScalarField objects, one per slice along non-spatial dimensions.\n\nExamples\n\nAbstractArray case:\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = ones(4, 4, 3);  # 2 spatial dims + 1 extra\n\njulia> slices = vec(data, 2);  # Split after 2 spatial dimensions\n\njulia> length(slices)\n3\n\njulia> size(slices[1])\n(4, 4)\n\nScalarField case:\n\njulia> wavelengths = [0.8, 1.064, 1.550];\n\njulia> # Small example for documentation - use larger arrays in practice\n\njulia> data = zeros(ComplexF64, 4, 4, 3);\n\njulia> u = ScalarField(data, (1.0, 1.0), wavelengths);\n\njulia> u_vec = vec(u);  # Returns Vector{ScalarField} of length 3\n\njulia> length(u_vec)\n3\n\njulia> (u_vec[1].lambdas.val, u_vec[2].lambdas.val, u_vec[3].lambdas.val)\n(0.8, 1.064, 1.55)\n\nSee also: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-7","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Vectorize into individual ScalarFields\nu_vec = vec(u)  # Vector of ScalarField objects\n\n# Iterate over modes\nfor (i, mode_field) in enumerate(u_vec)\n    P_mode = power(mode_field)\n    I_mode = intensity(mode_field)\n    println(\"Mode $i: Power = $(P_mode[])\")\nend\n\n# Collect results\npowers = [power(mode)[] for mode in u_vec]\npeak_intensities = [maximum(intensity(mode)) for mode in u_vec]","category":"page"},{"location":"api/fields/fields/#Broadcasting-and-Indexing","page":"API","title":"Broadcasting and Indexing","text":"","category":"section"},{"location":"api/fields/fields/#Base.Broadcast.broadcasted-Tuple{Function, ScalarField}","page":"API","title":"Base.Broadcast.broadcasted","text":"broadcasted(f::Function, u::ScalarField) -> ScalarField\n\nApply function f element-wise to the electric field. Returns a new ScalarField with transformed data.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.getindex-Tuple{ScalarField, Any}","page":"API","title":"Base.getindex","text":"getindex(u::ScalarField, i...)\n\nAccess elements of the electric field. Returns a view into the field data.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Base.conj-Tuple{ScalarField}","page":"API","title":"Base.conj","text":"conj(u::ScalarField) -> ScalarField\n\nReturn complex conjugate of the field. Creates a new field with conjugated electric field values.\n\n\n\n\n\n","category":"method"},{"location":"api/fields/fields/#Examples-8","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"# Broadcasting\nu_scaled = 2.0 .* u\nu_shifted = u .+ 1.0\n\n# Indexing (returns view)\nmode_1 = u[:, :, 1]\nrow = u[32, :, :]\n\n# Complex conjugate\nu_conj = conj(u)","category":"page"},{"location":"api/fields/fields/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/fields/fields/#Data-Layout","page":"API","title":"Data Layout","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"First Nd dimensions: spatial (x, y for 2D)\nRemaining dimensions: modes, wavelengths, etc.\nContiguous in memory for performance","category":"page"},{"location":"api/fields/fields/#Wavelength-Handling","page":"API","title":"Wavelength Handling","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Single wavelength: stored as scalar, broadcast to field\nMultiple wavelengths: array broadcasts with extra (non-spatial) dimensions","category":"page"},{"location":"api/fields/fields/#Tilt-Handling","page":"API","title":"Tilt Handling","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Tilts are passed as (θx, θy) tuples (scalars or arrays) to the constructor\nInternally stored as tuple of arrays for in-place modification\nEach tilt component broadcasts with extra (non-spatial) dimensions\nTilts represent Fourier offset: fx₀ = sin(θx)/λ","category":"page"},{"location":"api/fields/fields/#Power-Calculation","page":"API","title":"Power Calculation","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Power = ∫∫ |u(x,y)|² dx dy\nNumerical integration: P ≈ Σᵢⱼ |u[i,j]|² × dx × dy\nUnits depend on field amplitude units and spatial units","category":"page"},{"location":"api/fields/fields/#Intensity-vs-Power","page":"API","title":"Intensity vs Power","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Intensity: |u(x,y)|² (per unit area)\nPower: Spatial integral of intensity\nFor multi-mode: intensity sums over modes, power is per-mode","category":"page"},{"location":"api/fields/fields/#Coupling-Efficiency","page":"API","title":"Coupling Efficiency","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"η = |⟨u₁,u₂⟩|² / (‖u₁‖ ‖u₂‖)\nAlways real, between 0 and 1\nInsensitive to global phase\nEquals 1 for identical fields","category":"page"},{"location":"api/fields/fields/#Memory-Considerations","page":"API","title":"Memory Considerations","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"copy() creates independent copy of data\nsimilar() allocates uninitialized memory\nset_field_data() creates new field using provided data and same other parameters\nUse views for slicing without copying","category":"page"},{"location":"api/fields/fields/#Performance-Tips","page":"API","title":"Performance Tips","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Pre-allocate: Use similar() for temporary fields\nIn-place operations: Modify .electric directly when possible\nAvoid unnecessary copies: Use set_field_data() or views\nVectorization: Use vec() only when needed for iteration\nGPU: Field data can be moved to GPU with CUDA.cu(u)","category":"page"},{"location":"api/fields/fields/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/fields/fields/","page":"API","title":"API","text":"Modes for generating field data\nGridUtils for coordinate systems","category":"page"},{"location":"api/modes/#Modes","page":"Modes","title":"Modes","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Optical mode generation and spatial layouts.","category":"page"},{"location":"api/modes/#Overview","page":"Modes","title":"Overview","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"The Modes module provides:","category":"page"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Gaussian beam families (Gaussian, Hermite-Gaussian, Laguerre-Gaussian)\nSpatial layouts for mode composition and multi-mode configurations\nSpeckle generation with controlled statistics and envelope\nMode stacks for multi-mode generation","category":"page"},{"location":"api/modes/#Quick-Example","page":"Modes","title":"Quick Example","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"using FluxOptics\n\n# Single Gaussian mode\ngaussian = Gaussian(20.0)  # 20 μm waist\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nfield = gaussian(xv, yv)\n\n# Array of Hermite-Gaussian modes\nmodes = hermite_gaussian_groups(15.0, 4)  # All HG modes up to order 3\n\n# Spatial layout with replicated modes\nlayout = Modes.GridLayout(3, 3, 50.0, 50.0)  # 3×3 grid\nmode_stack = generate_mode_stack(layout, 128, 128, 2.0, 2.0, gaussian)","category":"page"},{"location":"api/modes/#Key-Types","page":"Modes","title":"Key Types","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Gaussian, HermiteGaussian, LaguerreGaussian: Beam modes\nPointLayout, GridLayout, TriangleLayout: Spatial arrangements\nCustomLayout: User-defined layouts","category":"page"},{"location":"api/modes/#Key-Functions","page":"Modes","title":"Key Functions","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"hermite_gaussian_groups: Generate complete mode sets\ngenerate_mode_stack: Create multi-mode field arrays\ngenerate_speckle: Random speckle patterns","category":"page"},{"location":"api/modes/#See-Also","page":"Modes","title":"See Also","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"GridUtils for coordinate transformations\nFields for using modes with ScalarField","category":"page"},{"location":"api/modes/#Index","page":"Modes","title":"Index","text":"","category":"section"},{"location":"api/modes/","page":"Modes","title":"Modes","text":"Modules = [FluxOptics.Modes]\nOrder = [:type, :function]","category":"page"},{"location":"api/modes/modes/#Modes-API","page":"API","title":"Modes API","text":"","category":"section"},{"location":"api/modes/modes/#Gaussian-Beam-Modes","page":"API","title":"Gaussian Beam Modes","text":"","category":"section"},{"location":"api/modes/modes/#Gaussian-Beams","page":"API","title":"Gaussian Beams","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.Gaussian1D","page":"API","title":"FluxOptics.Modes.Gaussian1D","text":"Gaussian1D(w0::Real; norm_constant=nothing)\nGaussian1D(w0::Real, λ::Real, z::Real; constant_phase=true, norm_constant=nothing)\n\nCreate a one-dimensional Gaussian mode.\n\nThe first form creates a Gaussian at the beam waist, while the second includes propagation effects at distance z from the waist.\n\nArguments\n\nw0::Real: Beam waist radius\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\nnorm_constant=nothing: Custom normalization constant - defines the peak intensity (default uses proper Gaussian normalization)\n\nReturns\n\nGaussian1D mode that can be evaluated at spatial positions.\n\nExamples\n\njulia> g = Gaussian1D(10.0);  # 10 μm waist at focus\n\njulia> nx = 40;  # 40 points\n\njulia> dx = 4.0;  # in µm\n\njulia> x, = spatial_vectors(40, dx);\n\njulia> amplitudes = g(x);\n\njulia> isapprox(sum(abs2, amplitudes) * dx, 1)  # Normalization to 1 by default\ntrue\n\njulia> g_prop = Gaussian1D(10.0, 1.064, 1000.0);  # Propagated 1 mm\n\njulia> amplitudes_prop = g_prop(x);\n\njulia> isapprox(sum(abs2, amplitudes_prop) * dx, 1; atol=1e-5)\ntrue\n\nSee also: HermiteGaussian1D, Gaussian, HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.Gaussian","page":"API","title":"FluxOptics.Modes.Gaussian","text":"Gaussian(w0::Real; norm_constant=nothing)\nGaussian(w0x::Real, w0y::Real; norm_constant=nothing)\nGaussian(w0::Real, λ::Real, z::Real; constant_phase=true, norm_constant=nothing)\nGaussian(w0x::Real, w0y::Real, λ::Real, z::Real; constant_phase=true, norm_constant=nothing)\n\nCreate a two-dimensional Gaussian mode.\n\nArguments\n\nw0::Real: Beam waist radius for circular beam\nw0x::Real, w0y::Real: Beam waist radii in x and y directions for elliptical beam\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\nnorm_constant=nothing: Custom normalization constant - defines the peak intensity (default uses proper Gaussian normalization)\n\nReturns\n\nGaussian mode that can be evaluated at spatial coordinates.\n\nExamples\n\njulia> g = Gaussian(10.0);  # Circular beam, 50 μm waist\n\njulia> nx, ny = 64, 64;\n\njulia> dx, dy = 4.0, 4.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> field = zeros(ComplexF64, nx, ny);\n\njulia> g(field, xv, yv);  # Evaluate on grid (in-place)\n\njulia> isapprox(sum(abs2, field) * dx * dy, 1)  # Check normalization\ntrue\n\njulia> g_ellip = Gaussian(10.0, 20.0, 1.064, 1000.0);  # Elliptical beam, wavelength 1.064 µm, propagated 1 mm\n\njulia> field_ellip = g_ellip(xv, yv);  # Direct evaluation (out-of-place)\n\njulia> isapprox(sum(abs2, field_ellip) * dx * dy, 1)\ntrue\n\nSee also: HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"using FluxOptics\n\n# Simple 2D Gaussian at focus\ng = Gaussian(25.0)  # 25 μm waist\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nfield = g(xv, yv)\n\n# Elliptical Gaussian\ng_ellip = Gaussian(20.0, 30.0)  # Different waists in x and y\nfield_ellip = g_ellip(xv, yv)\n\n# Propagated Gaussian\ng_prop = Gaussian(25.0, 1.064, 1000.0)  # At z=1mm from waist\nfield_prop = g_prop(xv, yv)","category":"page"},{"location":"api/modes/modes/#Hermite-Gaussian-Modes","page":"API","title":"Hermite-Gaussian Modes","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.HermiteGaussian1D","page":"API","title":"FluxOptics.Modes.HermiteGaussian1D","text":"HermiteGaussian1D(w0::Real, n::Integer)\nHermiteGaussian1D(w0::Real, n::Integer, λ::Real, z::Real; constant_phase=true)\n\nCreate a one-dimensional Hermite-Gaussian mode HG_n.\n\nArguments\n\nw0::Real: Beam waist radius\nn::Integer: Mode number (≥ 0)\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\n\nReturns\n\nHermiteGaussian1D mode that can be evaluated at spatial positions.\n\nExamples\n\njulia> hg0 = HermiteGaussian1D(20.0, 0);  # HG_0 (Gaussian)\n\njulia> hg1 = HermiteGaussian1D(20.0, 1);  # HG_1 (first excited mode)\n\njulia> nx = 64;\n\njulia> dx = 2.0;\n\njulia> x, = spatial_vectors(nx, dx);\n\njulia> field0 = hg0(x);\n\njulia> field1 = hg1(x);\n\njulia> isapprox(sum(abs2, field0) * dx, 1)  # Check normalization\ntrue\n\njulia> isapprox(sum(field0 .* conj.(field1)) * dx, 0; atol = 1e-15)  # Orthogonality check\ntrue\n\nSee also: Gaussian1D, Gaussian, HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.HermiteGaussian","page":"API","title":"FluxOptics.Modes.HermiteGaussian","text":"HermiteGaussian(w0::Real, m::Integer, n::Integer)\nHermiteGaussian(w0x::Real, w0y::Real, m::Integer, n::Integer)\nHermiteGaussian(w0::Real, m::Integer, n::Integer, λ::Real, z::Real; constant_phase=true)\nHermiteGaussian(w0x::Real, w0y::Real, m::Integer, n::Integer, λ::Real, z::Real; constant_phase=true)\n\nCreate a two-dimensional Hermite-Gaussian mode HG_{m,n}.\n\nArguments\n\nw0::Real: Beam waist radius for circular beam\nw0x::Real, w0y::Real: Beam waist radii in x and y directions\nm::Integer, n::Integer: Mode numbers in x and y directions (≥ 0)\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\n\nReturns\n\nHermiteGaussian mode that can be evaluated at spatial coordinates.\n\nExamples\n\njulia> hg00 = HermiteGaussian(10.0, 0, 0);  # Fundamental mode\n\njulia> hg10 = HermiteGaussian(10.0, 1, 0);  # First excited in x\n\njulia> hg01 = HermiteGaussian(10.0, 0, 1);  # First excited in y\n\njulia> nx, ny = 64, 64;\n\njulia> dx, dy = 2.0, 2.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> field00 = hg00(xv, yv);\n\njulia> field10 = hg10(xv, yv);\n\njulia> isapprox(sum(abs2, field00) * dx * dy, 1)  # Check normalization\ntrue\n\njulia> isapprox(sum(field00 .* conj.(field10)) * dx * dy, 0; atol = 1e-15)  # Orthogonality\ntrue\n\nSee also: Gaussian, LaguerreGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.hermite_gaussian_groups","page":"API","title":"FluxOptics.Modes.hermite_gaussian_groups","text":"hermite_gaussian_groups(w0, n_groups::Int)\n\nGenerate all Hermite-Gaussian modes up to a given group number.\n\nCreates all HGₘₙ modes where m + n < n_groups, ordered by increasing total mode number. This is useful for modal decomposition and beam shaping applications.\n\nArguments\n\nw0: Beam waist radius\nn_groups::Int: Maximum group number\n\nReturns\n\nVector of HermiteGaussian modes.\n\nExamples\n\njulia> modes = hermite_gaussian_groups(10.0, 3);\n\njulia> length(modes)  # Modes: HG_00, HG_10, HG_01, HG_20, HG_11, HG_02\n6\n\njulia> nx, ny = 64, 64;\n\njulia> dx, dy = 2.0, 2.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> fields = [mode(xv, yv) for mode in modes];\n\njulia> all(abs(sum(abs2, field) * dx * dy - 1.0) < 1e-10 for field in fields)  # All normalized\ntrue\n\njulia> modes = hermite_gaussian_groups(10.0, 4);\n\njulia> length(modes)  # Groups 0, 1, 2, 3 give 1+2+3+4 = 10 modes\n10\n\nSee also: Gaussian, HermiteGaussian, LaguerreGaussian\n\n\n\n\n\n","category":"function"},{"location":"api/modes/modes/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"# Single HG mode\nhg21 = HermiteGaussian(15.0, 2, 1)  # HG₂₁\nfield_hg = hg21(xv, yv)\n\n# Complete set of modes up to order N\nN = 4\nmodes = hermite_gaussian_groups(12.0, N)\n# Returns HG₀₀, HG₁₀, HG₀₁, HG₂₀, HG₁₁, HG₀₂, ...\n\n# Check orthogonality\nmode_fields = [m(xv, yv) for m in modes]\ndot(mode_fields[1], mode_fields[2]) * 2.0 * 2.0  # ≈ 0","category":"page"},{"location":"api/modes/modes/#Laguerre-Gaussian-Modes","page":"API","title":"Laguerre-Gaussian Modes","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.LaguerreGaussian","page":"API","title":"FluxOptics.Modes.LaguerreGaussian","text":"LaguerreGaussian(w0::Real, p::Integer, l::Integer; kind=:vortex)\nLaguerreGaussian(w0::Real, p::Integer, l::Integer, λ::Real, z::Real; constant_phase=true, kind=:vortex)\n\nCreate a Laguerre-Gaussian mode LGₚₗ.\n\nArguments\n\nw0::Real: Beam waist radius\np::Integer: Radial mode number (≥ 0)\nl::Integer: Azimuthal mode number (any integer)\nλ::Real: Wavelength (for propagated version)\nz::Real: Propagation distance from waist (for propagated version)\nconstant_phase=true: Include exp(ikz) phase factor\nkind: Mode type - :vortex (default), :even, or :odd\n:vortex: exp(ilφ) phase dependence\n:even: cos(lφ) dependence  \n:odd: sin(lφ) dependence\n\nReturns\n\nLaguerreGaussian mode that can be evaluated at spatial coordinates.\n\nExamples\n\njulia> lg00 = LaguerreGaussian(10.0, 0, 0);  # Fundamental mode (Gaussian)\n\njulia> lg01 = LaguerreGaussian(10.0, 0, 1);  # Vortex beam\n\njulia> nx, ny = 65, 65;\n\njulia> dx, dy = 2.0, 2.0;\n\njulia> xv, yv = spatial_vectors(nx, ny, dx, dy);\n\njulia> field00 = lg00(xv, yv);\n\njulia> field01 = lg01(xv, yv);\n\njulia> isapprox(sum(abs2, field00) * dx * dy, 1)  # Check normalization\ntrue\n\njulia> abs(field01[nx÷2+1, ny÷2+1]) < 1e-10  # LG_01 has zero at center (vortex)\ntrue\n\njulia> lg_even = LaguerreGaussian(10.0, 0, 2; kind=:even);\n\njulia> field_even = lg_even(xv, yv);\n\njulia> all(isreal, field_even)  # Even modes are real-valued\ntrue\n\nSee also: Gaussian, HermiteGaussian\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#Examples-3","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"# Fundamental mode (equivalent to Gaussian)\nlg00 = LaguerreGaussian(20.0, 0, 0)\nfield_lg00 = lg00(xv, yv)\n\n# Vortex beam (default)\nlg01 = LaguerreGaussian(20.0, 0, 1)  # Donut beam\nfield_vortex = lg01(xv, yv)\n\n# Even/odd superpositions\nlg_even = LaguerreGaussian(20.0, 0, 2; kind=:even)\nlg_odd = LaguerreGaussian(20.0, 0, 2; kind=:odd)\n\n# These are real-valued\n@assert all(isreal, lg_even(xv, yv))\n@assert all(isreal, lg_odd(xv, yv))","category":"page"},{"location":"api/modes/modes/#Spatial-Layouts","page":"API","title":"Spatial Layouts","text":"","category":"section"},{"location":"api/modes/modes/#Layout-Types","page":"API","title":"Layout Types","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.PointLayout","page":"API","title":"FluxOptics.Modes.PointLayout","text":"PointLayout(n, p=(0,0), t=Id2D())\n\nCreate a layout of n identical points.\n\nArguments\n\nn: Number of points\np=(0,0): Position of the point\nt=Id2D(): Coordinate transformation\n\nReturns\n\nPointLayout that can be iterated to get point positions.\n\nExamples\n\njulia> layout = Modes.PointLayout(3, (100.0, 50.0));\n\njulia> positions = collect(layout);\n\njulia> length(positions)\n3\n\njulia> all(pos == (100.0, 50.0) for pos in positions)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.GridLayout","page":"API","title":"FluxOptics.Modes.GridLayout","text":"GridLayout(nx, ny, px, py, t=Id2D())\n\nCreate a regular rectangular grid layout.\n\nArguments\n\nnx, ny: Number of points in x and y directions\npx, py: Spacing between points in x and y\nt=Id2D(): Coordinate transformation\n\nReturns\n\nGridLayout that can be iterated to get point positions.\n\nExamples\n\njulia> layout = Modes.GridLayout(2, 3, 100.0, 50.0);\n\njulia> positions = collect(layout);\n\njulia> length(positions)  # 2×3 = 6 points\n6\n\njulia> positions[1]  # First point (centered grid)\n(-50.0, -50.0)\n\njulia> positions[end]  # Last point\n(50.0, 50.0)\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.TriangleLayout","page":"API","title":"FluxOptics.Modes.TriangleLayout","text":"TriangleLayout(np, px, py, t=Id2D())\n\nCreate a triangular arrangement of points.\n\nArguments\n\nnp: Number of points along triangle edge\npx, py: Spacing between points in x and y\nt=Id2D(): Coordinate transformation\n\nReturns\n\nTriangleLayout with np(np+1)/2 total points.\n\nExamples\n\njulia> layout = Modes.TriangleLayout(3, 100.0, 100.0);\n\njulia> length(layout)  # 3×4/2 = 6 points\n6\n\njulia> layout = Modes.TriangleLayout(4, 50.0, 50.0);\n\njulia> length(layout)  # 4×5/2 = 10 points\n10\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#FluxOptics.Modes.CustomLayout","page":"API","title":"FluxOptics.Modes.CustomLayout","text":"CustomLayout(positions, t=Id2D())\n\nCreate a layout from custom list of positions.\n\nArguments\n\npositions: Vector of (x,y) tuples specifying point positions\nt=Id2D(): Coordinate transformation applied to all positions\n\nReturns\n\nCustomLayout that can be iterated to get transformed positions.\n\nExamples\n\njulia> positions = [(0.0, 0.0), (100.0, 0.0), (50.0, 86.6)];\n\njulia> layout = Modes.CustomLayout(positions);\n\njulia> collect(layout) == positions\ntrue\n\njulia> layout_rot = Modes.CustomLayout(positions, Rot2D(π/2));\n\njulia> rotated = collect(layout_rot);\n\njulia> all(isapprox.(rotated[2], (0.0, 100.0), atol=1e-12))  # Second point rotated 90°\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/modes/modes/#Mode-Stack-Generation","page":"API","title":"Mode Stack Generation","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.generate_mode_stack","page":"API","title":"FluxOptics.Modes.generate_mode_stack","text":"generate_mode_stack(layout, nx, ny, dx, dy, mode; t=Id2D(), normalize=true)\ngenerate_mode_stack(layout, nx, ny, dx, dy, mode_vector; t=Id2D(), normalize=true)\ngenerate_mode_stack(nx, ny, dx, dy, mode_vector; t=Id2D(), normalize=true)\n\nGenerate arrays of optical modes at specified positions.\n\nThe first form replicates the same mode at each layout position. The second form uses different modes from mode_vector at each position. The third form places modes at the origin (single position each).\n\nArguments\n\nlayout: Spatial layout determining mode positions\nnx, ny: Grid size for each mode field\ndx, dy: Pixel size\nmode: Single mode to replicate at all positions\nmode_vector: Vector of modes (one per position)\nt=Id2D(): Additional transformation applied to all modes\nnormalize=true: Normalize each mode to unit power\n\nReturns\n\n3D complex array of size (nx, ny, n_modes) containing mode fields.\n\nExamples\n\njulia> layout = Modes.GridLayout(2, 2, 50.0, 50.0);\n\njulia> gaussian = Gaussian(10.0);\n\njulia> modes = generate_mode_stack(layout, 64, 64, 2.0, 2.0, gaussian);\n\njulia> size(modes)\n(64, 64, 4)\n\njulia> sum(abs2, modes[:, :, 1]) * 2.0 * 2.0  # Check first mode normalization\n1.0000000000000007\n\njulia> hg_modes = [HermiteGaussian(25.0, m, n) for m in 0:1 for n in 0:1];\n\njulia> modes_hg = generate_mode_stack(layout, 64, 64, 2.0, 2.0, hg_modes);\n\njulia> size(modes_hg)\n(64, 64, 4)\n\njulia> lg_modes = [LaguerreGaussian(20.0, 0, l) for l in 0:2];\n\njulia> modes_lg = generate_mode_stack(64, 64, 2.0, 2.0, lg_modes);\n\njulia> size(modes_lg)  # No layout specified, modes at origin\n(64, 64, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/modes/modes/#Examples-4","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"# Replicate same mode at each position\ngaussian = Gaussian(10.0)\nlayout = Modes.GridLayout(2, 3, 80.0, 80.0)\nmodes = generate_mode_stack(layout, 256, 256, 1.0, 1.0, gaussian)\n# Returns 256×256×6 array\n\n# Different mode at each position\nhg_modes = [HermiteGaussian(12.0, m, n) \n            for m in 0:2 for n in 0:2]\nlayout = Modes.GridLayout(3, 3, 60.0, 60.0)\nmodes = generate_mode_stack(layout, 128, 128, 1.5, 1.5, hg_modes)\n# Returns 128×128×9 array\n\n# Single position, multiple modes\nlg_modes = [LaguerreGaussian(15.0, 0, l) for l in 0:5]\nmodes = generate_mode_stack(128, 128, 2.0, 2.0, lg_modes)\n# Returns 128×128×6 array (all centered)\n\n# With coordinate transformations\ntransform = Shift2D(20.0, -10.0) ∘ Rot2D(π/4)\nlayout_transformed = Modes.GridLayout(3, 3, 50.0, 50.0, transform)","category":"page"},{"location":"api/modes/modes/#Speckle-Generation","page":"API","title":"Speckle Generation","text":"","category":"section"},{"location":"api/modes/modes/#FluxOptics.Modes.generate_speckle","page":"API","title":"FluxOptics.Modes.generate_speckle","text":"generate_speckle(ns, ds, λ, NA; envelope=nothing, center=(0,0), t=Id2D(), normalize=true)\n\nGenerate random speckle pattern with controlled numerical aperture.\n\nCreates a complex random field with Fourier components limited by the numerical aperture, producing realistic speckle with controlled correlation length.\n\nArguments\n\nns: Grid dimensions - (nx,) for 1D, (nx, ny) for 2D, (nx, ny, nz) for 3D\nds: Pixel sizes - (dx,), (dx, dy), or (dx, dy, dz)\nλ: Wavelength\nNA: Numerical aperture controlling speckle size\nenvelope=nothing: Optional envelope function (Mode type)\ncenter=(0,0): Center position for envelope\nt=Id2D(): Coordinate transformation for envelope\nnormalize=true: Normalize the speckle distribution to unit power\n\nReturns\n\nComplex array with random speckle pattern.\n\nExamples\n\njulia> speckle = generate_speckle((64, 64), (1.0, 1.0), 1.064, 0.1);\n\njulia> isapprox(sum(abs2, speckle), 1)\ntrue\n\njulia> envelope = Gaussian(20.0);\n\njulia> speckle_env = generate_speckle((64, 64), (1.0, 1.0), 1.064, 0.1; envelope=envelope);\n\njulia> isapprox(sum(abs2, speckle_env), 1)\ntrue\n\njulia> speckle_1d = generate_speckle((128,), (0.5,), 1.064, 0.2);\n\njulia> isapprox(sum(abs2, speckle_1d) * 0.5, 1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/modes/modes/#Examples-5","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"# 2D speckle with controlled correlation length\nspeckle = generate_speckle((256, 256), (1.0, 1.0), 1.064, 0.2)\n# Returns 256×256 complex array, normalized to unit power\n\n# 1D speckle\nspeckle_1d = generate_speckle((512,), (0.5,), 1.064, 0.15)\n\n# 3D speckle\nspeckle_3d = generate_speckle((64, 64, 64), (2.0, 2.0, 2.0), 1.064, 0.1)\n\n# With Gaussian envelope\nenvelope = Gaussian(50.0)\nspeckle_gauss = generate_speckle(\n    (256, 256), (1.0, 1.0), 1.064, 0.2;\n    envelope=envelope\n)\n\n# Controlling speckle statistics via NA\nspeckle_fine = generate_speckle((256, 256), (1.0, 1.0), 1.064, 0.8)    # High NA\nspeckle_coarse = generate_speckle((256, 256), (1.0, 1.0), 1.064, 0.05)  # Low NA\n\n# Using with ScalarField\nspeckle_data = generate_speckle((128, 128), (2.0, 2.0), 1.064, 0.15;\n                                envelope=Gaussian(30.0))\nu = ScalarField(speckle_data, (2.0, 2.0), 1.064)","category":"page"},{"location":"api/modes/modes/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/modes/modes/#Mode-Normalization","page":"API","title":"Mode Normalization","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"All modes are normalized to unit power by default\nPower = ∫∫ |u(x,y)|² dx dy = 1\nFor custom normalization, use norm_constant parameter","category":"page"},{"location":"api/modes/modes/#Mode-Propagation","page":"API","title":"Mode Propagation","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"Use λ and z parameters for Gaussian beam propagation\nIncludes Gouy phase shift\nconstant_phase=true includes exp(ikz) term","category":"page"},{"location":"api/modes/modes/#Layout-Centering","page":"API","title":"Layout Centering","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"Layouts are centered at (0, 0) by default\nUse coordinate transformations to shift layouts","category":"page"},{"location":"api/modes/modes/#Speckle-Statistics","page":"API","title":"Speckle Statistics","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"Correlation length ≈ λ / NA\nHigh NA → fine speckle (small correlation length)\nLow NA → coarse speckle (large correlation length)\nSpeckle is fully developed (unit contrast) without envelope","category":"page"},{"location":"api/modes/modes/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/modes/modes/","page":"API","title":"API","text":"GridUtils for coordinate systems\nFields for ScalarField operations","category":"page"},{"location":"api/gridutils/#GridUtils","page":"GridUtils","title":"GridUtils","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Coordinate systems and transformations for optical field grids.","category":"page"},{"location":"api/gridutils/#Overview","page":"GridUtils","title":"Overview","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"The GridUtils module provides:","category":"page"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Spatial coordinate generation for optical field grids\n2D coordinate transformations (translations, rotations)\nCoordinate composition for complex geometries","category":"page"},{"location":"api/gridutils/#Quick-Example","page":"GridUtils","title":"Quick Example","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"using FluxOptics\n\n# Generate 2D coordinate grid\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\n\n# Create transformation: shift then rotate\ntransform = Rot2D(π/4) ∘ Shift2D(10.0, 5.0)\n\n# Apply to a point\npoint = transform([0.0, 0.0])","category":"page"},{"location":"api/gridutils/#Key-Functions","page":"GridUtils","title":"Key Functions","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"spatial_vectors: Generate coordinate arrays\nShift2D: 2D translation transformation\nRot2D: 2D rotation transformation\nId2D: Identity transformation","category":"page"},{"location":"api/gridutils/#See-Also","page":"GridUtils","title":"See Also","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Modes for using coordinates with optical modes\nFields for ScalarField grid structure","category":"page"},{"location":"api/gridutils/#Index","page":"GridUtils","title":"Index","text":"","category":"section"},{"location":"api/gridutils/","page":"GridUtils","title":"GridUtils","text":"Modules = [FluxOptics.GridUtils]\nOrder = [:type, :function]","category":"page"},{"location":"api/plotting/plotting/#Plotting-API","page":"API","title":"Plotting API","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Loading: This module is loaded conditionally. Use using Makie (or GLMakie, CairoMakie, WGLMakie) before using plotting functions.","category":"page"},{"location":"api/plotting/plotting/#Visualization-Functions","page":"API","title":"Visualization Functions","text":"","category":"section"},{"location":"api/plotting/plotting/#FluxOptics.Plotting.visualize","page":"API","title":"FluxOptics.Plotting.visualize","text":"visualize(u, fs; colormap=:viridis, height=200, show_colorbars=false)\nvisualize(u_vec, fs; colormap=:viridis, height=200, show_colorbars=false)\n\nDisplay optical fields or components with specified visualization functions.\n\nCreates a static heatmap figure showing one or more fields with one or more visualization functions (intensity, phase, etc.). All views are displayed simultaneously in a grid layout. Works with CairoMakie or GLMakie.\n\nArguments\n\nu: Single plottable object (ScalarField, AbstractOpticalComponent, or 2D array)\nu_vec: Vector or tuple of plottable objects (displayed as rows)\nfs: Visualization function or tuple of functions (displayed as columns)\ncolormap: Colormap name(s) - single symbol or tuple matching fs\nheight: Height in pixels per heatmap (default: 200)\nshow_colorbars: Display colorbars for real-valued plots (default: false)\n\nPlottable Types\n\nScalarField: Optical fields\nAbstractOpticalComponent: Phase masks, DOEs, etc. with 2D data\nAbstractArray{<:Number, 2}: Raw 2D arrays\n\nVisualization Functions\n\nCommon functions:\n\nintensity: Total intensity |u|²\nphase: Phase angle in radians\nreal, imag: Real/imaginary parts\nabs: Magnitude\nidentity: Complex field with HSV colormap\n\nExamples\n\nSingle field, single view:\n\nu = ScalarField(gaussian_data, (2.0, 2.0), 1.064)\nfig = visualize(u, intensity)\n\nMultiple representations:\n\nfig = visualize(u, (intensity, phase, real, imag))\n\nMultiple fields (comparison):\n\nfig = visualize([target, optimized], intensity)\n\nCustom colormaps:\n\nfig = visualize(u, (intensity, phase); \n                colormap=(:viridis, :twilight))\n\nWith colorbars:\n\nfig = visualize(u, intensity; show_colorbars=true, height=300)\n\nVisualize component:\n\nphase_mask = Phase(u, (x, y) -> x^2; trainable=true)\nfig = visualize(phase_mask, identity)\n\nNotes\n\nFor large field stacks, prefer visualize_slider to avoid displaying all at once\nComplex-valued results automatically use HSV colormap (:dark or :light)\nWidth computed automatically to maintain aspect ratio\nCompatible with CairoMakie (static) and GLMakie (interactive)\n\nSee also: visualize_slider, intensity, phase\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/plotting/#FluxOptics.Plotting.visualize_slider","page":"API","title":"FluxOptics.Plotting.visualize_slider","text":"visualize_slider(u_vec, fs; colormap=:viridis, height=400)\n\nDisplay field sequence with interactive slider for navigation.\n\nCreates an interactive figure with a horizontal slider to navigate through a sequence of fields. All visualization functions update in real-time when moving the slider. Requires GLMakie (interactive backend).\n\nThis is preferred over visualize for large field sequences (propagation steps, optimization iterations, etc.) as it avoids displaying all fields simultaneously.\n\nArguments\n\nu_vec: Vector or tuple of plottable objects (sequence to navigate)\nfs: Visualization function or tuple of functions\ncolormap: Colormap name(s) - single symbol or tuple matching fs\nheight: Height in pixels per heatmap (default: 400)\n\nRequirements\n\nMust use GLMakie (interactive backend with slider support)\nCairoMakie and WGLMakie do not support interactive sliders\n\nExamples\n\nPropagation sequence:\n\nusing GLMakie\n\n# Create propagation sequence\ndistances = range(0, 2000, length=50)\nu0 = ScalarField(gaussian_data, (2.0, 2.0), 1.064)\nsequence = [propagate(u0, ASProp(u0, z), Forward) for z in distances]\n\n# Interactive slider\nfig = visualize_slider(sequence, intensity)\ndisplay(fig)\n\nMultiple representations:\n\nfig = visualize_slider(sequence, (intensity, phase))\n\nOptimization iterations:\n\n# Save field at each iteration\nhistory = ScalarField[]\nfor iter in 1:100\n    # ... optimization step ...\n    push!(history, copy(system()))\nend\n\nfig = visualize_slider(history, (intensity, phase))\n\nCustom colormaps:\n\nfig = visualize_slider(sequence, (intensity, phase);\n                       colormap=(:inferno, :twilight),\n                       height=500)\n\nUse Cases\n\nPropagation through optical system\nOptimization convergence visualization\nWavelength sweeps\nParameter scans\nTime evolution\n\nPerformance\n\nOnly current frame is rendered (efficient for large sequences)\nSlider provides smooth navigation\nConsider downsampling very large fields if interactive response is slow\n\nNotes\n\nSlider range: 1 to length(u_vec)\nAll views update synchronously\nGLMakie required - will error with CairoMakie\n\nSee also: visualize, intensity, phase\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/plotting/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/plotting/plotting/#Single-Field-Visualization","page":"API","title":"Single Field Visualization","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"using FluxOptics, GLMakie\n\n# Create field\nu = ScalarField(ones(ComplexF64, 256, 256), (2.0, 2.0), 1.064)\nxv, yv = spatial_vectors(256, 256, 2.0, 2.0)\nu.electric .= Gaussian(30.0)(xv, yv)\n\n# Visualize intensity\nfig = visualize(u, intensity)\ndisplay(fig)\n\n# Visualize phase\nfig = visualize(u, phase)\n\n# Complex field with HSV colormap\nfig = visualize(u, identity)  # Hue=phase, Value=magnitude","category":"page"},{"location":"api/plotting/plotting/#Multiple-Representations","page":"API","title":"Multiple Representations","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Show multiple views side-by-side\nfig = visualize(u, (intensity, phase, real, imag))\ndisplay(fig)\n\n# Different colormaps per view\nfig = visualize(u, (intensity, phase); \n                colormap=(:viridis, :twilight))","category":"page"},{"location":"api/plotting/plotting/#Multi-Mode-Fields","page":"API","title":"Multi-Mode Fields","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Visualize all modes\ndata = generate_mode_stack(layout, 128, 128, 2.0, 2.0, Gaussian(15.0))\nu_multi = ScalarField(data, (2.0, 2.0), 1.064)\n\n# Each mode shown separately\nfig = visualize(u_multi, intensity)","category":"page"},{"location":"api/plotting/plotting/#Field-Sequences-with-Slider","page":"API","title":"Field Sequences with Slider","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Propagation sequence\ndistances = range(0, 2000, length=50)\nu0 = ScalarField(gaussian_data, (2.0, 2.0), 1.064)\n\npropagation = [propagate(u0, ASProp(u0, z), Forward) for z in distances]\n\n# Interactive slider\nfig = visualize_slider(propagation, intensity)\ndisplay(fig)\n\n# Multiple representations with slider\nfig = visualize_slider(propagation, (intensity, phase))","category":"page"},{"location":"api/plotting/plotting/#Component-Visualization","page":"API","title":"Component Visualization","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Visualize phase mask\nphase_mask = Phase(u, (x, y) -> 0.01*(x^2 + y^2); trainable=true)\nfig = visualize(phase_mask, identity)\n\n# Visualize TeaDOE surface\ndoe = TeaDOE(u, 0.5, (x, y) -> sin(2π*x/50)*sin(2π*y/50); trainable=true)\nfig = visualize(doe, real)","category":"page"},{"location":"api/plotting/plotting/#Comparison-Visualization","page":"API","title":"Comparison Visualization","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Compare target vs optimized\ntarget = ScalarField(target_data, (2.0, 2.0), 1.064)\noptimized = system()\n\n# Stack vertically for comparison\nfig = visualize([target, optimized], (intensity, phase))\ndisplay(fig)","category":"page"},{"location":"api/plotting/plotting/#Custom-Transformations","page":"API","title":"Custom Transformations","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Custom visualization function\nlog_intensity(u) = log10.(intensity(u) .+ 1e-10)\n\nfig = visualize(u, log_intensity)\n\n# Multiple custom functions\npower_spectrum(u) = abs2.(fftshift(fft(u.electric)))\nfig = visualize(u, (intensity, power_spectrum))","category":"page"},{"location":"api/plotting/plotting/#Styling-Options","page":"API","title":"Styling Options","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Larger figures\nfig = visualize(u, intensity; height=400)\n\n# Show colorbars\nfig = visualize(u, (intensity, phase); \n                show_colorbars=true)\n\n# Custom colormap\nfig = visualize(u, intensity; colormap=:inferno)","category":"page"},{"location":"api/plotting/plotting/#Complex-Field-Colormaps","page":"API","title":"Complex Field Colormaps","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"For complex-valued visualizations (when using identity or when function returns complex):","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Dark colormap (default): Hue=phase, Value=magnitude\nfig = visualize(u, identity; colormap=:dark)\n\n# Light colormap: Hue=phase, Saturation=magnitude\nfig = visualize(u, identity; colormap=:light)","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"HSV mapping:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Hue: Phase angle (0 to 2π → 0° to 360°)\nSaturation (light mode): Magnitude\nValue (dark mode): Magnitude","category":"page"},{"location":"api/plotting/plotting/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/plotting/plotting/#Plottable-Types","page":"API","title":"Plottable Types","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"The following can be visualized:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"ScalarField: Optical fields\nAbstractOpticalComponent: Components with 2D data (Phase, Mask, TeaDOE)\nAbstractArray{<:Number, 2}: Raw 2D arrays","category":"page"},{"location":"api/plotting/plotting/#Visualization-Functions-2","page":"API","title":"Visualization Functions","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Functions passed to visualize must:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Accept a plottable object as input\nReturn a 2D array (real, complex, or RGB)","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Common built-in functions:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"intensity(u)  # |u|² - total intensity\nphase(u)      # arg(u) - phase in radians\nreal(u)       # Re(u)\nimag(u)       # Im(u)\nabs(u)        # |u| - magnitude\nidentity(u)   # u itself (complex → HSV colormap)","category":"page"},{"location":"api/plotting/plotting/#Colormap-Selection","page":"API","title":"Colormap Selection","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Real-valued outputs: Use standard Makie colormaps (:viridis, :inferno, :twilight, etc.)\nComplex-valued outputs: Use :dark or :light for HSV mapping\nPer-view colormaps: Pass tuple matching number of views","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Valid colormaps from ColorSchemes.jl are automatically checked.","category":"page"},{"location":"api/plotting/plotting/#Layout-and-Sizing","page":"API","title":"Layout and Sizing","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"height: Control figure height (default: 200 for visualize, 400 for visualize_slider)\nWidth automatically computed to maintain aspect ratio\nMultiple views arranged in grid automatically","category":"page"},{"location":"api/plotting/plotting/#Performance","page":"API","title":"Performance","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"visualize: Displays all fields simultaneously - can be slow/memory-intensive for large stacks\nvisualize_slider: Only renders current frame - efficient for large sequences\nArrays are collected (GPU → CPU) automatically if needed\nConsider downsampling very large fields for interactive visualization","category":"page"},{"location":"api/plotting/plotting/#Slider-Interaction","page":"API","title":"Slider Interaction","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"visualize_slider provides:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Horizontal slider to navigate through sequence\nReal-time update of all displayed views\nRequires GLMakie - interactive backend with slider support\nUseful for propagation sequences, optimization iterations, wavelength sweeps","category":"page"},{"location":"api/plotting/plotting/#Conditional-Loading","page":"API","title":"Conditional Loading","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"The Plotting module uses @require for conditional loading:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# In your script/notebook\nusing FluxOptics\nusing GLMakie  # Triggers Plotting module load\n\n# Now plotting functions are available\nvisualize(field, intensity)","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Supported Makie backends:","category":"page"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"GLMakie: Interactive, OpenGL-based (required for visualize_slider)\nCairoMakie: High-quality static plots (PDF/SVG export) - works with visualize only\nWGLMakie: Web-based interactive plots (for Pluto.jl, etc.) - limited slider support","category":"page"},{"location":"api/plotting/plotting/#Advanced-Usage","page":"API","title":"Advanced Usage","text":"","category":"section"},{"location":"api/plotting/plotting/#Custom-Multi-Panel-Layouts","page":"API","title":"Custom Multi-Panel Layouts","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"# Different functions for each mode\nmode_funcs = (intensity, phase, real)\nfig = visualize(u_multi, mode_funcs)","category":"page"},{"location":"api/plotting/plotting/#Saving-Figures","page":"API","title":"Saving Figures","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"using CairoMakie  # For saving\n\nfig = visualize(u, intensity)\nsave(\"field_intensity.png\", fig)\nsave(\"field_intensity.pdf\", fig)  # Vector format","category":"page"},{"location":"api/plotting/plotting/#Animation","page":"API","title":"Animation","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"using GLMakie\n\n# Create propagation sequence\nsequence = [propagate(u0, ASProp(u0, z), Forward) \n            for z in range(0, 2000, length=100)]\n\n# Manual animation\nfig = Figure()\nax = Axis(fig[1, 1])\nhidedecorations!(ax)\n\nfor (i, u) in enumerate(sequence)\n    empty!(ax)\n    heatmap!(ax, intensity(u))\n    sleep(0.05)  # Frame delay\nend","category":"page"},{"location":"api/plotting/plotting/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/plotting/plotting/","page":"API","title":"API","text":"Fields for ScalarField operations\nMakie.jl documentation for advanced plotting\nColorSchemes.jl for available colormaps","category":"page"},{"location":"api/optimisers/optimisers/#OptimisersExt-API","page":"API","title":"OptimisersExt API","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Setup-and-Update","page":"API","title":"Setup and Update","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.make_rules","page":"API","title":"FluxOptics.OptimisersExt.make_rules","text":"make_rules(pairs::Pair{<:AbstractArray, <:AbstractRule}...)\nmake_rules(pairs::Pair{<:AbstractOpticalComponent, <:AbstractRule}...)\n\nCreate a dictionary of optimization rules for specific parameters or optical components.\n\nThis function creates an IdDict that maps parameter arrays to their corresponding optimization rules. This allows different parts of the optical system to use different optimizers (e.g., different learning rates, different algorithms).\n\nArguments\n\npairs: Pairs of (parameter/component, rule) where:\nFirst element: AbstractArray (parameter) or AbstractOpticalComponent \nSecond element: AbstractRule (optimization rule like Descent(0.01))\n\nReturns\n\nIdDict{AbstractArray, AbstractRule} mapping parameter arrays to optimization rules.\n\nExamples\n\njulia> u = ScalarField(zeros(ComplexF64, 64, 64), (2.0, 2.0), 1.064);\n\njulia> phase_mask = Phase(u, (x, y) -> 0.1*(x^2 + y^2); trainable=true);\n\njulia> source = ScalarSource(u; trainable=true);\n\njulia> rules = make_rules(\n           phase_mask => Descent(0.01),    # Slow learning for phase\n           source => Descent(0.1)     # Fast learning for source\n       );\n\njulia> typeof(rules)\nIdDict{AbstractArray, Optimisers.AbstractRule}\n\njulia> length(rules)\n2\n\njulia> opt_state = setup(rules, source |> phase_mask);\n\nSee also: setup, ProxRule, Phase, ScalarSource\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#Optimisers.setup-Tuple{IdDict}","page":"API","title":"Optimisers.setup","text":"setup(rules::IdDict{<:AbstractArray, <:AbstractRule}, model)\nsetup(rules::IdDict{<:AbstractArray, <:AbstractRule}, default_rule::AbstractRule, model)\n\nSet up optimization state with different rules for different parameters.\n\nThis extends Optimisers.setup to accept a dictionary of rules, allowing fine-grained control over which optimizer is used for which parameters. Parameters not in the rules dictionary use the default rule (or NoDescent() if no default provided).\n\nArguments\n\nrules: Dictionary mapping parameter arrays to optimization rules\ndefault_rule: Default rule for parameters not in the rules dictionary\nmodel: The model/parameters to optimize\n\nReturns\n\nNested optimization state structure matching the model structure.\n\nExamples\n\njulia> u = ScalarField(zeros(ComplexF64, 32, 32), (2.0, 2.0), 1.064);\n\njulia> phase_mask = Phase(u, (x, y) -> 0.0; trainable=true);\n\njulia> mask = Mask(u, (x, y) -> 1.0; trainable=true);\n\njulia> rules = make_rules(\n           phase_mask => Descent(0.01),\n           mask => Momentum(0.1, 0.9)\n       );\n\njulia> u = ScalarField(zeros(ComplexF64, 32, 32), (2.0, 2.0), 1.064);\n\njulia> source = ScalarSource(u; trainable=true);\n\njulia> opt_state = setup(rules, NoDescent(), source |> phase_mask |> mask);\n\nSee also: make_rules, Optimisers.update!, ProxRule, NoDescent\n\n\n\n\n\n","category":"method"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Note: update!(opt_state, params, grads) is re-exported from Optimisers.jl. It applies the optimization step to update parameters. See their documentation for details.","category":"page"},{"location":"api/optimisers/optimisers/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"using FluxOptics, Optimisers\n\n# Create components\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\nphase = Phase(u, (x, y) -> 0.0; trainable=true)\nmask = Mask(u, (x, y) -> 1.0; trainable=true)\nsource = ScalarSource(u; trainable=true)\n\n# Per-component rules\nrules = make_rules(\n    phase => Descent(0.01),\n    mask => Momentum(0.05, 0.9),\n    source => NoDescent()  # Keep source fixed\n)\n\n# Setup with default rule for other parameters\nsystem = source |> phase |> mask\nopt_state = setup(rules, Descent(0.001), system)\n\n# Optimization loop\nfor iter in 1:1000\n    grads = gradient(loss, params)[1]\n    update!(opt_state, params, grads)\nend","category":"page"},{"location":"api/optimisers/optimisers/#Optimization-Rules","page":"API","title":"Optimization Rules","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Custom-Rules","page":"API","title":"Custom Rules","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.Fista","page":"API","title":"FluxOptics.OptimisersExt.Fista","text":"Fista(η)\n\nFast Iterative Shrinkage-Thresholding Algorithm (FISTA) optimizer.\n\nFISTA is an accelerated gradient method particularly effective for problems with proximal operators. It provides faster convergence than standard gradient descent for sparse and constrained optimization problems common in computational optics.\n\nArguments\n\nη: Learning rate (stored as η²)\n\nExamples\n\njulia> fista_opt = Fista(0.1);\n\njulia> sparse_rule = ProxRule(Fista(0.05), IstaProx(0.001, 0.0));  # Sparse optimization\n\nSee also: ProxRule, IstaProx, TVProx\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.NoDescent","page":"API","title":"FluxOptics.OptimisersExt.NoDescent","text":"NoDescent()\n\nNo-operation optimizer that performs no parameter updates.\n\nUseful as a default rule for parameters that should remain fixed during optimization, or for ablation studies where you want to disable optimization for certain components.\n\nExamples\n\nrules = make_rules(\n           fixed_component => NoDescent(),    # Don't optimize this\n           active_component => Descent(0.01)  # Optimize this one\n       );\n\nSee also: make_rules, setup, ProxRule\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.ProxRule","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.ProxRule","text":"ProxRule(rule::AbstractRule, prox::AbstractProximalOperator)\n\nCombine an optimization rule with a proximal operator.\n\nThis creates a composite optimization rule that first applies the standard optimization step, then applies a proximal operator for regularization or constraints. This is useful for constrained optimization in inverse optics design.\n\nArguments\n\nrule: Base optimization rule (e.g., Descent, Momentum)\nprox: Proximal operator to apply after the optimization step\n\nReturns\n\nProxRule that applies both the optimizer and proximal operator.\n\nExamples\n\njulia> prox_descent = ProxRule(Descent(0.01), PositiveProx());  # Positive constraint\n\njulia> tv_regularized = ProxRule(Momentum(0.1, 0.9), TVProx(0.001));  # TV regularization\n\njulia> clamped = ProxRule(Descent(0.05), ClampProx(0.0, 1.0));  # Clamp to [0,1]\n\nSee also: IstaProx, TVProx, ClampProx, Fista\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#From-Optimisers.jl","page":"API","title":"From Optimisers.jl","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"FluxOptics also exports standard rules from Optimisers.jl:","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Descent(η): Gradient descent with learning rate η\nMomentum(η, ρ): Momentum optimizer\nNesterov(η, ρ): Nesterov accelerated gradient","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"See Optimisers.jl documentation for more rules (Adam, AdaGrad, etc.).","category":"page"},{"location":"api/optimisers/optimisers/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# FISTA for sparse optimization\nfista_opt = Fista(0.1)\nsparse_rule = ProxRule(fista_opt, IstaProx(0.001, 0.0))\n\n# Standard optimizers\nadam_opt = Optimisers.Adam(0.001)\nmomentum_opt = Momentum(0.01, 0.9)\n\n# No optimization\nfixed_opt = NoDescent()","category":"page"},{"location":"api/optimisers/optimisers/#Proximal-Operators","page":"API","title":"Proximal Operators","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Abstract-Type","page":"API","title":"Abstract Type","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.AbstractProximalOperator","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.AbstractProximalOperator","text":"AbstractProximalOperator\n\nAbstract base type for proximal-like operators used in constrained optimization.\n\nIn the classical sense, proximal operators implement:\n\nprox_λf(x) = argmin_z { f(z) + (1/2λ)||z - x||² }\n\nHowever, this module takes a pragmatic approach and includes:\n\nExact proximal operators: Mathematically rigorous (e.g., soft thresholding)\nProjections: Onto constraint sets (e.g., ClampProx, PositiveProx)\nPlug-and-play operators: Operators that work well empirically for inverse problems,  even without strict proximal interpretation (e.g., learned denoisers, heuristic constraints)\n\nThis flexibility follows the spirit of plug-and-play priors in computational imaging,  where practical performance often matters more than theoretical guarantees.\n\nInterface\n\nSubtypes must implement:\n\ninit(prox::AbstractProximalOperator, x::AbstractArray): Initialize operator state\napply!(prox::AbstractProximalOperator, state, x::AbstractArray): Apply operator in-place\n\nAvailable Operators\n\nPointwiseProx: Apply function element-wise (custom constraints)\nClampProx: Box constraints [a, b]\nPositiveProx: Non-negativity constraint\nIstaProx: Soft thresholding (exact prox of L1 norm)\nTVProx: Total variation denoising (approximate prox)\n\nComposition\n\nOperators can be composed with ∘:\n\ncombined = ClampProx(0.0, 1.0) ∘ PositiveProx()\n\nExamples\n\n# Use with ProxRule\nprox = ClampProx(-π, π)\nrule = ProxRule(Descent(0.01), prox)\n\n# Compose multiple constraints\nprox = ClampProx(0.0, 1.0) ∘ PositiveProx()\nrule = ProxRule(Momentum(0.1, 0.9), prox)\n\nReferences\n\nFor plug-and-play priors: Venkatakrishnan et al., \"Plug-and-Play Priors for Model Based Reconstruction\" (2013)\n\nSee also: ProxRule, IstaProx, TVProx\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#Pointwise-Operators","page":"API","title":"Pointwise Operators","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx","text":"PointwiseProx(f)\n\nApply a function pointwise as a proximal operator.\n\nCreates a proximal operator that applies function f element-wise to the parameter array. The function should take the current parameter value and return the projected/regularized value.\n\nArguments\n\nf: Function to apply element-wise\n\nExamples\n\njulia> clamp_prox = PointwiseProx(x -> clamp(x, -1, 1));\n\njulia> threshold_prox = PointwiseProx(x -> abs(x) < 0.1 ? 0 : x);\n\njulia> model = randn(10, 10);\n\njulia> prox_state = ProximalOperators.init(clamp_prox, model);\n\njulia> ProximalOperators.apply!(clamp_prox, prox_state, model);\n\njulia> all(x -> -1 ≤ x ≤ 1, model)  # All values clamped\ntrue\n\nSee also: ClampProx, PositiveProx, ProxRule\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.ClampProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.ClampProx","text":"ClampProx(lo, hi)\n\nClamp values to the range [lo, hi].\n\nSimple box constraint proximal operator that projects parameters onto a box. Useful for physically meaningful constraints (e.g., transmittance ∈ [0,1]).\n\nArguments\n\nlo: Lower bound\nhi: Upper bound\n\nExamples\n\njulia> unit_clamp = ClampProx(0.0, 1.0);  # Unit interval\n\njulia> phase_clamp = ClampProx(-π, π);    # Phase wrapping alternative\n\njulia> x = [-0.5, 0.3, 1.2, 0.8];\n\njulia> prox_state = ProximalOperators.init(unit_clamp, x);\n\njulia> ProximalOperators.apply!(unit_clamp, prox_state, x);\n\njulia> x  # Values clamped to [0,1]\n4-element Vector{Float64}:\n 0.0\n 0.3\n 1.0\n 0.8\n\nSee also: PositiveProx, ProxRule, PointwiseProx\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.PositiveProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.PositiveProx","text":"PositiveProx()\n\nProject values onto the non-negative orthant (set negative values to zero).\n\nSimple constraint for physical parameters that must be non-negative, such as intensities, thicknesses, or absorption coefficients.\n\nExamples\n\njulia> pos_prox = PositiveProx();\n\njulia> x = [-0.1, 0.0, 0.5, -0.3, 1.2];\n\njulia> prox_state = ProximalOperators.init(pos_prox, x);\n\njulia> ProximalOperators.apply!(pos_prox, prox_state, x);\n\njulia> x  # Negative values set to zero\n5-element Vector{Float64}:\n 0.0\n 0.0\n 0.5\n 0.0\n 1.2\n\nSee also: ClampProx, ProxRule, PointwiseProx\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#Sparsity-and-Regularization","page":"API","title":"Sparsity and Regularization","text":"","category":"section"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.IstaProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.IstaProx","text":"IstaProx(λ, center=0)\n\nIterative Shrinkage-Thresholding (ISTA) proximal operator for sparse optimization.\n\nApplies soft thresholding to promote sparsity in the parameters. Values close to center are shrunk towards center, promoting sparse solutions.\n\nArguments\n\nλ: Shrinkage parameter (larger values → more sparsity)\ncenter=0: Center value for thresholding\n\nExamples\n\njulia> sparse_prox = IstaProx(0.01, 0.0);  # Shrink towards zero\n\njulia> x = [-0.5, -0.005, 0.0, 0.003, 0.2];\n\njulia> prox_state = ProximalOperators.init(sparse_prox, x);\n\njulia> ProximalOperators.apply!(sparse_prox, prox_state, x);\n\njulia> x  # Small values shrunk to zero\n5-element Vector{Float64}:\n -0.49\n  0.0\n  0.0\n  0.0\n  0.19\n\nSee also: PointwiseProx, ProxRule, Fista\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.TVProx","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.TVProx","text":"TVProx(λ, n_iter=50; tol=nothing, isotropic=true, rule=Fista(...))\n\nTotal Variation (TV) regularization proximal operator.\n\nApply total variation denoising to promote piecewise smooth solutions in n dimensions.\n\nThis works on arrays of any dimensionality: 1D signals, 2D surfaces, 3D volumes, or higher-dimensional data. Particularly useful for optical applications where smooth profiles are desired while preserving sharp edges.\n\nArguments\n\nλ: Regularization strength (larger values → smoother results)\nn_iter=50: Maximum number of internal iterations\ntol=nothing: Convergence tolerance (if provided)\nisotropic=true: Use isotropic TV (L₂ norm of gradient) vs anisotropic (L₁)\nrule: Optimization rule for internal TV solver\n\nExamples\n\njulia> tv_smooth = TVProx(0.1, 100; isotropic=false);  # Light anisotropic smoothing\n\njulia> tv_strong = TVProx(1.2, 100);  # Strong isotropic TV\n\njulia> noisy_surface = 1 .+ 0.1*randn(32, 32);\n\njulia> prox_state = ProximalOperators.init(tv_strong, noisy_surface);\n\njulia> strongly_smoothed_surface = ProximalOperators.apply!(tv_strong, prox_state, copy(noisy_surface));\n\nSee also: TV_denoise!, ProxRule\n\n\n\n\n\n","category":"type"},{"location":"api/optimisers/optimisers/#FluxOptics.OptimisersExt.ProximalOperators.TV_denoise!","page":"API","title":"FluxOptics.OptimisersExt.ProximalOperators.TV_denoise!","text":"TV_denoise!(x, λ, n_iter=50; tol=nothing, isotropic=true, rule=Fista(...))\n\nApply total variation denoising directly to an n-dimensional array.\n\nConvenience function that applies TV regularization without setting up the full proximal operator infrastructure. Modifies the input array in-place.\n\nArguments\n\nx: Input array to denoise (modified in-place)\nλ: Regularization strength\nn_iter=50: Maximum iterations\ntol=nothing: Convergence tolerance\nisotropic=true: Isotropic vs anisotropic TV\nrule: Optimization rule for internal TV solver\n\nReturns\n\nThe modified input array (for chaining).\n\nExamples\n\njulia> using Statistics\n\njulia> noisy = randn(64, 64) + 5 * sin.(0.1 * (1:64)) * sin.(0.1 * (1:64)');\n\njulia> original_var = var(noisy);\n\njulia> TV_denoise!(noisy, 0.1, 100);\n\njulia> denoised_var = var(noisy);\n\njulia> denoised_var < original_var  # Reduced variation\ntrue\n\njulia> # Can chain operations:\n\njulia> result = TV_denoise!(copy(noisy), 0.05) |> x -> clamp.(x, 0, 1);\n\nSee also: TVProx, ClampProx, PositiveProx\n\n\n\n\n\n","category":"function"},{"location":"api/optimisers/optimisers/#Examples-3","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Box constraints\nclamp_prox = ClampProx(0.0, 1.0)  # Clamp to [0,1]\nrule = ProxRule(Descent(0.01), clamp_prox)\n\n# Non-negativity\npos_prox = PositiveProx()\nrule = ProxRule(Momentum(0.1, 0.9), pos_prox)\n\n# Soft thresholding (L1 regularization)\nista_prox = IstaProx(0.001, 0.0)  # λ=0.001\nrule = ProxRule(Fista(0.05), ista_prox)\n\n# Total variation denoising\ntv_prox = TVProx(0.01)  # λ=0.01\nrule = ProxRule(Descent(0.1), tv_prox)\n\n# Custom pointwise constraint\ncustom_prox = PointwiseProx(x -> clamp(x, -π, π))\nrule = ProxRule(Descent(0.01), custom_prox)\n\n# Compose multiple constraints\ncombined = ClampProx(-1.0, 1.0) ∘ PositiveProx()\nrule = ProxRule(Descent(0.01), combined)","category":"page"},{"location":"api/optimisers/optimisers/#Optimization-Patterns","page":"API","title":"Optimization Patterns","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Per-Component-Learning-Rates","page":"API","title":"Per-Component Learning Rates","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Fast learning for source, slow for phase\nrules = make_rules(\n    source => Descent(0.1),    # Fast\n    phase => Descent(0.001)    # Slow\n)\n\nopt_state = setup(rules, system)","category":"page"},{"location":"api/optimisers/optimisers/#Constrained-Phase-Optimization","page":"API","title":"Constrained Phase Optimization","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Keep phase in [-π, π]\nphase_rule = ProxRule(Fista(0.05), ClampProx(-π, π))\n\nrules = make_rules(phase => phase_rule)\nopt_state = setup(rules, Descent(0.01), system)","category":"page"},{"location":"api/optimisers/optimisers/#Sparse-Phase-Mask-Design","page":"API","title":"Sparse Phase Mask Design","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Encourage sparsity with soft thresholding\nsparse_rule = ProxRule(\n    Fista(0.01),\n    IstaProx(0.001, 0.0)  # L1 penalty\n)\n\nrules = make_rules(phase => sparse_rule)\nopt_state = setup(rules, system)","category":"page"},{"location":"api/optimisers/optimisers/#Smooth-Phase-with-TV-Regularization","page":"API","title":"Smooth Phase with TV Regularization","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Total variation for smooth phase profiles\ntv_rule = ProxRule(\n    Momentum(0.05, 0.9),\n    TVProx(0.01)  # Smoothness penalty\n)\n\nrules = make_rules(phase => tv_rule)\nopt_state = setup(rules, system)","category":"page"},{"location":"api/optimisers/optimisers/#Mixed-Optimization-Strategy","page":"API","title":"Mixed Optimization Strategy","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Different strategies for different components\nrules = make_rules(\n    source => NoDescent(),                                    # Fixed\n    phase => ProxRule(Fista(0.05), ClampProx(-π, π)),       # Constrained\n    mask => ProxRule(Momentum(0.1, 0.9), PositiveProx())    # Positive only\n)\n\nopt_state = setup(rules, Descent(0.001), system)","category":"page"},{"location":"api/optimisers/optimisers/#Freezing-Specific-Components","page":"API","title":"Freezing Specific Components","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Keep some components fixed during optimization\nrules = make_rules(\n    component_to_freeze => NoDescent()\n)\n\n# Others use default rule\nopt_state = setup(rules, Descent(0.01), system)","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Note: NoDescent() prevents parameter updates but still computes gradients. For better performance when permanently freezing components, create them with trainable=false at construction. However, this requires rebuilding the system to change trainability.","category":"page"},{"location":"api/optimisers/optimisers/#Technical-Notes","page":"API","title":"Technical Notes","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Proximal-Operators-2","page":"API","title":"Proximal Operators","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Proximal operators implement the proximal map:","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"prox_λf(x) = argmin_z { f(z) + (1/2λ)||z - x||² }","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Common uses:","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Constraints: Project onto feasible set (e.g., ClampProx)\nRegularization: Encourage desirable properties (e.g., TVProx for smoothness)\nSparsity: Soft thresholding (IstaProx)","category":"page"},{"location":"api/optimisers/optimisers/#ProxRule-Composition","page":"API","title":"ProxRule Composition","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"ProxRule combines optimization with proximal operators:","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Apply gradient step: x_temp = x - η∇f(x)\nApply proximal operator: x_new = prox(x_temp)","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"This enables constrained optimization while maintaining differentiability.","category":"page"},{"location":"api/optimisers/optimisers/#make_rules-Behavior","page":"API","title":"make_rules Behavior","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Maps components/arrays to optimization rules\nExtracts trainable arrays from components automatically\nReturns IdDict{AbstractArray, AbstractRule}\nCompatible with nested structures (OpticalSystem, sequences)","category":"page"},{"location":"api/optimisers/optimisers/#setup-with-Rules-Dictionary","page":"API","title":"setup with Rules Dictionary","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Parameters in rules dict use specified rules\nOther parameters use default rule (or NoDescent if no default)\nWarning if no trainable parameters found","category":"page"},{"location":"api/optimisers/optimisers/#FISTA-Acceleration","page":"API","title":"FISTA Acceleration","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"FISTA provides:","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Faster convergence than gradient descent\nOptimal O(1/k²) convergence rate\nParticularly effective with proximal operators\nMomentum-like behavior without explicit velocity","category":"page"},{"location":"api/optimisers/optimisers/#Operator-Composition","page":"API","title":"Operator Composition","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Proximal operators can be composed with ∘:","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"combined = ClampProx(0.0, 1.0) ∘ PositiveProx()","category":"page"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Operators applied right-to-left (like function composition).","category":"page"},{"location":"api/optimisers/optimisers/#Performance","page":"API","title":"Performance","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Proximal operators work in-place when possible\nPre-allocated buffers avoid allocations\nTV denoising uses efficient iterative algorithm\nGPU-compatible (works with CuArrays)","category":"page"},{"location":"api/optimisers/optimisers/#Advanced-Usage","page":"API","title":"Advanced Usage","text":"","category":"section"},{"location":"api/optimisers/optimisers/#Custom-Proximal-Operator","page":"API","title":"Custom Proximal Operator","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"using FluxOptics.OptimisersExt.ProximalOperators\n\nstruct MyProx <: AbstractProximalOperator\n    param::Float64\nend\n\nfunction ProximalOperators.init(prox::MyProx, x::AbstractArray)\n    # Return state (can be empty tuple if stateless)\n    ()\nend\n\nfunction ProximalOperators.apply!(prox::MyProx, state, x::AbstractArray)\n    # Modify x in-place\n    @. x = my_projection(x, prox.param)\n    x\nend\n\n# Use in optimization\nrule = ProxRule(Descent(0.01), MyProx(1.0))","category":"page"},{"location":"api/optimisers/optimisers/#Adaptive-Learning-Rates","page":"API","title":"Adaptive Learning Rates","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"# Start with high learning rate, decrease over time\nfor epoch in 1:10\n    η = 0.1 * 0.9^epoch\n    rules = make_rules(phase => Descent(η))\n    opt_state = setup(rules, system)\n    \n    for iter in 1:100\n        grads = gradient(loss, params)[1]\n        update!(opt_state, params, grads)\n    end\nend","category":"page"},{"location":"api/optimisers/optimisers/#See-Also","page":"API","title":"See Also","text":"","category":"section"},{"location":"api/optimisers/optimisers/","page":"API","title":"API","text":"Metrics for loss functions\nFields for field operations\nOpticalComponents for trainable components\nOptimisers.jl for more optimization algorithms","category":"page"},{"location":"api/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Visualization tools for optical fields and components.","category":"page"},{"location":"api/plotting/#Overview","page":"Plotting","title":"Overview","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"The Plotting module provides:","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Field visualization: Heatmaps for 2D optical fields\nMultiple representations: Intensity, phase, real/imaginary, complex\nStack visualization: Animated sliders for field evolution\nComponent visualization: Display phase masks, DOEs, and other 2D components\nComplex colormaps: HSV-based visualization for complex fields","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Note: This module is loaded conditionally when using Makie is called.","category":"page"},{"location":"api/plotting/#Quick-Example","page":"Plotting","title":"Quick Example","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"using FluxOptics\nusing GLMakie  # or CairoMakie, WGLMakie\n\n# Visualize a single field\nu = ScalarField(gaussian_data, (2.0, 2.0), 1.064)\nvisualize(u, intensity)\n\n# Multiple representations\nvisualize(u, (intensity, phase, real, imag))\n\n# Visualize propagation sequence\npropagation_sequence = [u0, u1, u2, u3, u4]\nvisualize_slider(propagation_sequence, intensity)","category":"page"},{"location":"api/plotting/#Key-Functions","page":"Plotting","title":"Key Functions","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"visualize: Display field(s) with specified representation(s) (CairoMakie or GLMakie)\nvisualize_slider: Interactive slider for field sequences (requires GLMakie)","category":"page"},{"location":"api/plotting/#When-to-Use-What","page":"Plotting","title":"When to Use What","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Use visualize when:","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Displaying single fields or small sets\nCreating static figures for papers/reports (CairoMakie)\nComparing a few fields side-by-side","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Use visualize_slider when:","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Viewing large field sequences (propagation, optimization iterations)\nNeed interactive navigation through many frames\nAvoid displaying all frames simultaneously","category":"page"},{"location":"api/plotting/#Visualization-Functions","page":"Plotting","title":"Visualization Functions","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Common functions for field visualization:","category":"page"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"intensity: Total intensity |u|²\nphase: Phase angle\nreal: Real part\nimag: Imaginary part\nabs: Magnitude\nidentity: Complex field with HSV colormap","category":"page"},{"location":"api/plotting/#See-Also","page":"Plotting","title":"See Also","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Fields for ScalarField type\nMakie.jl for plotting backend documentation","category":"page"},{"location":"api/plotting/#Index","page":"Plotting","title":"Index","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting","title":"Plotting","text":"Modules = [FluxOptics.Plotting]\nOrder = [:type, :function]","category":"page"},{"location":"#FluxOptics.jl","page":"Home","title":"FluxOptics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differentiable optical propagation and inverse design in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"FluxOptics.jl is a Julia package for simulating scalar optical field propagation with full support for automatic differentiation. Design and optimize optical systems through gradient-based methods.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🌊 Scalar field propagation: Angular Spectrum, Rayleigh-Sommerfeld, Collins integral, Beam Propagation Method\n🎭 Optical components: Phase masks, amplitude masks, DOEs, graded-index media\n🎯 Optimization ready: Fully differentiable with Zygote/Enzyme support via ChainRulesCore\n🔧 Proximal operators: TV regularization, sparsity, constraints\n📊 Built-in metrics: Power coupling, field matching, intensity shaping\n🚀 GPU support: CUDA acceleration available","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using FluxOptics\n\n# Create a Gaussian beam\nu = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)\ngaussian = Gaussian(20.0)\nxv, yv = spatial_vectors(128, 128, 2.0, 2.0)\nu.electric .= gaussian(xv, yv)\n\n# Propagate through an optical system\nsource = ScalarSource(u)\nphase_mask = Phase(u, (x, y) -> 0.01*(x^2 + y^2))\npropagator = ASProp(u, 1000.0)  # 1 mm propagation\n\nsystem = source |> phase_mask |> propagator\nresult = system()","category":"page"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"","category":"section"},{"location":"#[API-Reference](api/index.md)","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Complete documentation of all modules, types, and functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"GridUtils: Coordinate systems and transformations\nModes: Gaussian beams, HG/LG modes, spatial layouts\nFields: ScalarField type and field operations\nOptical Components: Propagators, masks, sources, systems\nOptimisersExt: Optimization rules and proximal operators\nMetrics: Loss functions for inverse design","category":"page"},{"location":"#Tutorials-*(coming-soon)*","page":"Home","title":"Tutorials (coming soon)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Step-by-step guides for common use cases","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"📖 Browse the API Reference for detailed function documentation\n💬 Open an issue on GitHub for bugs or feature requests\n📧 Contact the maintainers for questions","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use FluxOptics.jl in your research, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{fluxoptics2025,\n  author = {Barré, Nicolas},\n  title = {FluxOptics.jl: Differentiable Optical Simulations},\n  year = {2025},\n  url = {https://github.com/anscoil/FluxOptics.jl}\n}","category":"page"},{"location":"api/optimisers/#OptimisersExt","page":"OptimisersExt","title":"OptimisersExt","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"Optimization rules and proximal operators for constrained inverse design.","category":"page"},{"location":"api/optimisers/#Overview","page":"OptimisersExt","title":"Overview","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"The OptimisersExt module extends Optimisers.jl with:","category":"page"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"Custom optimization rules: FISTA, NoDescent\nProximal operators: Constraints and regularization (TV, sparsity, clamping)\nPer-parameter rules: Different optimizers for different components\nProximal-gradient methods: Combine optimization with constraints","category":"page"},{"location":"api/optimisers/#Quick-Example","page":"OptimisersExt","title":"Quick Example","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"using FluxOptics\n\n# Define trainable system\nphase = Phase(u, (x, y) -> 0.0; trainable=true)\nmask = Mask(u, (x, y) -> 1.0; trainable=true)\nsystem = source |> phase |> mask\n\n# Per-component optimization rules\nrules = make_rules(\n    phase => ProxRule(Descent(0.01), ClampProx(-π, π)),  # Constrained phase\n    mask => Momentum(0.1, 0.9)                            # Momentum for mask\n)\n\n# Setup and optimize\nopt_state = setup(rules, system)\ngrads = gradient(loss, params)[1]\nupdate!(opt_state, params, grads)","category":"page"},{"location":"api/optimisers/#Key-Types","page":"OptimisersExt","title":"Key Types","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"ProxRule: Combine optimizer with proximal operator\nFista: Fast iterative shrinkage-thresholding\nNoDescent: No-op optimizer for fixed parameters","category":"page"},{"location":"api/optimisers/#Proximal-Operators","page":"OptimisersExt","title":"Proximal Operators","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"IstaProx: Soft thresholding for sparsity\nTVProx: Total variation regularization\nClampProx: Box constraints\nPositiveProx: Non-negativity constraint\nPointwiseProx: Custom element-wise constraints","category":"page"},{"location":"api/optimisers/#Key-Functions","page":"OptimisersExt","title":"Key Functions","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"make_rules: Create per-parameter optimization rules\nsetup: Initialize optimization state with custom rules\nupdate!: Apply optimization step (from Optimisers.jl)","category":"page"},{"location":"api/optimisers/#See-Also","page":"OptimisersExt","title":"See Also","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"Metrics for loss functions\nOptimisers.jl for base optimization algorithms","category":"page"},{"location":"api/optimisers/#Index","page":"OptimisersExt","title":"Index","text":"","category":"section"},{"location":"api/optimisers/","page":"OptimisersExt","title":"OptimisersExt","text":"Modules = [FluxOptics.OptimisersExt, FluxOptics.OptimisersExt.ProximalOperators]\nOrder = [:type, :function]","category":"page"}]
}
