<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · FluxOptics.jl</title><meta name="title" content="API · FluxOptics.jl"/><meta property="og:title" content="API · FluxOptics.jl"/><meta property="twitter:title" content="API · FluxOptics.jl"/><meta name="description" content="Documentation for FluxOptics.jl."/><meta property="og:description" content="Documentation for FluxOptics.jl."/><meta property="twitter:description" content="Documentation for FluxOptics.jl."/><meta property="og:url" content="https://anscoil.github.io/FluxOptics.jl/api/metrics/metrics/"/><meta property="twitter:url" content="https://anscoil.github.io/FluxOptics.jl/api/metrics/metrics/"/><link rel="canonical" href="https://anscoil.github.io/FluxOptics.jl/api/metrics/metrics/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="FluxOptics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">FluxOptics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../">API Reference</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">GridUtils</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../gridutils/">GridUtils</a></li><li><a class="tocitem" href="../../gridutils/gridutils/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Modes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../modes/">Modes</a></li><li><a class="tocitem" href="../../modes/modes/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../fields/">Fields</a></li><li><a class="tocitem" href="../../fields/fields/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Optical Components</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/">Optical Components</a></li><li><input class="collapse-toggle" id="menuitem-2-5-2" type="checkbox"/><label class="tocitem" for="menuitem-2-5-2"><span class="docs-label">Core</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/core/">Core</a></li><li><a class="tocitem" href="../../optical_components/core/core/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5-3" type="checkbox"/><label class="tocitem" for="menuitem-2-5-3"><span class="docs-label">Sources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/sources/">Sources</a></li><li><a class="tocitem" href="../../optical_components/sources/sources/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5-4" type="checkbox"/><label class="tocitem" for="menuitem-2-5-4"><span class="docs-label">Modulators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/modulators/">Modulators</a></li><li><a class="tocitem" href="../../optical_components/modulators/modulators/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5-5"><span class="docs-label">Fourier</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/fourier/">Fourier</a></li><li><a class="tocitem" href="../../optical_components/fourier/fourier/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5-6" type="checkbox"/><label class="tocitem" for="menuitem-2-5-6"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/utilities/">Utilities</a></li><li><a class="tocitem" href="../../optical_components/utilities/utilities/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5-7" type="checkbox"/><label class="tocitem" for="menuitem-2-5-7"><span class="docs-label">Free-Space Propagators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/freespace/">Free-Space Propagators</a></li><li><a class="tocitem" href="../../optical_components/freespace/freespace/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5-8" type="checkbox"/><label class="tocitem" for="menuitem-2-5-8"><span class="docs-label">Bulk Propagators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/bulk/">Bulk Propagators</a></li><li><a class="tocitem" href="../../optical_components/bulk/bulk/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5-9" type="checkbox"/><label class="tocitem" for="menuitem-2-5-9"><span class="docs-label">Active Media</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/active/">Active Media</a></li><li><a class="tocitem" href="../../optical_components/active/active_media/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5-10" type="checkbox"/><label class="tocitem" for="menuitem-2-5-10"><span class="docs-label">System</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/system/">System</a></li><li><a class="tocitem" href="../../optical_components/system/system/">API</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">OptimisersExt</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optimisers/">OptimisersExt</a></li><li><a class="tocitem" href="../../optimisers/optimisers/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox" checked/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Metrics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Metrics</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Abstract-Types"><span>Abstract Types</span></a></li><li><a class="tocitem" href="#Core-Functions"><span>Core Functions</span></a></li><li><a class="tocitem" href="#Dot-Product-Metrics"><span>Dot Product Metrics</span></a></li><li><a class="tocitem" href="#Field-Difference-Metrics"><span>Field Difference Metrics</span></a></li><li><a class="tocitem" href="#Optimization-Patterns"><span>Optimization Patterns</span></a></li><li><a class="tocitem" href="#Technical-Notes"><span>Technical Notes</span></a></li><li><a class="tocitem" href="#Advanced-Usage"><span>Advanced Usage</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Plotting</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../plotting/">Plotting</a></li><li><a class="tocitem" href="../../plotting/plotting/">API</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li><a class="is-disabled">Metrics</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/anscoil/FluxOptics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/anscoil/FluxOptics.jl/blob/main/docs/src/api/metrics/metrics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Metrics-API"><a class="docs-heading-anchor" href="#Metrics-API">Metrics API</a><a id="Metrics-API-1"></a><a class="docs-heading-anchor-permalink" href="#Metrics-API" title="Permalink"></a></h1><h2 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Metrics.AbstractMetric" href="#FluxOptics.Metrics.AbstractMetric"><code>FluxOptics.Metrics.AbstractMetric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractMetric</code></pre><p>Abstract base type for optimization metrics in inverse optics design.</p><p>Metrics are callable objects that evaluate optimization objectives on optical fields. They encapsulate target references and pre-allocated buffers for efficient gradient computation during iterative optimization.</p><p><strong>Interface</strong></p><p>Subtypes must implement:</p><ul><li><code>compute_metric(m::AbstractMetric, u::NTuple{N, ScalarField})</code>: Evaluate metric</li><li><code>backpropagate_metric(m::AbstractMetric, u::NTuple{N, ScalarField}, ∂c)</code>: Compute gradients</li></ul><p><strong>Callable Interface</strong></p><p>All metrics are callable:</p><pre><code class="language-julia hljs">metric = PowerCoupling(target)
loss = metric(u)                    # Single field
losses = metric(u1, u2)             # Multiple fields</code></pre><p><strong>Available Metrics</strong></p><ul><li><a href="#FluxOptics.Metrics.DotProduct"><code>DotProduct</code></a>: Complex overlap integral ⟨u,v⟩</li><li><a href="#FluxOptics.Metrics.PowerCoupling"><code>PowerCoupling</code></a>: Power coupled to target modes</li><li><a href="#FluxOptics.Metrics.SquaredFieldDifference"><code>SquaredFieldDifference</code></a>: Field amplitude/phase matching</li><li><a href="#FluxOptics.Metrics.SquaredIntensityDifference"><code>SquaredIntensityDifference</code></a>: Intensity pattern matching</li></ul><p><strong>Design Philosophy</strong></p><ul><li><strong>Stateful</strong>: Pre-allocate buffers at construction for zero-allocation evaluation</li><li><strong>Flexible</strong>: Support single or multiple fields, mode-selective or full matrices</li><li><strong>Efficient</strong>: Custom gradient implementations via <code>backpropagate_metric</code></li><li><strong>Composable</strong>: Combine metrics for multi-objective optimization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/8e7d25d6918ca2dd59f04773cdaa77ab50ae6134/src/metrics/Metrics.jl#L9-L46">source</a></section></article><h2 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Metrics.AbstractMetric-Tuple{ScalarField}" href="#FluxOptics.Metrics.AbstractMetric-Tuple{ScalarField}"><code>FluxOptics.Metrics.AbstractMetric</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(m::AbstractMetric)(u::Vararg{ScalarField})
(m::AbstractMetric)(u::ScalarField)</code></pre><p>Callable interface for metrics. Equivalent to <code>compute_metric(m, u)</code>.</p><p>This is the preferred way to evaluate metrics.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">metric = PowerCoupling(target)

# Single field
loss = metric(u)

# Multiple fields
metric_multi = DotProduct(target1, target2)
losses = metric_multi(u1, u2)</code></pre><p>See also: <a href="#FluxOptics.Metrics.compute_metric"><code>compute_metric</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/8e7d25d6918ca2dd59f04773cdaa77ab50ae6134/src/metrics/Metrics.jl#L91-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Metrics.compute_metric" href="#FluxOptics.Metrics.compute_metric"><code>FluxOptics.Metrics.compute_metric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_metric(m::AbstractMetric, u::NTuple{N, ScalarField})
compute_metric(m::AbstractMetric, u::ScalarField)</code></pre><p>Evaluate a metric on one or more optical fields.</p><p>This is the core evaluation function for metrics. In practice, prefer using the callable interface <code>metric(u)</code> which calls this function internally.</p><p><strong>Arguments</strong></p><ul><li><code>m::AbstractMetric</code>: The metric to evaluate.</li><li><code>u</code>: Single <code>ScalarField</code> or tuple of <code>ScalarField</code>s.</li></ul><p><strong>Returns</strong></p><p>Array(s) containing metric values. Dimensions depend on the specific metric type and whether <code>mode_selective=true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">metric = PowerCoupling(target)

# Callable interface (preferred)
loss = metric(u)

# Explicit call (equivalent)
loss = compute_metric(metric, u)

# Multiple fields
metric_multi = DotProduct(target1, target2)
losses = compute_metric(metric_multi, (u1, u2))</code></pre><p>See also: <a href="#FluxOptics.Metrics.backpropagate_metric"><code>backpropagate_metric</code></a>, <a href="#FluxOptics.Metrics.AbstractMetric"><code>AbstractMetric</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/8e7d25d6918ca2dd59f04773cdaa77ab50ae6134/src/metrics/Metrics.jl#L49-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Metrics.backpropagate_metric" href="#FluxOptics.Metrics.backpropagate_metric"><code>FluxOptics.Metrics.backpropagate_metric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">backpropagate_metric(m::AbstractMetric, u::NTuple{N, ScalarField}, ∂c)</code></pre><p>Compute gradients of metric with respect to input fields.</p><p>Used internally by automatic differentiation. Most users don&#39;t need to call this directly.</p><p><strong>Arguments</strong></p><ul><li><code>m::AbstractMetric</code>: The metric.</li><li><code>u</code>: Tuple of input fields.</li><li><code>∂c</code>: Gradient w.r.t. metric output.</li></ul><p><strong>Returns</strong></p><p>Tuple of <code>ScalarField</code>s containing gradients w.r.t. each input field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/8e7d25d6918ca2dd59f04773cdaa77ab50ae6134/src/metrics/Metrics.jl#L116-L130">source</a></section></article><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><pre><code class="language-julia hljs">using FluxOptics

# Create metric
target = ScalarField(target_data, (2.0, 2.0), 1.064)
metric = PowerCoupling(target)

# Evaluate metric
u = system()
loss = compute_metric(metric, u)

# Or use callable interface
loss = metric(u)

# With multiple fields
metric_multi = DotProduct(target1, target2)
losses = metric_multi(u1, u2)</code></pre><h2 id="Dot-Product-Metrics"><a class="docs-heading-anchor" href="#Dot-Product-Metrics">Dot Product Metrics</a><a id="Dot-Product-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Dot-Product-Metrics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Metrics.DotProduct" href="#FluxOptics.Metrics.DotProduct"><code>FluxOptics.Metrics.DotProduct</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DotProduct(fields...; mode_selective::Bool=true)</code></pre><p>Compute dot product (inner product) between optical fields for optimization.</p><p>This metric calculates the complex overlap integral ⟨u,v⟩ between fields, commonly used  for mode coupling analysis and field matching objectives in inverse design.</p><p><strong>Arguments</strong></p><ul><li><code>fields...</code>: Reference ScalarField(s) to compare against.</li><li><code>mode_selective::Bool=true</code>: If true, compute per-mode overlaps. If false, compute full overlap matrix.</li></ul><p><strong>Mathematical definition</strong></p><p>⟨u,v⟩ = ∫∫ u*(x,y) v(x,y) dx dy</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Small example for documentation - use larger arrays in practice
julia&gt; data = ones(ComplexF64, 4, 4, 2);

julia&gt; data[3:end,:,2] .= -ones(ComplexF64, 2, 4);

julia&gt; u = ScalarField(data, (1.0, 1.0), 1.064);

julia&gt; normalize_power!(u);

julia&gt; metric_selective = DotProduct(u);

julia&gt; metric_selective(u)
1×1×2 Array{ComplexF64, 3}:
[:, :, 1] =
 1.0 + 0.0im

[:, :, 2] =
 1.0 + 0.0im

julia&gt; metric_non_selective = DotProduct(u; mode_selective = false);

julia&gt; metric_non_selective(u)
2×2 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im</code></pre><p>See also: <code>PowerCoupling</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/8e7d25d6918ca2dd59f04773cdaa77ab50ae6134/src/metrics/dot_product.jl#L1-L46">source</a></section></article><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Mode-selective dot product (default)
target = ScalarField(target_data, (64, 64, 3), (2.0, 2.0), 1.064)
metric = DotProduct(target; mode_selective=true)

u = system()
overlaps = metric(u)  # 1×1×3 array (per-mode)

# Full overlap matrix
metric_full = DotProduct(target; mode_selective=false)
overlap_matrix = metric_full(u)  # 3×3 matrix

# Multiple targets
metric_multi = DotProduct(target1, target2)
overlaps = metric_multi(u1, u2)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Metrics.PowerCoupling" href="#FluxOptics.Metrics.PowerCoupling"><code>FluxOptics.Metrics.PowerCoupling</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PowerCoupling(fields...; mode_selective::Bool=true)</code></pre><p>Compute power coupled into target optical modes.</p><p>This metric calculates |⟨u,v̂⟩|², the optical power (in Watts) coupled from field u  into normalized target modes v̂. The target fields are copied and normalized internally  to unit power, leaving the original fields unmodified.</p><p><strong>Arguments</strong></p><ul><li><code>fields...</code>: Target ScalarField(s) to couple into (copied and normalized internally).</li><li><code>mode_selective::Bool=true</code>: If true, compute per-mode coupling. If false, compute full coupling matrix.</li></ul><p><strong>Mathematical definition</strong></p><p>P_coupled = |⟨u,v̂⟩|² where v̂ are normalized copies of the target fields</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Small example for documentation - use larger arrays in practice
julia&gt; data = ones(ComplexF64, 4, 4, 2);

julia&gt; data[3:end,:,2] .= -ones(ComplexF64, 2, 4);

julia&gt; u = ScalarField(data, (1.0, 1.0), 1.064);

julia&gt; normalize_power!(u);

julia&gt; metric_selective = PowerCoupling(u);

julia&gt; metric_selective(u)
1×1×2 Array{Float64, 3}:
[:, :, 1] =
 1.0

[:, :, 2] =
 1.0

julia&gt; metric_non_selective = PowerCoupling(u; mode_selective = false);

julia&gt; metric_non_selective(u)
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0</code></pre><p>See also: <code>DotProduct</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/8e7d25d6918ca2dd59f04773cdaa77ab50ae6134/src/metrics/power_coupling.jl#L1-L47">source</a></section></article><h3 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Single target mode
target = ScalarField(target_data, (128, 128), (2.0, 2.0), 1.064)
normalize_power!(target)  # Not required - done internally

metric = PowerCoupling(target)
u = system()
power_coupled = metric(u)[]  # Scalar power in Watts

# Multi-mode coupling
modes_data = generate_mode_stack(layout, 128, 128, 2.0, 2.0, Gaussian(15.0))
modes = ScalarField(modes_data, (2.0, 2.0), 1.064)

metric = PowerCoupling(modes; mode_selective=true)
u = system()
powers = metric(u)  # Power per mode

# Use in optimization
function loss()
    u = system()
    -sum(metric(u))  # Maximize total coupled power
end</code></pre><h2 id="Field-Difference-Metrics"><a class="docs-heading-anchor" href="#Field-Difference-Metrics">Field Difference Metrics</a><a id="Field-Difference-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Field-Difference-Metrics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Metrics.SquaredFieldDifference" href="#FluxOptics.Metrics.SquaredFieldDifference"><code>FluxOptics.Metrics.SquaredFieldDifference</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SquaredFieldDifference(fields...)</code></pre><p>Compute squared L² norm difference between complex optical fields.</p><p>This metric calculates ‖u - v‖², the squared field difference, commonly used as a loss function for direct field matching in inverse design problems.</p><p><strong>Arguments</strong></p><ul><li><code>fields...</code>: Reference ScalarField(s) to match against.</li></ul><p><strong>Mathematical definition</strong></p><p>L = ∫∫ |u(x,y) - v(x,y)|² dx dy = ‖u - v‖²</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Small example for documentation - use larger arrays in practice
julia&gt; data1 = ones(ComplexF64, 4, 4);

julia&gt; target = ScalarField(data1, (1.0, 1.0), 1.064);

julia&gt; data2 = zeros(ComplexF64, 4, 4);

julia&gt; current = ScalarField(data2, (1.0, 1.0), 1.064);

julia&gt; metric = SquaredFieldDifference(target);

julia&gt; metric(current)
1×1 Matrix{Float64}:
 16.0</code></pre><p>See also: <code>SquaredIntensityDifference</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/8e7d25d6918ca2dd59f04773cdaa77ab50ae6134/src/metrics/squared_field_difference.jl#L1-L34">source</a></section></article><h3 id="Examples-4"><a class="docs-heading-anchor" href="#Examples-4">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-4" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Complex field matching
target = ScalarField(target_data, (128, 128), (2.0, 2.0), 1.064)

metric = SquaredFieldDifference(target)
u = system()
loss = metric(u)[]

# Multi-mode matching
target_multi = ScalarField(target_data, (64, 64, 3), (2.0, 2.0), 1.064)
metric_multi = SquaredFieldDifference(target_multi)
u_multi = system()
losses_per_mode = metric_multi(u_multi)  # 1×1×3 array</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Metrics.SquaredIntensityDifference" href="#FluxOptics.Metrics.SquaredIntensityDifference"><code>FluxOptics.Metrics.SquaredIntensityDifference</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SquaredIntensityDifference(field_intensity_pairs...)</code></pre><p>Compute squared difference between field intensities and target patterns.</p><p>This metric supports two modes depending on target array dimensions:</p><ul><li><strong>Full dimensions</strong>: Target has same dimensions as field → compare each mode individually</li><li><strong>Spatial only</strong>: Target has only spatial dimensions → compare total intensity across all modes</li></ul><p><strong>Arguments</strong></p><ul><li><code>field_intensity_pairs...</code>: Tuples of (ScalarField, target<em>intensity</em>array).</li></ul><p><strong>Mathematical definition</strong></p><p><strong>Full dimensions case:</strong> L = ∫∫ |uₖ(x,y)|² - Itargetₖ(x,y)|² dx dy (per mode)</p><p><strong>Spatial only case:</strong> L = ∫∫ |(∑ₖ |uₖ(x,y)|²) - Itarget(x,y)|² dx dy (total intensity)</p><p><strong>Examples</strong></p><p><strong>Full dimensions case (mode-by-mode comparison):</strong></p><pre><code class="language-julia-repl hljs"># Small example for documentation - use larger arrays in practice
julia&gt; data = ones(ComplexF64, 4, 4, 2);

julia&gt; field = ScalarField(data, (1.0, 1.0), 1.064);

julia&gt; target_intensity = zeros(4, 4, 2);  # Same dimensions as field

julia&gt; metric = SquaredIntensityDifference((field, target_intensity));

julia&gt; metric(field)
1×1×2 Array{Float64, 3}:
[:, :, 1] =
 16.0

[:, :, 2] =
 16.0</code></pre><p><strong>Spatial only case (total intensity comparison):</strong></p><pre><code class="language-julia-repl hljs"># Small example for documentation - use larger arrays in practice
julia&gt; data = ones(ComplexF64, 4, 4, 3);

julia&gt; field = ScalarField(data, (1.0, 1.0), 1.064);

julia&gt; target_intensity = 3*ones(4, 4);  # Only spatial dimensions

julia&gt; metric = SquaredIntensityDifference((field, target_intensity));

julia&gt; metric(field)
1×1 Matrix{Float64}:
 0.0</code></pre><p>See also: <code>SquaredFieldDifference</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/8e7d25d6918ca2dd59f04773cdaa77ab50ae6134/src/metrics/squared_intensity_difference.jl#L1-L57">source</a></section></article><h3 id="Examples-5"><a class="docs-heading-anchor" href="#Examples-5">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-5" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Mode-by-mode intensity matching
target_intensity = abs2.(target_data)  # 128×128×3
u = ScalarField(ones(ComplexF64, 128, 128, 3), (2.0, 2.0), 1.064)

metric = SquaredIntensityDifference((u, target_intensity))
loss_per_mode = metric(u)  # 1×1×3 array

# Total intensity matching (summed over modes)
target_intensity_total = sum(abs2.(target_data), dims=3)[:,:,1]  # 128×128
metric_total = SquaredIntensityDifference((u, target_intensity_total))
loss_total = metric_total(u)[]  # Scalar

# Multiple field-target pairs
metric_multi = SquaredIntensityDifference(
    (field1, target1),
    (field2, target2)
)
losses = metric_multi(field1, field2)</code></pre><h2 id="Optimization-Patterns"><a class="docs-heading-anchor" href="#Optimization-Patterns">Optimization Patterns</a><a id="Optimization-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Patterns" title="Permalink"></a></h2><h3 id="Basic-Optimization"><a class="docs-heading-anchor" href="#Basic-Optimization">Basic Optimization</a><a id="Basic-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Optimization" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Zygote, Optimisers

# Setup system and metric
system = source |&gt; phase_mask |&gt; propagator
target = ScalarField(target_data, (2.0, 2.0), 1.064)
metric = PowerCoupling(target)

# Loss function
function loss()
    u = system()
    -metric(u)[]  # Maximize coupling (minimize negative)
end

# Optimize
params = Functors.fmap(trainable, system)
opt_state = Optimisers.setup(Optimisers.Adam(0.01), params)

for iter in 1:100
    grads = gradient(loss, params)[1]
    Optimisers.update!(opt_state, params, grads)
end</code></pre><h3 id="Multi-Objective-Optimization"><a class="docs-heading-anchor" href="#Multi-Objective-Optimization">Multi-Objective Optimization</a><a id="Multi-Objective-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Objective-Optimization" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Combine multiple metrics
target_mode = ScalarField(mode_data, (2.0, 2.0), 1.064)
target_intensity = desired_intensity_pattern

metric_coupling = PowerCoupling(target_mode)
metric_intensity = SquaredIntensityDifference((target_mode, target_intensity))

function combined_loss()
    u = system()
    α = 0.7  # Weighting factor
    α * (1.0 - metric_coupling(u)[]) + (1-α) * metric_intensity(u)[]
end</code></pre><h3 id="Mode-Selective-Optimization"><a class="docs-heading-anchor" href="#Mode-Selective-Optimization">Mode-Selective Optimization</a><a id="Mode-Selective-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Mode-Selective-Optimization" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Optimize specific modes
modes = ScalarField(mode_stack, (2.0, 2.0), 1.064)
metric = PowerCoupling(modes; mode_selective=true)

function selective_loss()
    u = system()
    powers = metric(u)
    
    # Weight different modes
    weights = [1.0, 0.5, 0.2]  # Prioritize first mode
    -sum(reshape(weights, 1, 1, 3) .* powers)
end</code></pre><h2 id="Technical-Notes"><a class="docs-heading-anchor" href="#Technical-Notes">Technical Notes</a><a id="Technical-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Notes" title="Permalink"></a></h2><h3 id="Metric-Types"><a class="docs-heading-anchor" href="#Metric-Types">Metric Types</a><a id="Metric-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Metric-Types" title="Permalink"></a></h3><ul><li>All metrics are subtypes of <code>AbstractMetric</code></li><li>Metrics are callable: <code>metric(field)</code> calls <code>compute_metric</code></li><li>Support single or multiple field arguments</li></ul><h3 id="Mode-Selectivity"><a class="docs-heading-anchor" href="#Mode-Selectivity">Mode Selectivity</a><a id="Mode-Selectivity-1"></a><a class="docs-heading-anchor-permalink" href="#Mode-Selectivity" title="Permalink"></a></h3><ul><li><code>mode_selective=true</code>: Compute per-mode metrics (diagonal)</li><li><code>mode_selective=false</code>: Compute full coupling matrix</li><li>Affects output dimensionality and computational cost</li></ul><h3 id="Normalization"><a class="docs-heading-anchor" href="#Normalization">Normalization</a><a id="Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization" title="Permalink"></a></h3><ul><li><code>PowerCoupling</code> normalizes targets internally (copies first)</li><li><code>DotProduct</code> uses fields as-is</li><li>Consider normalizing input fields before metrics</li></ul><h3 id="Gradient-Computation"><a class="docs-heading-anchor" href="#Gradient-Computation">Gradient Computation</a><a id="Gradient-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Computation" title="Permalink"></a></h3><ul><li>Metrics implement custom <code>backpropagate_metric</code> for efficiency</li><li>Compatible with Zygote and other AD libraries</li><li>Gradients flow through metric computations</li></ul><h3 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h3><ul><li>Metrics cache internal buffers to avoid allocations</li><li>Pre-compute metrics once, reuse for multiple evaluations</li><li>Use in-place operations where possible</li></ul><h3 id="Memory-Layout"><a class="docs-heading-anchor" href="#Memory-Layout">Memory Layout</a><a id="Memory-Layout-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Layout" title="Permalink"></a></h3><ul><li>Metrics store internal arrays matching field structure</li><li>Buffers allocated at construction time</li><li>GPU-compatible when using CuArrays</li></ul><h2 id="Advanced-Usage"><a class="docs-heading-anchor" href="#Advanced-Usage">Advanced Usage</a><a id="Advanced-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Usage" title="Permalink"></a></h2><h3 id="Custom-Metric"><a class="docs-heading-anchor" href="#Custom-Metric">Custom Metric</a><a id="Custom-Metric-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Metric" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Define new metric type
struct MyMetric &lt;: AbstractMetric
    reference::ScalarField
    buffer::Array{ComplexF64}
end

# Implement required methods
function compute_metric(m::MyMetric, u::Tuple{ScalarField})
    # Your metric computation
end

function backpropagate_metric(m::MyMetric, u::Tuple{ScalarField}, ∂c)
    # Your gradient computation
end</code></pre><h3 id="Combining-Metrics"><a class="docs-heading-anchor" href="#Combining-Metrics">Combining Metrics</a><a id="Combining-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-Metrics" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Wrapper for weighted sum
struct WeightedSum{M&lt;:Tuple} &lt;: AbstractMetric
    metrics::M
    weights::Vector{Float64}
end

function compute_metric(m::WeightedSum, u::NTuple{N, ScalarField}) where N
    sum(w * compute_metric(metric, u) for (w, metric) in zip(m.weights, m.metrics))
end</code></pre><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../../optimisers/">OptimisersExt</a> for optimization algorithms</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Metrics</a><a class="docs-footer-nextpage" href="../../plotting/">Plotting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 10 October 2025 21:37">Friday 10 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
