<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · FluxOptics.jl</title><meta name="title" content="API · FluxOptics.jl"/><meta property="og:title" content="API · FluxOptics.jl"/><meta property="twitter:title" content="API · FluxOptics.jl"/><meta name="description" content="Documentation for FluxOptics.jl."/><meta property="og:description" content="Documentation for FluxOptics.jl."/><meta property="twitter:description" content="Documentation for FluxOptics.jl."/><meta property="og:url" content="https://anscoil.github.io/FluxOptics.jl/api/fields/fields/"/><meta property="twitter:url" content="https://anscoil.github.io/FluxOptics.jl/api/fields/fields/"/><link rel="canonical" href="https://anscoil.github.io/FluxOptics.jl/api/fields/fields/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">FluxOptics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../">API Reference</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">GridUtils</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../gridutils/">GridUtils</a></li><li><a class="tocitem" href="../../gridutils/gridutils/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Modes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../modes/">Modes</a></li><li><a class="tocitem" href="../../modes/modes/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox" checked/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Fields</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#ScalarField-Type"><span>ScalarField Type</span></a></li><li><a class="tocitem" href="#Field-Data-Management"><span>Field Data Management</span></a></li><li><a class="tocitem" href="#Field-Properties"><span>Field Properties</span></a></li><li><a class="tocitem" href="#Tilt-Management"><span>Tilt Management</span></a></li><li><a class="tocitem" href="#Power-and-Intensity"><span>Power and Intensity</span></a></li><li><a class="tocitem" href="#Field-Comparison"><span>Field Comparison</span></a></li><li><a class="tocitem" href="#Vectorization"><span>Vectorization</span></a></li><li><a class="tocitem" href="#Broadcasting-and-Indexing"><span>Broadcasting and Indexing</span></a></li><li><a class="tocitem" href="#Technical-Notes"><span>Technical Notes</span></a></li><li><a class="tocitem" href="#Performance-Tips"><span>Performance Tips</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Metrics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../metrics/">Metrics</a></li><li><a class="tocitem" href="../../metrics/metrics/">API</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li><a class="is-disabled">Fields</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/anscoil/FluxOptics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/anscoil/FluxOptics.jl/blob/main/docs/src/api/fields/fields.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Fields-API"><a class="docs-heading-anchor" href="#Fields-API">Fields API</a><a id="Fields-API-1"></a><a class="docs-heading-anchor-permalink" href="#Fields-API" title="Permalink"></a></h1><h2 id="ScalarField-Type"><a class="docs-heading-anchor" href="#ScalarField-Type">ScalarField Type</a><a id="ScalarField-Type-1"></a><a class="docs-heading-anchor-permalink" href="#ScalarField-Type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.ScalarField" href="#FluxOptics.Fields.ScalarField"><code>FluxOptics.Fields.ScalarField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScalarField(data::AbstractArray{Complex}, ds::NTuple{Nd,Real}, lambdas; tilts=ntuple(_-&gt;0, Nd))
ScalarField(nd::NTuple, ds::NTuple{Nd,Real}, lambdas; tilts=ntuple(_-&gt;0, Nd))</code></pre><p>Represent a scalar optical field with spatial grid information, wavelength(s), and optional tilt angles.</p><p>This is the central data structure of FluxOptics.jl for storing and manipulating scalar optical fields. The field data can be multi-dimensional with 1 or 2 transverse dimensions and additional dimensions for  different spatial modes. Each mode can hold independent wavelength and tilt information.</p><p><strong>Constructors</strong></p><p><strong>From existing data:</strong></p><ul><li><code>data::AbstractArray{Complex}</code>: Complex field amplitude data.</li><li><code>ds::NTuple{Nd,Real}</code>: Spatial sampling intervals (dx,[dy]) in micrometers (or meters as long as consistent units are used everywhere).</li><li><code>lambdas</code>: Wavelength(s) - can be a scalar Real or AbstractArray{Real} for multiple wavelengths. In case of AbstractArray{Real}, it must be broadcastable on the extra dimensions of <code>data</code> (all dimensions except the spatial ones).</li><li><code>tilts::NTuple{Nd}=ntuple(_-&gt;0, Nd)</code>: Tilt angles in radians corresponding to a Fourier offset of fx₀ = sin(θx)/λ, fy₀ = sin(θy)/λ. Array arguments to NTuple are accepted as long as they broadcast with the extra non-spatial dimensions of <code>data</code>.</li></ul><p><strong>Zero-initialized field (convenience):</strong></p><ul><li><code>nd::NTuple</code>: Dimensions of the data array (nx, [ny,] ...).</li><li>Other arguments same as above.</li></ul><p><strong>Examples</strong></p><p><strong>Creating from existing data:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; data = rand(ComplexF64, 4, 4);

julia&gt; u = ScalarField(data, (1.0, 1.0), 1.064);

julia&gt; size(u)
(4, 4)</code></pre><p><strong>Creating zero-initialized field:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; u = ScalarField((4, 4), (1.0, 1.0), 1.064);

julia&gt; size(u)
(4, 4)</code></pre><p><strong>Multi-wavelength field:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wavelengths = [0.8, 1.064, 1.550];

julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; data = zeros(ComplexF64, 4, 4, 3);

julia&gt; u = ScalarField(data, (1.0, 1.0), wavelengths);</code></pre><p><strong>Field with initial tilt:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wavelengths = [0.8, 1.064, 1.55];

julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; data = zeros(ComplexF64, 4, 4, 3);

julia&gt; u = ScalarField(data, (1.0, 1.0), 1.064; tilts=(0.01, 0.005));

julia&gt; v = ScalarField(data, (1.0, 1.0), 1.064; tilts=([0.01, 0.02, 0.03], 0));</code></pre><p>See also: <a href="#FluxOptics.Fields.set_field_data"><code>set_field_data</code></a>, <a href="#FluxOptics.Fields.power"><code>power</code></a>, <a href="#FluxOptics.Fields.normalize_power!"><code>normalize_power!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L40-L117">source</a></section></article><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><pre><code class="language-julia hljs">using FluxOptics

# From existing data
data = rand(ComplexF64, 64, 64)
u = ScalarField(data, (2.0, 2.0), 1.064)

# Zero-initialized
u = ScalarField((128, 128), (1.5, 1.5), 1.064)

# Multi-mode field
data = zeros(ComplexF64, 128, 128, 5)
u = ScalarField(data, (2.0, 2.0), 1.064)

# Multi-wavelength field
λs = [0.8, 1.064, 1.55]
data = zeros(ComplexF64, 64, 64, 3)
u = ScalarField(data, (1.0, 1.0), λs)

# Field with tilts
u = ScalarField(data, (2.0, 2.0), 1.064; tilts=(0.01, 0.005))</code></pre><h2 id="Field-Data-Management"><a class="docs-heading-anchor" href="#Field-Data-Management">Field Data Management</a><a id="Field-Data-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Field-Data-Management" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.set_field_data" href="#FluxOptics.Fields.set_field_data"><code>FluxOptics.Fields.set_field_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_field_data(u::ScalarField, data::AbstractArray)</code></pre><p>Create a new ScalarField with updated field data, preserving all other parameters.</p><p>This function creates a copy with new amplitude data while keeping the same spatial grid, wavelengths, and tilt information.</p><p><strong>Arguments</strong></p><ul><li><code>u::ScalarField</code>: Original field.</li><li><code>data::AbstractArray</code>: New complex field data.</li></ul><p><strong>Returns</strong></p><p>New <code>ScalarField</code> with updated data.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);

julia&gt; new_data = rand(ComplexF64, 4, 4);

julia&gt; u_new = set_field_data(u, new_data);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L187-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.similar-Tuple{ScalarField}" href="#Base.similar-Tuple{ScalarField}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">similar(u::ScalarField)</code></pre><p>Create a new ScalarField with same parameters but uninitialized data.</p><p>Useful for creating temporary fields with the same grid, wavelength and tilt structures as an existing field.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);

julia&gt; u_tmp = similar(u);  # Same grid/wavelengths/tilts, but data is uninitialized</code></pre><p>See also: <a href="#Base.copy-Tuple{ScalarField}"><code>copy</code></a>, <a href="#FluxOptics.Fields.set_field_data"><code>set_field_data</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L434-L452">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{ScalarField}" href="#Base.copy-Tuple{ScalarField}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(u::ScalarField)</code></pre><p>Create a copy of the scalar field.</p><p>Creates a copy of the field data, while sharing the internal representation of other parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; u = ScalarField(zeros(ComplexF64, 4, 4), (1.0, 1.0), 1.064);

julia&gt; u_copy = copy(u);

julia&gt; # Modifying u_copy.electric will not affect u, but the internal arrays representing

julia&gt; # the wavelengths or tilts must never be modified.</code></pre><p>See also: <a href="#Base.similar-Tuple{ScalarField}"><code>similar</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L398-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fill!-Tuple{ScalarField, Number}" href="#Base.fill!-Tuple{ScalarField, Number}"><code>Base.fill!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill!(u::ScalarField, v) -&gt; ScalarField</code></pre><p>Fill the electric field with value <code>v</code> in-place.</p><p><strong>Arguments</strong></p><ul><li><code>u::ScalarField</code>: Field to modify.</li><li><code>v</code>: Fill value, either a scalar (fills entire field) or array (copied into field).</li></ul><p><strong>Returns</strong></p><p>Modified <code>ScalarField</code> (same as input).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = ScalarField((4, 4), (1.0, 1.0), 1.064);

julia&gt; fill!(u, 1.0 + 0.0im);  # Fill with constant

julia&gt; fill!(u, rand(ComplexF64, 4, 4));  # Fill with array</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L367-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copyto!-Tuple{ScalarField, ScalarField}" href="#Base.copyto!-Tuple{ScalarField, ScalarField}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copyto!(u::ScalarField, v::ScalarField) -&gt; ScalarField</code></pre><p>Copy data from <code>v</code> into <code>u</code>. Modifies <code>u</code> in-place and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L424-L428">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.collect-Tuple{ScalarField}" href="#Base.collect-Tuple{ScalarField}"><code>Base.collect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collect(u::ScalarField) -&gt; Array</code></pre><p>Convert field data to a regular CPU array. Returns an <code>Array</code> (not a <code>ScalarField</code>).</p><p>Useful for converting GPU arrays (e.g., <code>CuArray</code>) to CPU for analysis, plotting, or saving.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064);

julia&gt; data = collect(u);  # Returns Array, not ScalarField

julia&gt; typeof(data)
Matrix{ComplexF64} (alias for Array{Complex{Float64}, 2})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L457-L473">source</a></section></article><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Update field data
new_data = rand(ComplexF64, size(u)...)
u_new = set_field_data(u, new_data)

# Copy and allocate
u_copy = copy(u)
u_tmp = similar(u)

# Fill operations
fill!(u, 1.0 + 0.0im)
fill!(u, rand(ComplexF64, size(u)...))

# Copy between fields
copyto!(u_tmp, u)

# Convert GPU to CPU array
data = collect(u)  # Returns Array</code></pre><h2 id="Field-Properties"><a class="docs-heading-anchor" href="#Field-Properties">Field Properties</a><a id="Field-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Field-Properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{ScalarField}" href="#Base.size-Tuple{ScalarField}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(u::ScalarField) -&gt; Tuple
size(u::ScalarField, k::Integer) -&gt; Int</code></pre><p>Return the size of the electric field array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L342-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.ndims-Tuple{ScalarField}" href="#Base.ndims-Tuple{ScalarField}"><code>Base.ndims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ndims(u::ScalarField, spatial::Bool=false) -&gt; Int</code></pre><p>Return number of dimensions. If <code>spatial=true</code>, returns only spatial dimensions (Nd), otherwise returns total dimensions of the electric field array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L351-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{ScalarField}" href="#Base.eltype-Tuple{ScalarField}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eltype(u::ScalarField) -&gt; Type</code></pre><p>Return the element type of the electric field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L360-L364">source</a></section></article><h3 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Get dimensions
nx, ny = size(u)[1:2]
n_modes = size(u, 3)

# Number of dimensions
ndims(u)           # Total dimensions
ndims(u, true)     # Spatial dimensions only

# Element type
eltype(u)  # ComplexF64 or ComplexF32</code></pre><h2 id="Tilt-Management"><a class="docs-heading-anchor" href="#Tilt-Management">Tilt Management</a><a id="Tilt-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Tilt-Management" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.set_field_tilts" href="#FluxOptics.Fields.set_field_tilts"><code>FluxOptics.Fields.set_field_tilts</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_field_tilts(u::ScalarField, tilts) -&gt; ScalarField</code></pre><p>Create a new ScalarField with updated tilts, preserving all other parameters.</p><p>This function creates a copy with new tilt values while keeping the same field data, spatial grid, and wavelengths.</p><p><strong>Arguments</strong></p><ul><li><code>u::ScalarField</code>: Original field.</li><li><code>tilts</code>: New tilt values as <code>(θx, θy)</code> tuple, where each component can be scalar or array.</li></ul><p><strong>Returns</strong></p><p>New <code>ScalarField</code> with updated tilts.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064; tilts=(0.01, 0.0));

julia&gt; u_tilted = set_field_tilts(u, (0.02, 0.01));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L221-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.offset_tilts!" href="#FluxOptics.Fields.offset_tilts!"><code>FluxOptics.Fields.offset_tilts!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">offset_tilts!(u::ScalarField, tilts)</code></pre><p>Add offset to existing tilts and apply corresponding linear phase to the field in-place.</p><p>This function modifies both the tilt metadata and the electric field by:</p><ol><li>Adding the offset to the stored tilt values</li><li>Multiplying the field by <code>exp(i 2π/λ (Δθx⋅x + Δθy⋅y))</code> to maintain consistency</li></ol><p>This shifts the reference frame without rotating the angular spectrum.</p><p><strong>Arguments</strong></p><ul><li><code>u::ScalarField</code>: Field to modify.</li><li><code>tilts</code>: Tilt offsets as <code>(Δθx, Δθy)</code> tuple in radians.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = ScalarField(ones(ComplexF64, 4, 4), (1.0, 1.0), 1.064; tilts=(0.01, 0.0));

julia&gt; offset_tilts!(u, (0.005, 0.005));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L258-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.is_on_axis" href="#FluxOptics.Fields.is_on_axis"><code>FluxOptics.Fields.is_on_axis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_on_axis(u::ScalarField) -&gt; Bool</code></pre><p>Check if the field has zero tilts (on-axis propagation).</p><p>Returns <code>true</code> if all tilt components are zero, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L247-L253">source</a></section></article><h3 id="Examples-4"><a class="docs-heading-anchor" href="#Examples-4">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-4" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Set new tilts
u_tilted = set_field_tilts(u, (0.02, 0.015))

# Add tilt offset (modifies tilts and applies phase)
offset_tilts!(u, (0.01, 0.005))

# Check if on-axis
is_on_axis(u)  # true/false</code></pre><h2 id="Power-and-Intensity"><a class="docs-heading-anchor" href="#Power-and-Intensity">Power and Intensity</a><a id="Power-and-Intensity-1"></a><a class="docs-heading-anchor-permalink" href="#Power-and-Intensity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.power" href="#FluxOptics.Fields.power"><code>FluxOptics.Fields.power</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">power(u::ScalarField)</code></pre><p>Compute the optical power of the field.</p><p>Calculates the spatial integral of the intensity |u|² over the field domain, properly accounting for the spatial sampling.</p><p><strong>Mathematical definition</strong></p><p>P = ∫∫ |u(x,y)|² dx dy ≈ Σᵢⱼ |u[i,j]|² × dx × dy.</p><p><strong>Returns</strong></p><p>Array of power value(s) with same dimensions as <code>u</code>, spatial dimensions being reduced to size 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; data = rand(ComplexF64, 4, 4, 3);

julia&gt; u = ScalarField(data, (1.0, 1.0), 1.064);

julia&gt; P = power(u);  # Returns 1×1×3 Array</code></pre><p>See also: <a href="#FluxOptics.Fields.normalize_power!"><code>normalize_power!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L812-L838">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.normalize_power!" href="#FluxOptics.Fields.normalize_power!"><code>FluxOptics.Fields.normalize_power!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize_power!(u::ScalarField, target_power=1)</code></pre><p>Normalize the field to have specified optical power (in-place modification).</p><p>Scales the field amplitudes so that the total optical power equals the target values. This is useful for setting consistent power levels between different fields.</p><p><strong>Arguments</strong></p><ul><li><code>u::ScalarField</code>: Field to normalize (modified in-place)</li><li><code>target_power=1</code>: Target power value(s) - can be a scalar Real or AbstractArray{Real} as long as it can be broadcasted on the field data.</li></ul><p><strong>Returns</strong></p><p>The modified field <code>u</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; u = ScalarField(rand(ComplexF64, 4, 4, 3), (1.0, 1.0), 1.064);

julia&gt; normalize_power!(u);        # Normalize all fields to 1 W

julia&gt; normalize_power!(u, 1e-3);  # Normalize all fields to 1 mW

julia&gt; all(x -&gt; isapprox(x, 1e-3), power(u))
true

julia&gt; # For multiple fields: normalize each field separately

julia&gt; power_values = reshape([1e-3, 2e-3, 3e-3], 1, 1, 3);

julia&gt; normalize_power!(u, power_values);  # Different power per field

julia&gt; isapprox(power(u), power_values)
true</code></pre><p>See also: <a href="#FluxOptics.Fields.power"><code>power</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L844-L884">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.intensity" href="#FluxOptics.Fields.intensity"><code>FluxOptics.Fields.intensity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intensity(u::AbstractArray, nd::Integer=2)
intensity(u::ScalarField)</code></pre><p>Compute the total intensity |u|² of optical fields or arrays.</p><p>Calculates intensity by summing |u|² over all extra dimensions beyond the spatial ones, returning the combined intensity distribution for the spatial dimensions only.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractArray</code>: Array of complex values.</li><li><code>nd::Integer=2</code>: Number of spatial dimensions (for AbstractArray case only).</li><li><code>u::ScalarField</code>: Optical field with potentially multiple modes.</li></ul><p><strong>Mathematical definition</strong></p><p>I[i,j] = Σₖ |u[i,j,k]|² where k runs over all extra dimensions</p><p><strong>Returns</strong></p><ul><li><strong>AbstractArray</strong>: Array with spatial dimensions only, extra dims summed.</li><li><strong>ScalarField</strong>: Array with spatial dimensions only, containing total intensity.</li></ul><p><strong>Examples</strong></p><p><strong>AbstractArray case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; data = ones(ComplexF64, 4, 4, 3);  # 2 spatial + 1 extra dim

julia&gt; I = intensity(data, 2);  # Sum over 3rd dimension

julia&gt; size(I)
(4, 4)

julia&gt; I[1,1]
3.0</code></pre><p><strong>ScalarField case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; data = ones(ComplexF64, 4, 4, 3);  # 3 modes

julia&gt; u = ScalarField(data, (1.0, 1.0), 1.064);

julia&gt; I = intensity(u);  # Returns 4×4 array (total intensity of all 3 modes)

julia&gt; size(I)
(4, 4)

julia&gt; I[1,1]
3.0</code></pre><p>See also: <a href="#FluxOptics.Fields.power"><code>power</code></a>, <a href="#FluxOptics.Fields.phase"><code>phase</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L547-L603">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.phase" href="#FluxOptics.Fields.phase"><code>FluxOptics.Fields.phase</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase(u::AbstractArray)
phase(u::ScalarField)</code></pre><p>Compute the phase angle of complex arrays or optical fields.</p><p>Returns the argument (angle) of complex values in radians, preserving array structure. For optical fields, this gives the wavefront phase information across all modes.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractArray</code>: Array of complex values.</li><li><code>u::ScalarField</code>: Optical field (uses underlying data array).</li></ul><p><strong>Mathematical definition</strong></p><p>φ = arg(u) = atan(imag(u), real(u))</p><p><strong>Returns</strong></p><ul><li><strong>AbstractArray</strong>: Array of same dimensions containing phase values in radians [-π, π].</li><li><strong>ScalarField</strong>: Calls <code>phase(u.electric)</code>, returns array with phase values.</li></ul><p><strong>Examples</strong></p><p><strong>AbstractArray case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = [1.0+0.0im, 0.0+1.0im, -1.0+0.0im];

julia&gt; phase(data)
3-element Vector{Float64}:
 0.0
 1.5707963267948966
 3.141592653589793</code></pre><p><strong>ScalarField case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; data = [1.0+0.0im 0.0+1.0im; -1.0+0.0im 0.0-1.0im];

julia&gt; u = ScalarField(data, (1.0, 1.0), 1.064);

julia&gt; phase(u)
2×2 Matrix{Float64}:
 0.0       1.5708
 3.14159  -1.5708</code></pre><p>See also: <a href="#FluxOptics.Fields.intensity"><code>intensity</code></a>, <a href="#FluxOptics.Fields.phase"><code>phase</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L614-L662">source</a></section></article><h3 id="Examples-5"><a class="docs-heading-anchor" href="#Examples-5">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-5" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Single mode field
u = ScalarField(ones(ComplexF64, 128, 128), (2.0, 2.0), 1.064)
P = power(u)  # Returns 1×1 array

# Normalize to 1 W
normalize_power!(u)
@assert isapprox(power(u)[], 1.0)

# Normalize to specific power
normalize_power!(u, 1e-3)  # 1 mW

# Multi-mode field
data = rand(ComplexF64, 64, 64, 3)
u = ScalarField(data, (1.0, 1.0), 1.064)
P = power(u)  # Returns 1×1×3 array

# Different power per mode
target_powers = reshape([1.0, 1.5, 2.0], 1, 1, 3)
normalize_power!(u, target_powers)

# Total intensity (sum over all modes)
I_total = intensity(u)  # Returns 2D array

# Phase extraction
φ = phase(u)  # Returns array same size as u</code></pre><h2 id="Field-Comparison"><a class="docs-heading-anchor" href="#Field-Comparison">Field Comparison</a><a id="Field-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Field-Comparison" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.Fields.coupling_efficiency" href="#FluxOptics.Fields.coupling_efficiency"><code>FluxOptics.Fields.coupling_efficiency</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coupling_efficiency(u, v)
coupling_efficiency(u::ScalarField, v::ScalarField)</code></pre><p>Compute the power coupling efficiency between two optical fields.</p><p>For multi-dimensional fields, computes power coupling efficiency between corresponding field distributions (same extra dimension indices). This normalized metric returns values between 0 and 1, representing the fraction of power that would be transferred from field u to field v.</p><p><strong>Mathematical definition</strong></p><p>η = |⟨u,v⟩|² / (‖u‖ ‖v‖)</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: First field (ScalarField or AbstractArray).</li><li><code>v</code>: Second field with same spatial dimensions as <code>u</code>.</li></ul><p><strong>Returns</strong></p><ul><li>For AbstractArrays: Scalar coupling efficiency [0,1].</li><li>For ScalarFields: Array of coupling efficiencies, one for each field distribution.</li></ul><p><strong>Examples</strong></p><p><strong>Array case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; u = ones(ComplexF64, 4, 4);

julia&gt; v = ones(ComplexF64, 4, 4);

julia&gt; coupling_efficiency(u, v)
1.0</code></pre><p><strong>ScalarField single-mode case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; field1_data = ones(ComplexF64, 4, 4);

julia&gt; field2_data = ones(ComplexF64, 4, 4);

julia&gt; u = ScalarField(field1_data, (1.0, 1.0), 1.064);

julia&gt; v = ScalarField(field2_data, (1.0, 1.0), 1.064);

julia&gt; coupling_efficiency(u, v)
1-element Vector{Float64}:
 1.0</code></pre><p><strong>ScalarField multi-mode case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; field1_data = ones(ComplexF64, 4, 4, 3);

julia&gt; field2_data = ones(ComplexF64, 4, 4, 3);

julia&gt; u = ScalarField(field1_data, (1.0, 1.0), 1.064);

julia&gt; v = ScalarField(field2_data, (1.0, 1.0), 1.064);

julia&gt; coupling_efficiency(u, v)
3-element Vector{Float64}:
 1.0
 1.0
 1.0</code></pre><p>See also: <a href="#FluxOptics.Fields.power"><code>power</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L671-L743">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{ScalarField}" href="#LinearAlgebra.dot-Tuple{ScalarField}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(u::ScalarField, v::ScalarField)</code></pre><p>Compute the inner product ⟨u,v⟩ between two optical fields.</p><p>For multi-dimensional fields, computes the dot product between corresponding field distributions (same extra dimension indices).</p><p><strong>Mathematical definition</strong></p><p>⟨u,v⟩ = ∫∫ u<em>(x,y) v(x,y) dx dy ≈ Σᵢⱼ u</em>[i,j] v[i,j]</p><p><strong>Arguments</strong></p><ul><li><code>u::ScalarField</code>: First field.</li><li><code>v::ScalarField</code>: Second field with same spatial dimensions as <code>u</code>.</li></ul><p><strong>Returns</strong></p><p>Vector of complex inner products, one for each field distribution.</p><p><strong>Examples</strong></p><p><strong>Single-mode case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; field1_data = rand(ComplexF64, 4, 4);

julia&gt; field2_data = rand(ComplexF64, 4, 4);

julia&gt; u = ScalarField(field1_data, (1.0, 1.0), 1.064);

julia&gt; v = ScalarField(field2_data, (1.0, 1.0), 1.064);

julia&gt; overlap = dot(u, v);  # 0-dimensional Array storing the complex overlap integral</code></pre><p><strong>Multi-mode case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; field1_data = rand(ComplexF64, 4, 4, 3);

julia&gt; field2_data = rand(ComplexF64, 4, 4, 3);

julia&gt; u = ScalarField(field1_data, (1.0, 1.0), 1.064);

julia&gt; v = ScalarField(field2_data, (1.0, 1.0), 1.064);

julia&gt; overlaps = dot(u, v);  # 3-element Vector of complex overlaps</code></pre><p>See also: <a href="#FluxOptics.Fields.coupling_efficiency"><code>coupling_efficiency</code></a>, <a href="#LinearAlgebra.dot-Tuple{ScalarField}"><code>dot</code></a>, <a href="#FluxOptics.Fields.power"><code>power</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L754-L805">source</a></section></article><h3 id="Examples-6"><a class="docs-heading-anchor" href="#Examples-6">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-6" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Modal overlap integral
u1 = ScalarField(gaussian1(xv, yv), (2.0, 2.0), 1.064)
u2 = ScalarField(gaussian2(xv, yv), (2.0, 2.0), 1.064)

overlap = dot(u1, u2)  # Complex overlap
η = coupling_efficiency(u1, u2)  # Real, between 0 and 1

# Multi-mode fields
data1 = rand(ComplexF64, 64, 64, 3)
data2 = rand(ComplexF64, 64, 64, 3)
u1 = ScalarField(data1, (2.0, 2.0), 1.064)
u2 = ScalarField(data2, (2.0, 2.0), 1.064)

overlaps = dot(u1, u2)  # 3-element array
efficiencies = coupling_efficiency(u1, u2)  # 3-element array</code></pre><h2 id="Vectorization"><a class="docs-heading-anchor" href="#Vectorization">Vectorization</a><a id="Vectorization-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vec-Tuple{ScalarField}" href="#Base.vec-Tuple{ScalarField}"><code>Base.vec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vec(u::AbstractArray, nd::Integer=2)
vec(u::ScalarField)</code></pre><p>Convert multi-dimensional arrays or fields into vector of slices.</p><p>For AbstractArray, splits along dimensions beyond the first <code>nd</code> spatial dimensions. For ScalarField, converts into vector of individual ScalarField objects, each representing a single slice along non-spatial dimensions. Useful for iteration and visualization.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: Array or ScalarField to vectorize.</li><li><code>nd::Integer</code>: Number of spatial dimensions (for AbstractArray case only).</li></ul><p><strong>Returns</strong></p><ul><li>For AbstractArray: Vector of array slices along non-spatial dimensions.</li><li>For ScalarField: Vector of ScalarField objects, one per slice along non-spatial dimensions.</li></ul><p><strong>Examples</strong></p><p><strong>AbstractArray case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; data = ones(4, 4, 3);  # 2 spatial dims + 1 extra

julia&gt; slices = vec(data, 2);  # Split after 2 spatial dimensions

julia&gt; length(slices)
3

julia&gt; size(slices[1])
(4, 4)</code></pre><p><strong>ScalarField case:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wavelengths = [0.8, 1.064, 1.550];

julia&gt; # Small example for documentation - use larger arrays in practice

julia&gt; data = zeros(ComplexF64, 4, 4, 3);

julia&gt; u = ScalarField(data, (1.0, 1.0), wavelengths);

julia&gt; u_vec = vec(u);  # Returns Vector{ScalarField} of length 3

julia&gt; length(u_vec)
3

julia&gt; (u_vec[1].lambdas.val, u_vec[2].lambdas.val, u_vec[3].lambdas.val)
(0.8, 1.064, 1.55)</code></pre><p>See also: <a href="#FluxOptics.Fields.ScalarField"><code>ScalarField</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L484-L539">source</a></section></article><h3 id="Examples-7"><a class="docs-heading-anchor" href="#Examples-7">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-7" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Vectorize into individual ScalarFields
u_vec = vec(u)  # Vector of ScalarField objects

# Iterate over modes
for (i, mode_field) in enumerate(u_vec)
    P_mode = power(mode_field)
    I_mode = intensity(mode_field)
    println(&quot;Mode $i: Power = $(P_mode[])&quot;)
end

# Collect results
powers = [power(mode)[] for mode in u_vec]
peak_intensities = [maximum(intensity(mode)) for mode in u_vec]</code></pre><h2 id="Broadcasting-and-Indexing"><a class="docs-heading-anchor" href="#Broadcasting-and-Indexing">Broadcasting and Indexing</a><a id="Broadcasting-and-Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-and-Indexing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.broadcasted-Tuple{Function, ScalarField}" href="#Base.Broadcast.broadcasted-Tuple{Function, ScalarField}"><code>Base.Broadcast.broadcasted</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">broadcasted(f::Function, u::ScalarField) -&gt; ScalarField</code></pre><p>Apply function <code>f</code> element-wise to the electric field. Returns a new ScalarField with transformed data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L299-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{ScalarField, Any}" href="#Base.getindex-Tuple{ScalarField, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(u::ScalarField, i...)</code></pre><p>Access elements of the electric field. Returns a view into the field data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L335-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{ScalarField}" href="#Base.conj-Tuple{ScalarField}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj(u::ScalarField) -&gt; ScalarField</code></pre><p>Return complex conjugate of the field. Creates a new field with conjugated electric field values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/49f128f93bbeafa988290933e1b5e7d7a81f4b98/src/Fields.jl#L890-L894">source</a></section></article><h3 id="Examples-8"><a class="docs-heading-anchor" href="#Examples-8">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-8" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Broadcasting
u_scaled = 2.0 .* u
u_shifted = u .+ 1.0

# Indexing (returns view)
mode_1 = u[:, :, 1]
row = u[32, :, :]

# Complex conjugate
u_conj = conj(u)</code></pre><h2 id="Technical-Notes"><a class="docs-heading-anchor" href="#Technical-Notes">Technical Notes</a><a id="Technical-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Notes" title="Permalink"></a></h2><h3 id="Data-Layout"><a class="docs-heading-anchor" href="#Data-Layout">Data Layout</a><a id="Data-Layout-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Layout" title="Permalink"></a></h3><ul><li>First <code>Nd</code> dimensions: spatial (x, y for 2D)</li><li>Remaining dimensions: modes, wavelengths, etc.</li><li>Contiguous in memory for performance</li></ul><h3 id="Wavelength-Handling"><a class="docs-heading-anchor" href="#Wavelength-Handling">Wavelength Handling</a><a id="Wavelength-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Wavelength-Handling" title="Permalink"></a></h3><ul><li>Single wavelength: stored as scalar, broadcast to field</li><li>Multiple wavelengths: array broadcasts with extra (non-spatial) dimensions</li></ul><h3 id="Tilt-Handling"><a class="docs-heading-anchor" href="#Tilt-Handling">Tilt Handling</a><a id="Tilt-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Tilt-Handling" title="Permalink"></a></h3><ul><li>Tilts are passed as <code>(θx, θy)</code> tuples (scalars or arrays) to the constructor</li><li>Internally stored as tuple of arrays for in-place modification</li><li>Each tilt component broadcasts with extra (non-spatial) dimensions</li><li>Tilts represent Fourier offset: <code>fx₀ = sin(θx)/λ</code></li></ul><h3 id="Power-Calculation"><a class="docs-heading-anchor" href="#Power-Calculation">Power Calculation</a><a id="Power-Calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Calculation" title="Permalink"></a></h3><ul><li>Power = ∫∫ |u(x,y)|² dx dy</li><li>Numerical integration: <code>P ≈ Σᵢⱼ |u[i,j]|² × dx × dy</code></li><li>Units depend on field amplitude units and spatial units</li></ul><h3 id="Intensity-vs-Power"><a class="docs-heading-anchor" href="#Intensity-vs-Power">Intensity vs Power</a><a id="Intensity-vs-Power-1"></a><a class="docs-heading-anchor-permalink" href="#Intensity-vs-Power" title="Permalink"></a></h3><ul><li><strong>Intensity</strong>: |u(x,y)|² (per unit area)</li><li><strong>Power</strong>: Spatial integral of intensity</li><li>For multi-mode: intensity sums over modes, power is per-mode</li></ul><h3 id="Coupling-Efficiency"><a class="docs-heading-anchor" href="#Coupling-Efficiency">Coupling Efficiency</a><a id="Coupling-Efficiency-1"></a><a class="docs-heading-anchor-permalink" href="#Coupling-Efficiency" title="Permalink"></a></h3><ul><li>η = |⟨u₁,u₂⟩|² / (‖u₁‖ ‖u₂‖)</li><li>Always real, between 0 and 1</li><li>Insensitive to global phase</li><li>Equals 1 for identical fields</li></ul><h3 id="Memory-Considerations"><a class="docs-heading-anchor" href="#Memory-Considerations">Memory Considerations</a><a id="Memory-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Considerations" title="Permalink"></a></h3><ul><li><code>copy()</code> creates independent copy of data</li><li><code>similar()</code> allocates uninitialized memory</li><li><code>set_field_data()</code> creates new field using provided data and same other parameters</li><li>Use views for slicing without copying</li></ul><h2 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h2><ol><li><strong>Pre-allocate</strong>: Use <code>similar()</code> for temporary fields</li><li><strong>In-place operations</strong>: Modify <code>.electric</code> directly when possible</li><li><strong>Avoid unnecessary copies</strong>: Use <code>set_field_data()</code> or views</li><li><strong>Vectorization</strong>: Use <code>vec()</code> only when needed for iteration</li><li><strong>GPU</strong>: Field data can be moved to GPU with <code>CUDA.cu(u)</code></li></ol><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../../modes/">Modes</a> for generating field data</li><li><a href="../../gridutils/">GridUtils</a> for coordinate systems</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Fields</a><a class="docs-footer-nextpage" href="../../metrics/">Metrics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 5 October 2025 18:34">Sunday 5 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
