<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · FluxOptics.jl</title><meta name="title" content="API · FluxOptics.jl"/><meta property="og:title" content="API · FluxOptics.jl"/><meta property="twitter:title" content="API · FluxOptics.jl"/><meta name="description" content="Documentation for FluxOptics.jl."/><meta property="og:description" content="Documentation for FluxOptics.jl."/><meta property="twitter:description" content="Documentation for FluxOptics.jl."/><meta property="og:url" content="https://anscoil.github.io/FluxOptics.jl/api/optimisers/optimisers/"/><meta property="twitter:url" content="https://anscoil.github.io/FluxOptics.jl/api/optimisers/optimisers/"/><link rel="canonical" href="https://anscoil.github.io/FluxOptics.jl/api/optimisers/optimisers/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="FluxOptics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">FluxOptics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../../tutorials/01_FoxLi_simulation/">FoxLi Simulation</a></li><li><a class="tocitem" href="../../../tutorials/02_field_retrieval/">Field Retrieval</a></li><li><a class="tocitem" href="../../../tutorials/03_RGB_beam_shaping/">Multi-Wavelength Beam Shaping</a></li><li><a class="tocitem" href="../../../tutorials/04_waveguide_tomography/">Waveguide Tomography</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../">API Reference</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">GridUtils</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../gridutils/">GridUtils</a></li><li><a class="tocitem" href="../../gridutils/gridutils/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Modes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../modes/">Modes</a></li><li><a class="tocitem" href="../../modes/modes/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../fields/">Fields</a></li><li><a class="tocitem" href="../../fields/fields/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Optical Components</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/">Optical Components</a></li><li><input class="collapse-toggle" id="menuitem-3-5-2" type="checkbox"/><label class="tocitem" for="menuitem-3-5-2"><span class="docs-label">Core</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/core/">Core</a></li><li><a class="tocitem" href="../../optical_components/core/core/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5-3" type="checkbox"/><label class="tocitem" for="menuitem-3-5-3"><span class="docs-label">Sources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/sources/">Sources</a></li><li><a class="tocitem" href="../../optical_components/sources/sources/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5-4" type="checkbox"/><label class="tocitem" for="menuitem-3-5-4"><span class="docs-label">Modulators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/modulators/">Modulators</a></li><li><a class="tocitem" href="../../optical_components/modulators/modulators/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5-5"><span class="docs-label">Fourier</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/fourier/">Fourier</a></li><li><a class="tocitem" href="../../optical_components/fourier/fourier/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5-6" type="checkbox"/><label class="tocitem" for="menuitem-3-5-6"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/utilities/">Utilities</a></li><li><a class="tocitem" href="../../optical_components/utilities/utilities/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5-7" type="checkbox"/><label class="tocitem" for="menuitem-3-5-7"><span class="docs-label">Free-Space Propagators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/freespace/">Free-Space Propagators</a></li><li><a class="tocitem" href="../../optical_components/freespace/freespace/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5-8" type="checkbox"/><label class="tocitem" for="menuitem-3-5-8"><span class="docs-label">Bulk Propagators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/bulk/">Bulk Propagators</a></li><li><a class="tocitem" href="../../optical_components/bulk/bulk/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5-9" type="checkbox"/><label class="tocitem" for="menuitem-3-5-9"><span class="docs-label">Active Media</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/active/">Active Media</a></li><li><a class="tocitem" href="../../optical_components/active/active_media/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5-10" type="checkbox"/><label class="tocitem" for="menuitem-3-5-10"><span class="docs-label">System</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../optical_components/system/">System</a></li><li><a class="tocitem" href="../../optical_components/system/system/">API</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox" checked/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">OptimisersExt</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">OptimisersExt</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Setup-and-Update"><span>Setup and Update</span></a></li><li><a class="tocitem" href="#Optimization-Rules"><span>Optimization Rules</span></a></li><li><a class="tocitem" href="#Proximal-Operators"><span>Proximal Operators</span></a></li><li><a class="tocitem" href="#Optimization-Patterns"><span>Optimization Patterns</span></a></li><li><a class="tocitem" href="#Technical-Notes"><span>Technical Notes</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Metrics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../metrics/">Metrics</a></li><li><a class="tocitem" href="../../metrics/metrics/">API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Plotting</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../plotting/">Plotting</a></li><li><a class="tocitem" href="../../plotting/plotting/">API</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li><a class="is-disabled">OptimisersExt</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/anscoil/FluxOptics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/anscoil/FluxOptics.jl/blob/main/docs/src/api/optimisers/optimisers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OptimisersExt-API"><a class="docs-heading-anchor" href="#OptimisersExt-API">OptimisersExt API</a><a id="OptimisersExt-API-1"></a><a class="docs-heading-anchor-permalink" href="#OptimisersExt-API" title="Permalink"></a></h1><h2 id="Setup-and-Update"><a class="docs-heading-anchor" href="#Setup-and-Update">Setup and Update</a><a id="Setup-and-Update-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-and-Update" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.make_rules" href="#FluxOptics.OptimisersExt.make_rules"><code>FluxOptics.OptimisersExt.make_rules</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_rules(pairs::Pair{&lt;:AbstractArray, &lt;:AbstractRule}...)
make_rules(pairs::Pair{&lt;:AbstractOpticalComponent, &lt;:AbstractRule}...)</code></pre><p>Create a dictionary of optimization rules for specific parameters or optical components.</p><p>This function creates an <code>IdDict</code> that maps parameter arrays to their corresponding optimization rules. This allows different parts of the optical system to use different optimizers (e.g., different learning rates, different algorithms).</p><p><strong>Arguments</strong></p><ul><li><code>pairs</code>: Pairs of (parameter/component, rule) where:<ul><li>First element: <code>AbstractArray</code> (parameter) or <code>AbstractOpticalComponent</code> </li><li>Second element: <code>AbstractRule</code> (optimization rule like <code>Descent(0.01)</code>)</li></ul></li></ul><p><strong>Returns</strong></p><p><code>IdDict{AbstractArray, AbstractRule}</code> mapping parameter arrays to optimization rules.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = ScalarField(zeros(ComplexF64, 64, 64), (2.0, 2.0), 1.064);

julia&gt; phase_mask = Phase(u, (x, y) -&gt; 0.1*(x^2 + y^2); trainable=true);

julia&gt; source = ScalarSource(u; trainable=true);

julia&gt; rules = make_rules(
           phase_mask =&gt; Descent(0.01),    # Slow learning for phase
           source =&gt; Descent(0.1)     # Fast learning for source
       );

julia&gt; typeof(rules)
IdDict{AbstractArray, Optimisers.AbstractRule}

julia&gt; length(rules)
2

julia&gt; opt_state = setup(rules, source |&gt; phase_mask);</code></pre><p>See also: <a href="#Optimisers.setup-Tuple{IdDict}"><code>setup</code></a>, <a href="#ProxRule"><code>ProxRule</code></a>, <a href="../../optical_components/modulators/modulators/#FluxOptics.OpticalComponents.Phase"><code>Phase</code></a>, <a href="../../optical_components/sources/sources/#FluxOptics.OpticalComponents.ScalarSource"><code>ScalarSource</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/OptimisersExt.jl#L153-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Optimisers.setup-Tuple{IdDict}" href="#Optimisers.setup-Tuple{IdDict}"><code>Optimisers.setup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setup(rules::IdDict{&lt;:AbstractArray, &lt;:AbstractRule}, model)
setup(rules::IdDict{&lt;:AbstractArray, &lt;:AbstractRule}, default_rule::AbstractRule, model)</code></pre><p>Set up optimization state with different rules for different parameters.</p><p>This extends <code>Optimisers.setup</code> to accept a dictionary of rules, allowing fine-grained control over which optimizer is used for which parameters. Parameters not in the rules dictionary use the default rule (or <code>NoDescent()</code> if no default provided).</p><p><strong>Arguments</strong></p><ul><li><code>rules</code>: Dictionary mapping parameter arrays to optimization rules</li><li><code>default_rule</code>: Default rule for parameters not in the rules dictionary</li><li><code>model</code>: The model/parameters to optimize</li></ul><p><strong>Returns</strong></p><p>Nested optimization state structure matching the model structure.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = ScalarField(zeros(ComplexF64, 32, 32), (2.0, 2.0), 1.064);

julia&gt; phase_mask = Phase(u, (x, y) -&gt; 0.0; trainable=true);

julia&gt; mask = Mask(u, (x, y) -&gt; 1.0; trainable=true);

julia&gt; rules = make_rules(
           phase_mask =&gt; Descent(0.01),
           mask =&gt; Momentum(0.1, 0.9)
       );

julia&gt; u = ScalarField(zeros(ComplexF64, 32, 32), (2.0, 2.0), 1.064);

julia&gt; source = ScalarSource(u; trainable=true);

julia&gt; opt_state = setup(rules, NoDescent(), source |&gt; phase_mask |&gt; mask);</code></pre><p>See also: <a href="#FluxOptics.OptimisersExt.make_rules"><code>make_rules</code></a>, <code>Optimisers.update!</code>, <a href="#ProxRule"><code>ProxRule</code></a>, <a href="#FluxOptics.OptimisersExt.NoDescent"><code>NoDescent</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/OptimisersExt.jl#L84-L123">source</a></section></article><p><strong>Note:</strong> <code>update!(opt_state, params, grads)</code> is re-exported from <a href="https://fluxml.ai/Optimisers.jl/stable/api/#Optimisers.update!">Optimisers.jl</a>. It applies the optimization step to update parameters. See their documentation for details.</p><h2 id="Optimization-Rules"><a class="docs-heading-anchor" href="#Optimization-Rules">Optimization Rules</a><a id="Optimization-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Rules" title="Permalink"></a></h2><h3 id="Custom-Rules"><a class="docs-heading-anchor" href="#Custom-Rules">Custom Rules</a><a id="Custom-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Rules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.Fista" href="#FluxOptics.OptimisersExt.Fista"><code>FluxOptics.OptimisersExt.Fista</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fista(η)</code></pre><p>Fast Iterative Shrinkage-Thresholding Algorithm (FISTA) optimizer.</p><p>FISTA is an accelerated gradient method particularly effective for problems with proximal operators. It provides faster convergence than standard gradient descent for sparse and constrained optimization problems common in computational optics.</p><p><strong>Arguments</strong></p><ul><li><code>η</code>: Learning rate (stored as η²)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fista_opt = Fista(0.1);

julia&gt; sparse_rule = ProxRule(Fista(0.05), IstaProx(0.001, 0.0));  # Sparse optimization</code></pre><p>See also: <a href="#ProxRule"><code>ProxRule</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.IstaProx"><code>IstaProx</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.TVProx"><code>TVProx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/OptimisersExt.jl#L12-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.NoDescent" href="#FluxOptics.OptimisersExt.NoDescent"><code>FluxOptics.OptimisersExt.NoDescent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoDescent()</code></pre><p>No-operation optimizer that performs no parameter updates.</p><p>Useful as a default rule for parameters that should remain fixed during optimization, or for ablation studies where you want to disable optimization for certain components.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">rules = make_rules(
           fixed_component =&gt; NoDescent(),    # Don&#39;t optimize this
           active_component =&gt; Descent(0.01)  # Optimize this one
       );</code></pre><p>See also: <a href="#FluxOptics.OptimisersExt.make_rules"><code>make_rules</code></a>, <a href="#Optimisers.setup-Tuple{IdDict}"><code>setup</code></a>, <a href="#ProxRule"><code>ProxRule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/OptimisersExt.jl#L56-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.ProximalOperators.ProxRule" href="#FluxOptics.OptimisersExt.ProximalOperators.ProxRule"><code>FluxOptics.OptimisersExt.ProximalOperators.ProxRule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProxRule(rule::AbstractRule, prox::AbstractProximalOperator)</code></pre><p>Combine an optimization rule with a proximal operator.</p><p>This creates a composite optimization rule that first applies the standard optimization step, then applies a proximal operator for regularization or constraints. This is useful for constrained optimization in inverse optics design.</p><p><strong>Arguments</strong></p><ul><li><code>rule</code>: Base optimization rule (e.g., <code>Descent</code>, <code>Momentum</code>)</li><li><code>prox</code>: Proximal operator to apply after the optimization step</li></ul><p><strong>Returns</strong></p><p><code>ProxRule</code> that applies both the optimizer and proximal operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prox_descent = ProxRule(Descent(0.01), PositiveProx());  # Positive constraint

julia&gt; tv_regularized = ProxRule(Momentum(0.1, 0.9), TVProx(0.001));  # TV regularization

julia&gt; clamped = ProxRule(Descent(0.05), ClampProx(0.0, 1.0));  # Clamp to [0,1]</code></pre><p>See also: <a href="#FluxOptics.OptimisersExt.ProximalOperators.IstaProx"><code>IstaProx</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.TVProx"><code>TVProx</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.ClampProx"><code>ClampProx</code></a>, <a href="#FluxOptics.OptimisersExt.Fista"><code>Fista</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/proximal_operators/ProximalOperators.jl#L71-L97">source</a></section></article><h3 id="From-Optimisers.jl"><a class="docs-heading-anchor" href="#From-Optimisers.jl">From Optimisers.jl</a><a id="From-Optimisers.jl-1"></a><a class="docs-heading-anchor-permalink" href="#From-Optimisers.jl" title="Permalink"></a></h3><p>FluxOptics also exports standard rules from Optimisers.jl:</p><ul><li><code>Descent(η)</code>: Gradient descent with learning rate η</li><li><code>Momentum(η, ρ)</code>: Momentum optimizer</li><li><code>Nesterov(η, ρ)</code>: Nesterov accelerated gradient</li></ul><p>See <a href="https://fluxml.ai/Optimisers.jl/stable/">Optimisers.jl documentation</a> for more rules (Adam, AdaGrad, etc.).</p><h2 id="Proximal-Operators"><a class="docs-heading-anchor" href="#Proximal-Operators">Proximal Operators</a><a id="Proximal-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Proximal-Operators" title="Permalink"></a></h2><h3 id="Abstract-Type"><a class="docs-heading-anchor" href="#Abstract-Type">Abstract Type</a><a id="Abstract-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Type" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.ProximalOperators.AbstractProximalOperator" href="#FluxOptics.OptimisersExt.ProximalOperators.AbstractProximalOperator"><code>FluxOptics.OptimisersExt.ProximalOperators.AbstractProximalOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractProximalOperator</code></pre><p>Abstract base type for proximal-like operators used in constrained optimization.</p><p>In the classical sense, proximal operators implement:</p><pre><code class="nohighlight hljs">prox_λf(x) = argmin_z { f(z) + (1/2λ)||z - x||² }</code></pre><p>However, this module takes a <strong>pragmatic approach</strong> and includes:</p><ul><li><strong>Exact proximal operators</strong>: Mathematically rigorous (e.g., soft thresholding)</li><li><strong>Projections</strong>: Onto constraint sets (e.g., ClampProx, PositiveProx)</li><li><strong>Plug-and-play operators</strong>: Operators that work well empirically for inverse problems,  even without strict proximal interpretation (e.g., learned denoisers, heuristic constraints)</li></ul><p>This flexibility follows the spirit of plug-and-play priors in computational imaging,  where practical performance often matters more than theoretical guarantees.</p><p><strong>Interface</strong></p><p>Subtypes must implement:</p><ul><li><code>init(prox::AbstractProximalOperator, x::AbstractArray)</code>: Initialize operator state</li><li><code>apply!(prox::AbstractProximalOperator, state, x::AbstractArray)</code>: Apply operator in-place</li></ul><p><strong>Available Operators</strong></p><ul><li><a href="#FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx"><code>PointwiseProx</code></a>: Apply function element-wise (custom constraints)</li><li><a href="#FluxOptics.OptimisersExt.ProximalOperators.ClampProx"><code>ClampProx</code></a>: Box constraints [a, b]</li><li><a href="#FluxOptics.OptimisersExt.ProximalOperators.PositiveProx"><code>PositiveProx</code></a>: Non-negativity constraint</li><li><a href="#FluxOptics.OptimisersExt.ProximalOperators.IstaProx"><code>IstaProx</code></a>: Soft thresholding (exact prox of L1 norm)</li><li><a href="#FluxOptics.OptimisersExt.ProximalOperators.TVProx"><code>TVProx</code></a>: Total variation denoising (approximate prox)</li></ul><p><strong>Composition</strong></p><p>Operators can be composed with <code>∘</code>:</p><pre><code class="language-julia hljs">combined = ClampProx(0.0, 1.0) ∘ PositiveProx()</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Use with ProxRule
prox = ClampProx(-π, π)
rule = ProxRule(Descent(0.01), prox)

# Compose multiple constraints
prox = ClampProx(0.0, 1.0) ∘ PositiveProx()
rule = ProxRule(Momentum(0.1, 0.9), prox)</code></pre><p><strong>References</strong></p><p>For plug-and-play priors: Venkatakrishnan et al., &quot;Plug-and-Play Priors for Model Based Reconstruction&quot; (2013)</p><p>See also: <a href="#ProxRule"><code>ProxRule</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.IstaProx"><code>IstaProx</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.TVProx"><code>TVProx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/proximal_operators/ProximalOperators.jl#L11-L68">source</a></section></article><h3 id="Pointwise-Operators"><a class="docs-heading-anchor" href="#Pointwise-Operators">Pointwise Operators</a><a id="Pointwise-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Pointwise-Operators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx" href="#FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx"><code>FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PointwiseProx(f)</code></pre><p>Apply a function pointwise as a proximal operator.</p><p>Creates a proximal operator that applies function <code>f</code> element-wise to the parameter array. The function should take the current parameter value and return the projected/regularized value.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function to apply element-wise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; clamp_prox = PointwiseProx(x -&gt; clamp(x, -1, 1));

julia&gt; threshold_prox = PointwiseProx(x -&gt; abs(x) &lt; 0.1 ? 0 : x);

julia&gt; model = randn(10, 10);

julia&gt; prox_state = ProximalOperators.init(clamp_prox, model);

julia&gt; ProximalOperators.apply!(clamp_prox, prox_state, model);

julia&gt; all(x -&gt; -1 ≤ x ≤ 1, model)  # All values clamped
true</code></pre><p>See also: <a href="#FluxOptics.OptimisersExt.ProximalOperators.ClampProx"><code>ClampProx</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.PositiveProx"><code>PositiveProx</code></a>, <a href="#ProxRule"><code>ProxRule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/proximal_operators/pointwise_prox.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.ProximalOperators.ClampProx" href="#FluxOptics.OptimisersExt.ProximalOperators.ClampProx"><code>FluxOptics.OptimisersExt.ProximalOperators.ClampProx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ClampProx(lo, hi)</code></pre><p>Clamp values to the range [lo, hi].</p><p>Simple box constraint proximal operator that projects parameters onto a box. Useful for physically meaningful constraints (e.g., transmittance ∈ [0,1]).</p><p><strong>Arguments</strong></p><ul><li><code>lo</code>: Lower bound</li><li><code>hi</code>: Upper bound</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_clamp = ClampProx(0.0, 1.0);  # Unit interval

julia&gt; phase_clamp = ClampProx(-π, π);    # Phase wrapping alternative

julia&gt; x = [-0.5, 0.3, 1.2, 0.8];

julia&gt; prox_state = ProximalOperators.init(unit_clamp, x);

julia&gt; ProximalOperators.apply!(unit_clamp, prox_state, x);

julia&gt; x  # Values clamped to [0,1]
4-element Vector{Float64}:
 0.0
 0.3
 1.0
 0.8</code></pre><p>See also: <a href="#FluxOptics.OptimisersExt.ProximalOperators.PositiveProx"><code>PositiveProx</code></a>, <a href="#ProxRule"><code>ProxRule</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx"><code>PointwiseProx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/proximal_operators/clamp_prox.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.ProximalOperators.PositiveProx" href="#FluxOptics.OptimisersExt.ProximalOperators.PositiveProx"><code>FluxOptics.OptimisersExt.ProximalOperators.PositiveProx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PositiveProx()</code></pre><p>Project values onto the non-negative orthant (set negative values to zero).</p><p>Simple constraint for physical parameters that must be non-negative, such as intensities, thicknesses, or absorption coefficients.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pos_prox = PositiveProx();

julia&gt; x = [-0.1, 0.0, 0.5, -0.3, 1.2];

julia&gt; prox_state = ProximalOperators.init(pos_prox, x);

julia&gt; ProximalOperators.apply!(pos_prox, prox_state, x);

julia&gt; x  # Negative values set to zero
5-element Vector{Float64}:
 0.0
 0.0
 0.5
 0.0
 1.2</code></pre><p>See also: <a href="#FluxOptics.OptimisersExt.ProximalOperators.ClampProx"><code>ClampProx</code></a>, <a href="#ProxRule"><code>ProxRule</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx"><code>PointwiseProx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/proximal_operators/positive_prox.jl#L9-L37">source</a></section></article><h3 id="Sparsity-and-Regularization"><a class="docs-heading-anchor" href="#Sparsity-and-Regularization">Sparsity and Regularization</a><a id="Sparsity-and-Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Sparsity-and-Regularization" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.ProximalOperators.IstaProx" href="#FluxOptics.OptimisersExt.ProximalOperators.IstaProx"><code>FluxOptics.OptimisersExt.ProximalOperators.IstaProx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IstaProx(λ, center=0)</code></pre><p>Iterative Shrinkage-Thresholding (ISTA) proximal operator for sparse optimization.</p><p>Applies soft thresholding to promote sparsity in the parameters. Values close to <code>center</code> are shrunk towards <code>center</code>, promoting sparse solutions.</p><p><strong>Arguments</strong></p><ul><li><code>λ</code>: Shrinkage parameter (larger values → more sparsity)</li><li><code>center=0</code>: Center value for thresholding</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sparse_prox = IstaProx(0.01, 0.0);  # Shrink towards zero

julia&gt; x = [-0.5, -0.005, 0.0, 0.003, 0.2];

julia&gt; prox_state = ProximalOperators.init(sparse_prox, x);

julia&gt; ProximalOperators.apply!(sparse_prox, prox_state, x);

julia&gt; x  # Small values shrunk to zero
5-element Vector{Float64}:
 -0.49
  0.0
  0.0
  0.0
  0.19</code></pre><p>See also: <a href="#FluxOptics.OptimisersExt.ProximalOperators.PointwiseProx"><code>PointwiseProx</code></a>, <a href="#ProxRule"><code>ProxRule</code></a>, <a href="#FluxOptics.OptimisersExt.Fista"><code>Fista</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/proximal_operators/ista_prox.jl#L21-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.ProximalOperators.TVProx" href="#FluxOptics.OptimisersExt.ProximalOperators.TVProx"><code>FluxOptics.OptimisersExt.ProximalOperators.TVProx</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TVProx(λ, n_iter=50; tol=nothing, isotropic=true, rule=Fista(...))</code></pre><p>Total Variation (TV) regularization proximal operator.</p><p>Apply total variation denoising to promote piecewise smooth solutions in n dimensions.</p><p>This works on arrays of any dimensionality: 1D signals, 2D surfaces, 3D volumes, or higher-dimensional data. Particularly useful for optical applications where smooth profiles are desired while preserving sharp edges.</p><p><strong>Arguments</strong></p><ul><li><code>λ</code>: Regularization strength (larger values → smoother results)</li><li><code>n_iter=50</code>: Maximum number of internal iterations</li><li><code>tol=nothing</code>: Convergence tolerance (if provided)</li><li><code>isotropic=true</code>: Use isotropic TV (L₂ norm of gradient) vs anisotropic (L₁)</li><li><code>rule</code>: Optimization rule for internal TV solver</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tv_smooth = TVProx(0.1, 100; isotropic=false);  # Light anisotropic smoothing

julia&gt; tv_strong = TVProx(1.2, 100);  # Strong isotropic TV

julia&gt; noisy_surface = 1 .+ 0.1*randn(32, 32);

julia&gt; prox_state = ProximalOperators.init(tv_strong, noisy_surface);

julia&gt; strongly_smoothed_surface = ProximalOperators.apply!(tv_strong, prox_state, copy(noisy_surface));</code></pre><p>See also: <a href="#FluxOptics.OptimisersExt.ProximalOperators.TV_denoise!"><code>TV_denoise!</code></a>, <a href="#ProxRule"><code>ProxRule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/proximal_operators/tv_prox.jl#L61-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FluxOptics.OptimisersExt.ProximalOperators.TV_denoise!" href="#FluxOptics.OptimisersExt.ProximalOperators.TV_denoise!"><code>FluxOptics.OptimisersExt.ProximalOperators.TV_denoise!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TV_denoise!(x, λ, n_iter=50; tol=nothing, isotropic=true, rule=Fista(...))</code></pre><p>Apply total variation denoising directly to an n-dimensional array.</p><p>Convenience function that applies TV regularization without setting up the full proximal operator infrastructure. Modifies the input array in-place.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Input array to denoise (modified in-place)</li><li><code>λ</code>: Regularization strength</li><li><code>n_iter=50</code>: Maximum iterations</li><li><code>tol=nothing</code>: Convergence tolerance</li><li><code>isotropic=true</code>: Isotropic vs anisotropic TV</li><li><code>rule</code>: Optimization rule for internal TV solver</li></ul><p><strong>Returns</strong></p><p>The modified input array (for chaining).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Statistics

julia&gt; noisy = randn(64, 64) + 5 * sin.(0.1 * (1:64)) * sin.(0.1 * (1:64)&#39;);

julia&gt; original_var = var(noisy);

julia&gt; TV_denoise!(noisy, 0.1, 100);

julia&gt; denoised_var = var(noisy);

julia&gt; denoised_var &lt; original_var  # Reduced variation
true

julia&gt; # Can chain operations:

julia&gt; result = TV_denoise!(copy(noisy), 0.05) |&gt; x -&gt; clamp.(x, 0, 1);</code></pre><p>See also: <a href="#FluxOptics.OptimisersExt.ProximalOperators.TVProx"><code>TVProx</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.ClampProx"><code>ClampProx</code></a>, <a href="#FluxOptics.OptimisersExt.ProximalOperators.PositiveProx"><code>PositiveProx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anscoil/FluxOptics.jl/blob/26ad7763edc3ea89320ea9c3f73ec50b0427bd59/src/proximal_operators/tv_prox.jl#L197-L237">source</a></section></article><h2 id="Optimization-Patterns"><a class="docs-heading-anchor" href="#Optimization-Patterns">Optimization Patterns</a><a id="Optimization-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Patterns" title="Permalink"></a></h2><h3 id="Sparse-Phase-Mask-Design"><a class="docs-heading-anchor" href="#Sparse-Phase-Mask-Design">Sparse Phase Mask Design</a><a id="Sparse-Phase-Mask-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Phase-Mask-Design" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Encourage sparsity with soft thresholding
sparse_rule = ProxRule(
    Fista(0.01),
    IstaProx(0.001, 0.0)  # L1 penalty
)

rules = make_rules(phase =&gt; sparse_rule)
opt_state = setup(rules, system)</code></pre><h3 id="Smooth-Phase-with-TV-Regularization"><a class="docs-heading-anchor" href="#Smooth-Phase-with-TV-Regularization">Smooth Phase with TV Regularization</a><a id="Smooth-Phase-with-TV-Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Smooth-Phase-with-TV-Regularization" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Total variation for smooth phase profiles
tv_rule = ProxRule(
    Momentum(0.05, 0.9),
    TVProx(0.01)  # Smoothness penalty
)

rules = make_rules(phase =&gt; tv_rule)
opt_state = setup(rules, system)</code></pre><h3 id="Mixed-Optimization-Strategy"><a class="docs-heading-anchor" href="#Mixed-Optimization-Strategy">Mixed Optimization Strategy</a><a id="Mixed-Optimization-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Mixed-Optimization-Strategy" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Different strategies for different components
rules = make_rules(
    phase =&gt; ProxRule(Fista(0.05), ClampProx(-π, π)),       # Constrained
    mask =&gt; ProxRule(Momentum(0.1, 0.9), PositiveProx())    # Positive only
)

opt_state = setup(rules, Descent(0.001), system)</code></pre><h3 id="Freezing-Specific-Components"><a class="docs-heading-anchor" href="#Freezing-Specific-Components">Freezing Specific Components</a><a id="Freezing-Specific-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Freezing-Specific-Components" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Keep some components fixed during optimization
rules = make_rules(
    component_to_freeze =&gt; NoDescent()
)

# Others use default rule
opt_state = setup(rules, Descent(0.01), system)</code></pre><p><strong>Note:</strong> <code>NoDescent()</code> prevents parameter updates but still computes gradients. For better performance when permanently freezing components, create them with <code>trainable=false</code> at construction. However, this requires rebuilding the system to change trainability.</p><h2 id="Technical-Notes"><a class="docs-heading-anchor" href="#Technical-Notes">Technical Notes</a><a id="Technical-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Notes" title="Permalink"></a></h2><h3 id="ProxRule"><a class="docs-heading-anchor" href="#ProxRule">ProxRule</a><a id="ProxRule-1"></a><a class="docs-heading-anchor-permalink" href="#ProxRule" title="Permalink"></a></h3><p><code>ProxRule</code> combines optimization with proximal operators:</p><ol><li>Apply gradient step: <code>x_temp = x - η∇f(x)</code></li><li>Apply proximal operator: <code>x_new = prox(x_temp)</code></li></ol><p>This enables constrained optimization while maintaining differentiability.</p><h3 id="make_rules-Behavior"><a class="docs-heading-anchor" href="#make_rules-Behavior">make_rules Behavior</a><a id="make_rules-Behavior-1"></a><a class="docs-heading-anchor-permalink" href="#make_rules-Behavior" title="Permalink"></a></h3><ul><li>Maps components/arrays to optimization rules</li><li>Extracts trainable arrays from components automatically</li><li>Returns <code>IdDict{AbstractArray, AbstractRule}</code></li><li>Compatible with nested structures (OpticalSystem, sequences)</li></ul><h3 id="setup-with-Rules-Dictionary"><a class="docs-heading-anchor" href="#setup-with-Rules-Dictionary">setup with Rules Dictionary</a><a id="setup-with-Rules-Dictionary-1"></a><a class="docs-heading-anchor-permalink" href="#setup-with-Rules-Dictionary" title="Permalink"></a></h3><ul><li>Parameters in rules dict use specified rules</li><li>Other parameters use default rule (or NoDescent if no default)</li><li>Warning if no trainable parameters found</li></ul><h3 id="Operator-Composition"><a class="docs-heading-anchor" href="#Operator-Composition">Operator Composition</a><a id="Operator-Composition-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-Composition" title="Permalink"></a></h3><p>Proximal operators can be composed with <code>∘</code>:</p><pre><code class="language-julia hljs">combined = ClampProx(0.0, 1.0) ∘ PositiveProx()</code></pre><p>Operators applied right-to-left (like function composition). The resulting operator may not be a rigorous proximal operator but can still be used as a Plug and Play prior.</p><h3 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h3><ul><li>Proximal operators work in-place when possible</li><li>Pre-allocated buffers avoid allocations</li><li>TV denoising uses efficient iterative algorithm</li><li>GPU-compatible (works with CuArrays)</li></ul><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../../metrics/">Metrics</a> for loss functions</li><li><a href="../../fields/">Fields</a> for field operations</li><li><a href="../../optical_components/">OpticalComponents</a> for trainable components</li><li><a href="https://fluxml.ai/Optimisers.jl/stable/">Optimisers.jl</a> for more optimization algorithms</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« OptimisersExt</a><a class="docs-footer-nextpage" href="../../metrics/">Metrics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 23 October 2025 18:34">Thursday 23 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
